/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/grid-editor/grid-editor.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/after/index.js":
/*!*************************************!*\
  !*** ./node_modules/after/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),

/***/ "./node_modules/arraybuffer.slice/index.js":
/*!*************************************************!*\
  !*** ./node_modules/arraybuffer.slice/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),

/***/ "./node_modules/backbone/backbone.js":
/*!*******************************************!*\
  !*** ./node_modules/backbone/backbone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.4.0

//     (c) 2010-2019 Jeremy Ashkenas and DocumentCloud
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global;

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js"), __webpack_require__(/*! jquery */ "jquery-ui"), exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else { var _, $; }

})(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.4.0';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // A private global variable to share between listeners and listenees.
  var _listening;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function(iteratee, events, name, callback, opts) {
    var i = 0, names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length ; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space-separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {
    this._events = eventsApi(onApi, this._events || {}, name, callback, {
      context: context,
      ctx: this,
      listening: _listening
    });

    if (_listening) {
      var listeners = this._listeners || (this._listeners = {});
      listeners[_listening.id] = _listening;
      // Allow the listening to use a counter, instead of tracking
      // callbacks for library interop
      _listening.interop = false;
    }

    return this;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo = function(obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = _listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      this._listenId || (this._listenId = _.uniqueId('l'));
      listening = _listening = listeningTo[id] = new Listening(this, obj);
    }

    // Bind callbacks on obj.
    var error = tryCatchOn(obj, name, callback, this);
    _listening = void 0;

    if (error) throw error;
    // If the target obj is not Backbone.Events, track events manually.
    if (listening.interop) listening.on(name, callback);

    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context, ctx = options.ctx, listening = options.listening;
      if (listening) listening.count++;

      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});
    }
    return events;
  };

  // An try-catch guarded #on function, to prevent poisoning the global
  // `_listening` variable.
  var tryCatchOn = function(obj, name, callback, context) {
    try {
      obj.on(name, callback, context);
    } catch (e) {
      return e;
    }
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off = function(name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
      context: context,
      listeners: this._listeners
    });

    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening = function(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);
    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
      if (listening.interop) listening.off(name, callback);
    }
    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {
    if (!events) return;

    var context = options.context, listeners = options.listeners;
    var i = 0, names;

    // Delete all event listeners and "drop" events.
    if (!name && !context && !callback) {
      for (names = _.keys(listeners); i < names.length; i++) {
        listeners[names[i]].cleanup();
      }
      return;
    }

    names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Find any remaining events.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (
          callback && callback !== handler.callback &&
            callback !== handler.callback._callback ||
              context && context !== handler.context
        ) {
          remaining.push(handler);
        } else {
          var listening = handler.listening;
          if (listening) listening.off(name, callback);
        }
      }

      // Replace events if there are any remaining.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }

    return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once = function(name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
    if (typeof name === 'string' && context == null) callback = void 0;
    return this.on(events, callback, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce = function(obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function() {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger = function(name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, callback, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  // A listening class that tracks and cleans up memory bindings
  // when all callbacks have been offed.
  var Listening = function(listener, obj) {
    this.id = listener._listenId;
    this.listener = listener;
    this.obj = obj;
    this.interop = true;
    this.count = 0;
    this._events = void 0;
  };

  Listening.prototype.on = Events.on;

  // Offs a callback (or several).
  // Uses an optimized counter if the listenee uses Backbone.Events.
  // Otherwise, falls back to manual tracking to support events
  // library interop.
  Listening.prototype.off = function(name, callback) {
    var cleanup;
    if (this.interop) {
      this._events = eventsApi(offApi, this._events, name, callback, {
        context: void 0,
        listeners: void 0
      });
      cleanup = !this._events;
    } else {
      this.count--;
      cleanup = this.count === 0;
    }
    if (cleanup) this.cleanup();
  };

  // Cleans up memory bindings between the listener and the listenee.
  Listening.prototype.cleanup = function() {
    delete this.listener._listeningTo[this.obj._listenId];
    if (!this.interop) delete this.obj._listeners[this.id];
  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.preinitialize.apply(this, arguments);
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    var defaults = _.result(this, 'defaults');
    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the Model.
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset      = options.unset;
      var silent     = options.silent;
      var changes    = [];
      var changing   = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev    = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      var hasChanged;
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
        hasChanged = true;
      }
      return hasChanged ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend({}, options, {validate: true}));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    this.preinitialize.apply(this, arguments);
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Splices `insert` into `array` at index `at`.
  var splice = function(array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    var i;
    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
    for (i = 0; i < length; i++) array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,


    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the Collection.
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model) { return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();
      var removed = this._removeModels(models, options);
      if (!options.silent && removed.length) {
        options.changes = {added: [], merged: [], removed: removed};
        this.trigger('update', this, options);
      }
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      if (models == null) return;

      options = _.extend({}, setOptions, options);
      if (options.parse && !this._isModel(models)) {
        models = this.parse(models, options) || [];
      }

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at > this.length) at = this.length;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toMerge = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && at == null && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model, i;
      for (i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            toMerge.push(existing);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
          return m !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort/update events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length || toMerge.length) {
          options.changes = {
            added: toAdd,
            removed: toRemove,
            merged: toMerge
          };
          this.trigger('update', this, options);
        }
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id, cid, model object with id or cid
    // properties, or an attributes object that is transformed through modelId.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] ||
        this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] ||
        obj.cid && this._byId[obj.cid];
    },

    // Returns `true` if the model is in the collection.
    has: function(obj) {
      return this.get(obj) != null;
    },

    // Get the model at the given index.
    at: function(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = comparator.bind(this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return this.map(attr + '');
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(m, resp, callbackOpts) {
        if (wait) collection.add(m, callbackOpts);
        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function(attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Get an iterator of all models in this collection.
    values: function() {
      return new CollectionIterator(this, ITERATOR_VALUES);
    },

    // Get an iterator of all model IDs in this collection.
    keys: function() {
      return new CollectionIterator(this, ITERATOR_KEYS);
    },

    // Get an iterator of all [ID, model] tuples in this collection.
    entries: function() {
      return new CollectionIterator(this, ITERATOR_KEYSVALUES);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        // Remove references before triggering 'remove' event to prevent an
        // infinite loop. #3693
        delete this._byId[model.cid];
        var id = this.modelId(model.attributes);
        if (id != null) delete this._byId[id];

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function(model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if (model) {
        if ((event === 'add' || event === 'remove') && collection !== this) return;
        if (event === 'destroy') this.remove(model, options);
        if (event === 'change') {
          var prevId = this.modelId(model.previousAttributes());
          var id = this.modelId(model.attributes);
          if (prevId !== id) {
            if (prevId != null) delete this._byId[prevId];
            if (id != null) this._byId[id] = model;
          }
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Defining an @@iterator method implements JavaScript's Iterable protocol.
  // In modern ES2015 browsers, this value is found at Symbol.iterator.
  /* global Symbol */
  var $$iterator = typeof Symbol === 'function' && Symbol.iterator;
  if ($$iterator) {
    Collection.prototype[$$iterator] = Collection.prototype.values;
  }

  // CollectionIterator
  // ------------------

  // A CollectionIterator implements JavaScript's Iterator protocol, allowing the
  // use of `for of` loops in modern browsers and interoperation between
  // Backbone.Collection and other JavaScript functions and third-party libraries
  // which can operate on Iterables.
  var CollectionIterator = function(collection, kind) {
    this._collection = collection;
    this._kind = kind;
    this._index = 0;
  };

  // This "enum" defines the three possible kinds of values which can be emitted
  // by a CollectionIterator that correspond to the values(), keys() and entries()
  // methods on Collection, respectively.
  var ITERATOR_VALUES = 1;
  var ITERATOR_KEYS = 2;
  var ITERATOR_KEYSVALUES = 3;

  // All Iterators should themselves be Iterable.
  if ($$iterator) {
    CollectionIterator.prototype[$$iterator] = function() {
      return this;
    };
  }

  CollectionIterator.prototype.next = function() {
    if (this._collection) {

      // Only continue iterating if the iterated collection is long enough.
      if (this._index < this._collection.length) {
        var model = this._collection.at(this._index);
        this._index++;

        // Construct a value depending on what kind of values should be iterated.
        var value;
        if (this._kind === ITERATOR_VALUES) {
          value = model;
        } else {
          var id = this._collection.modelId(model.attributes);
          if (this._kind === ITERATOR_KEYS) {
            value = id;
          } else { // ITERATOR_KEYSVALUES
            value = [id, model];
          }
        }
        return {value: value, done: false};
      }

      // Once exhausted, remove the reference to the collection so future
      // calls to the next method always return done.
      this._collection = void 0;
    }

    return {value: void 0, done: true};
  };

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this.preinitialize.apply(this, arguments);
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the View
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], method.bind(this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function(base, length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return base[method](this[attribute]);
      };
      case 2: return function(value) {
        return base[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return base[method](this[attribute], cb(iteratee, this), context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return base[method](this[attribute], cb(iteratee, this), defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return base[method].apply(base, args);
      };
    }
  };

  var addUnderscoreMethods = function(Class, base, methods, attribute) {
    _.each(methods, function(length, method) {
      if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
    return iteratee;
  };
  var modelMatcher = function(attrs) {
    var matcher = _.matches(attrs);
    return function(model) {
      return matcher(model.attributes);
    };
  };

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
    foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
    select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
    sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};


  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
    omit: 0, chain: 1, isEmpty: 1};

  // Mix in each Underscore method as a proxy to `Collection#models`.

  _.each([
    [Collection, collectionMethods, 'models'],
    [Model, modelMethods, 'attributes']
  ], function(config) {
    var Base = config[0],
        methods = config[1],
        attribute = config[2];

    Base.mixin = function(obj) {
      var mappings = _.reduce(_.functions(obj), function(memo, name) {
        memo[name] = 0;
        return memo;
      }, {});
      addUnderscoreMethods(Base, obj, mappings, attribute);
    };

    addUnderscoreMethods(Base, _, methods, attribute);
  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    create: 'POST',
    update: 'PUT',
    patch: 'PATCH',
    delete: 'DELETE',
    read: 'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    this.preinitialize.apply(this, arguments);
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the Router.
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
        .replace(optionalParam, '(?:$1)?')
        .replace(namedParam, function(match, optional) {
          return optional ? match : '([^/?]+)';
        })
        .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    this.checkUrl = this.checkUrl.bind(this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var rootPath = path.slice(0, this.root.length - 1) + '/';
      return rootPath === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var rootPath = this.root.slice(0, -1) || '/';
          this.location.replace(rootPath + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function(eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function(eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var rootPath = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        rootPath = rootPath.slice(0, -1) || '/';
      }
      var url = rootPath + fragment;

      // Strip the fragment of the query and hash for matching.
      fragment = fragment.replace(pathStripper, '');

      // Decode for matching.
      var decodedFragment = this.decodeFragment(fragment);

      if (this.fragment === decodedFragment) return;
      this.fragment = decodedFragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function and add the prototype properties.
    child.prototype = _.create(parent.prototype, protoProps);
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/blob/index.js":
/*!************************************!*\
  !*** ./node_modules/blob/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();


/***/ }),

/***/ "./node_modules/blueimp-file-upload/js/jquery.fileupload.js":
/*!******************************************************************!*\
  !*** ./node_modules/blueimp-file-upload/js/jquery.fileupload.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * jQuery File Upload Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, require */
/* eslint-disable new-cap */

(function (factory) {
  'use strict';
  if (true) {
    // Register as an anonymous AMD module:
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery-ui"), __webpack_require__(/*! jquery-ui/ui/widget */ "./node_modules/jquery-ui/ui/widget.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  'use strict';

  // Detect file input support, based on
  // https://viljamis.com/2012/file-upload-support-on-mobile/
  $.support.fileInput = !(
    new RegExp(
      // Handle devices which give false positives for the feature detection:
      '(Android (1\\.[0156]|2\\.[01]))' +
        '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +
        '|(w(eb)?OSBrowser)|(webOS)' +
        '|(Kindle/(1\\.0|2\\.[05]|3\\.0))'
    ).test(window.navigator.userAgent) ||
    // Feature detection for all other devices:
    $('<input type="file"/>').prop('disabled')
  );

  // The FileReader API is not actually used, but works as feature detection,
  // as some Safari versions (5?) support XHR file uploads via the FormData API,
  // but not non-multipart XHR file uploads.
  // window.XMLHttpRequestUpload is not available on IE10, so we check for
  // window.ProgressEvent instead to detect XHR2 file upload capability:
  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
  $.support.xhrFormDataFileUpload = !!window.FormData;

  // Detect support for Blob slicing (required for chunked uploads):
  $.support.blobSlice =
    window.Blob &&
    (Blob.prototype.slice ||
      Blob.prototype.webkitSlice ||
      Blob.prototype.mozSlice);

  /**
   * Helper function to create drag handlers for dragover/dragenter/dragleave
   *
   * @param {string} type Event type
   * @returns {Function} Drag handler
   */
  function getDragHandler(type) {
    var isDragOver = type === 'dragover';
    return function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var dataTransfer = e.dataTransfer;
      if (
        dataTransfer &&
        $.inArray('Files', dataTransfer.types) !== -1 &&
        this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false
      ) {
        e.preventDefault();
        if (isDragOver) {
          dataTransfer.dropEffect = 'copy';
        }
      }
    };
  }

  // The fileupload widget listens for change events on file input fields defined
  // via fileInput setting and paste or drop events of the given dropZone.
  // In addition to the default jQuery Widget methods, the fileupload widget
  // exposes the "add" and "send" methods, to add or directly send files using
  // the fileupload API.
  // By default, files added via file input selection, paste, drag & drop or
  // "add" method are uploaded immediately, but it is possible to override
  // the "add" callback option to queue file uploads.
  $.widget('blueimp.fileupload', {
    options: {
      // The drop target element(s), by the default the complete document.
      // Set to null to disable drag & drop support:
      dropZone: $(document),
      // The paste target element(s), by the default undefined.
      // Set to a DOM node or jQuery object to enable file pasting:
      pasteZone: undefined,
      // The file input field(s), that are listened to for change events.
      // If undefined, it is set to the file input fields inside
      // of the widget element on plugin initialization.
      // Set to null to disable the change listener.
      fileInput: undefined,
      // By default, the file input field is replaced with a clone after
      // each input field change event. This is required for iframe transport
      // queues and allows change events to be fired for the same file
      // selection, but can be disabled by setting the following option to false:
      replaceFileInput: true,
      // The parameter name for the file form data (the request argument name).
      // If undefined or empty, the name property of the file input field is
      // used, or "files[]" if the file input name property is also empty,
      // can be a string or an array of strings:
      paramName: undefined,
      // By default, each file of a selection is uploaded using an individual
      // request for XHR type uploads. Set to false to upload file
      // selections in one request each:
      singleFileUploads: true,
      // To limit the number of files uploaded with one XHR request,
      // set the following option to an integer greater than 0:
      limitMultiFileUploads: undefined,
      // The following option limits the number of files uploaded with one
      // XHR request to keep the request size under or equal to the defined
      // limit in bytes:
      limitMultiFileUploadSize: undefined,
      // Multipart file uploads add a number of bytes to each uploaded file,
      // therefore the following option adds an overhead for each file used
      // in the limitMultiFileUploadSize configuration:
      limitMultiFileUploadSizeOverhead: 512,
      // Set the following option to true to issue all file upload requests
      // in a sequential order:
      sequentialUploads: false,
      // To limit the number of concurrent uploads,
      // set the following option to an integer greater than 0:
      limitConcurrentUploads: undefined,
      // Set the following option to true to force iframe transport uploads:
      forceIframeTransport: false,
      // Set the following option to the location of a redirect url on the
      // origin server, for cross-domain iframe transport uploads:
      redirect: undefined,
      // The parameter name for the redirect url, sent as part of the form
      // data and set to 'redirect' if this option is empty:
      redirectParamName: undefined,
      // Set the following option to the location of a postMessage window,
      // to enable postMessage transport uploads:
      postMessage: undefined,
      // By default, XHR file uploads are sent as multipart/form-data.
      // The iframe transport is always using multipart/form-data.
      // Set to false to enable non-multipart XHR uploads:
      multipart: true,
      // To upload large files in smaller chunks, set the following option
      // to a preferred maximum chunk size. If set to 0, null or undefined,
      // or the browser does not support the required Blob API, files will
      // be uploaded as a whole.
      maxChunkSize: undefined,
      // When a non-multipart upload or a chunked multipart upload has been
      // aborted, this option can be used to resume the upload by setting
      // it to the size of the already uploaded bytes. This option is most
      // useful when modifying the options object inside of the "add" or
      // "send" callbacks, as the options are cloned for each file upload.
      uploadedBytes: undefined,
      // By default, failed (abort or error) file uploads are removed from the
      // global progress calculation. Set the following option to false to
      // prevent recalculating the global progress data:
      recalculateProgress: true,
      // Interval in milliseconds to calculate and trigger progress events:
      progressInterval: 100,
      // Interval in milliseconds to calculate progress bitrate:
      bitrateInterval: 500,
      // By default, uploads are started automatically when adding files:
      autoUpload: true,
      // By default, duplicate file names are expected to be handled on
      // the server-side. If this is not possible (e.g. when uploading
      // files directly to Amazon S3), the following option can be set to
      // an empty object or an object mapping existing filenames, e.g.:
      // { "image.jpg": true, "image (1).jpg": true }
      // If it is set, all files will be uploaded with unique filenames,
      // adding increasing number suffixes if necessary, e.g.:
      // "image (2).jpg"
      uniqueFilenames: undefined,

      // Error and info messages:
      messages: {
        uploadedBytes: 'Uploaded bytes exceed file size'
      },

      // Translation function, gets the message key to be translated
      // and an object with context specific data as arguments:
      i18n: function (message, context) {
        // eslint-disable-next-line no-param-reassign
        message = this.messages[message] || message.toString();
        if (context) {
          $.each(context, function (key, value) {
            // eslint-disable-next-line no-param-reassign
            message = message.replace('{' + key + '}', value);
          });
        }
        return message;
      },

      // Additional form data to be sent along with the file uploads can be set
      // using this option, which accepts an array of objects with name and
      // value properties, a function returning such an array, a FormData
      // object (for XHR file uploads), or a simple object.
      // The form of the first fileInput is given as parameter to the function:
      formData: function (form) {
        return form.serializeArray();
      },

      // The add callback is invoked as soon as files are added to the fileupload
      // widget (via file input selection, drag & drop, paste or add API call).
      // If the singleFileUploads option is enabled, this callback will be
      // called once for each file in the selection for XHR file uploads, else
      // once for each file selection.
      //
      // The upload starts when the submit method is invoked on the data parameter.
      // The data object contains a files property holding the added files
      // and allows you to override plugin options as well as define ajax settings.
      //
      // Listeners for this callback can also be bound the following way:
      // .on('fileuploadadd', func);
      //
      // data.submit() returns a Promise object and allows to attach additional
      // handlers using jQuery's Deferred callbacks:
      // data.submit().done(func).fail(func).always(func);
      add: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        if (
          data.autoUpload ||
          (data.autoUpload !== false &&
            $(this).fileupload('option', 'autoUpload'))
        ) {
          data.process().done(function () {
            data.submit();
          });
        }
      },

      // Other callbacks:

      // Callback for the submit event of each file upload:
      // submit: function (e, data) {}, // .on('fileuploadsubmit', func);

      // Callback for the start of each file upload request:
      // send: function (e, data) {}, // .on('fileuploadsend', func);

      // Callback for successful uploads:
      // done: function (e, data) {}, // .on('fileuploaddone', func);

      // Callback for failed (abort or error) uploads:
      // fail: function (e, data) {}, // .on('fileuploadfail', func);

      // Callback for completed (success, abort or error) requests:
      // always: function (e, data) {}, // .on('fileuploadalways', func);

      // Callback for upload progress events:
      // progress: function (e, data) {}, // .on('fileuploadprogress', func);

      // Callback for global upload progress events:
      // progressall: function (e, data) {}, // .on('fileuploadprogressall', func);

      // Callback for uploads start, equivalent to the global ajaxStart event:
      // start: function (e) {}, // .on('fileuploadstart', func);

      // Callback for uploads stop, equivalent to the global ajaxStop event:
      // stop: function (e) {}, // .on('fileuploadstop', func);

      // Callback for change events of the fileInput(s):
      // change: function (e, data) {}, // .on('fileuploadchange', func);

      // Callback for paste events to the pasteZone(s):
      // paste: function (e, data) {}, // .on('fileuploadpaste', func);

      // Callback for drop events of the dropZone(s):
      // drop: function (e, data) {}, // .on('fileuploaddrop', func);

      // Callback for dragover events of the dropZone(s):
      // dragover: function (e) {}, // .on('fileuploaddragover', func);

      // Callback before the start of each chunk upload request (before form data initialization):
      // chunkbeforesend: function (e, data) {}, // .on('fileuploadchunkbeforesend', func);

      // Callback for the start of each chunk upload request:
      // chunksend: function (e, data) {}, // .on('fileuploadchunksend', func);

      // Callback for successful chunk uploads:
      // chunkdone: function (e, data) {}, // .on('fileuploadchunkdone', func);

      // Callback for failed (abort or error) chunk uploads:
      // chunkfail: function (e, data) {}, // .on('fileuploadchunkfail', func);

      // Callback for completed (success, abort or error) chunk upload requests:
      // chunkalways: function (e, data) {}, // .on('fileuploadchunkalways', func);

      // The plugin options are used as settings object for the ajax calls.
      // The following are jQuery ajax settings required for the file uploads:
      processData: false,
      contentType: false,
      cache: false,
      timeout: 0
    },

    // jQuery versions before 1.8 require promise.pipe if the return value is
    // used, as promise.then in older versions has a different behavior, see:
    // https://blog.jquery.com/2012/08/09/jquery-1-8-released/
    // https://bugs.jquery.com/ticket/11010
    // https://github.com/blueimp/jQuery-File-Upload/pull/3435
    _promisePipe: (function () {
      var parts = $.fn.jquery.split('.');
      return Number(parts[0]) > 1 || Number(parts[1]) > 7 ? 'then' : 'pipe';
    })(),

    // A list of options that require reinitializing event listeners and/or
    // special initialization code:
    _specialOptions: [
      'fileInput',
      'dropZone',
      'pasteZone',
      'multipart',
      'forceIframeTransport'
    ],

    _blobSlice:
      $.support.blobSlice &&
      function () {
        var slice = this.slice || this.webkitSlice || this.mozSlice;
        return slice.apply(this, arguments);
      },

    _BitrateTimer: function () {
      this.timestamp = Date.now ? Date.now() : new Date().getTime();
      this.loaded = 0;
      this.bitrate = 0;
      this.getBitrate = function (now, loaded, interval) {
        var timeDiff = now - this.timestamp;
        if (!this.bitrate || !interval || timeDiff > interval) {
          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
          this.loaded = loaded;
          this.timestamp = now;
        }
        return this.bitrate;
      };
    },

    _isXHRUpload: function (options) {
      return (
        !options.forceIframeTransport &&
        ((!options.multipart && $.support.xhrFileUpload) ||
          $.support.xhrFormDataFileUpload)
      );
    },

    _getFormData: function (options) {
      var formData;
      if ($.type(options.formData) === 'function') {
        return options.formData(options.form);
      }
      if ($.isArray(options.formData)) {
        return options.formData;
      }
      if ($.type(options.formData) === 'object') {
        formData = [];
        $.each(options.formData, function (name, value) {
          formData.push({ name: name, value: value });
        });
        return formData;
      }
      return [];
    },

    _getTotal: function (files) {
      var total = 0;
      $.each(files, function (index, file) {
        total += file.size || 1;
      });
      return total;
    },

    _initProgressObject: function (obj) {
      var progress = {
        loaded: 0,
        total: 0,
        bitrate: 0
      };
      if (obj._progress) {
        $.extend(obj._progress, progress);
      } else {
        obj._progress = progress;
      }
    },

    _initResponseObject: function (obj) {
      var prop;
      if (obj._response) {
        for (prop in obj._response) {
          if (Object.prototype.hasOwnProperty.call(obj._response, prop)) {
            delete obj._response[prop];
          }
        }
      } else {
        obj._response = {};
      }
    },

    _onProgress: function (e, data) {
      if (e.lengthComputable) {
        var now = Date.now ? Date.now() : new Date().getTime(),
          loaded;
        if (
          data._time &&
          data.progressInterval &&
          now - data._time < data.progressInterval &&
          e.loaded !== e.total
        ) {
          return;
        }
        data._time = now;
        loaded =
          Math.floor(
            (e.loaded / e.total) * (data.chunkSize || data._progress.total)
          ) + (data.uploadedBytes || 0);
        // Add the difference from the previously loaded state
        // to the global loaded counter:
        this._progress.loaded += loaded - data._progress.loaded;
        this._progress.bitrate = this._bitrateTimer.getBitrate(
          now,
          this._progress.loaded,
          data.bitrateInterval
        );
        data._progress.loaded = data.loaded = loaded;
        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
          now,
          loaded,
          data.bitrateInterval
        );
        // Trigger a custom progress event with a total data property set
        // to the file size(s) of the current upload and a loaded data
        // property calculated accordingly:
        this._trigger(
          'progress',
          $.Event('progress', { delegatedEvent: e }),
          data
        );
        // Trigger a global progress event for all current file uploads,
        // including ajax calls queued for sequential file uploads:
        this._trigger(
          'progressall',
          $.Event('progressall', { delegatedEvent: e }),
          this._progress
        );
      }
    },

    _initProgressListener: function (options) {
      var that = this,
        xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
      // Accesss to the native XHR object is required to add event listeners
      // for the upload progress event:
      if (xhr.upload) {
        $(xhr.upload).on('progress', function (e) {
          var oe = e.originalEvent;
          // Make sure the progress event properties get copied over:
          e.lengthComputable = oe.lengthComputable;
          e.loaded = oe.loaded;
          e.total = oe.total;
          that._onProgress(e, options);
        });
        options.xhr = function () {
          return xhr;
        };
      }
    },

    _deinitProgressListener: function (options) {
      var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
      if (xhr.upload) {
        $(xhr.upload).off('progress');
      }
    },

    _isInstanceOf: function (type, obj) {
      // Cross-frame instanceof check
      return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    },

    _getUniqueFilename: function (name, map) {
      // eslint-disable-next-line no-param-reassign
      name = String(name);
      if (map[name]) {
        // eslint-disable-next-line no-param-reassign
        name = name.replace(/(?: \(([\d]+)\))?(\.[^.]+)?$/, function (
          _,
          p1,
          p2
        ) {
          var index = p1 ? Number(p1) + 1 : 1;
          var ext = p2 || '';
          return ' (' + index + ')' + ext;
        });
        return this._getUniqueFilename(name, map);
      }
      map[name] = true;
      return name;
    },

    _initXHRData: function (options) {
      var that = this,
        formData,
        file = options.files[0],
        // Ignore non-multipart setting if not supported:
        multipart = options.multipart || !$.support.xhrFileUpload,
        paramName =
          $.type(options.paramName) === 'array'
            ? options.paramName[0]
            : options.paramName;
      options.headers = $.extend({}, options.headers);
      if (options.contentRange) {
        options.headers['Content-Range'] = options.contentRange;
      }
      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
        options.headers['Content-Disposition'] =
          'attachment; filename="' +
          encodeURI(file.uploadName || file.name) +
          '"';
      }
      if (!multipart) {
        options.contentType = file.type || 'application/octet-stream';
        options.data = options.blob || file;
      } else if ($.support.xhrFormDataFileUpload) {
        if (options.postMessage) {
          // window.postMessage does not allow sending FormData
          // objects, so we just add the File/Blob objects to
          // the formData array and let the postMessage window
          // create the FormData object out of this array:
          formData = this._getFormData(options);
          if (options.blob) {
            formData.push({
              name: paramName,
              value: options.blob
            });
          } else {
            $.each(options.files, function (index, file) {
              formData.push({
                name:
                  ($.type(options.paramName) === 'array' &&
                    options.paramName[index]) ||
                  paramName,
                value: file
              });
            });
          }
        } else {
          if (that._isInstanceOf('FormData', options.formData)) {
            formData = options.formData;
          } else {
            formData = new FormData();
            $.each(this._getFormData(options), function (index, field) {
              formData.append(field.name, field.value);
            });
          }
          if (options.blob) {
            formData.append(
              paramName,
              options.blob,
              file.uploadName || file.name
            );
          } else {
            $.each(options.files, function (index, file) {
              // This check allows the tests to run with
              // dummy objects:
              if (
                that._isInstanceOf('File', file) ||
                that._isInstanceOf('Blob', file)
              ) {
                var fileName = file.uploadName || file.name;
                if (options.uniqueFilenames) {
                  fileName = that._getUniqueFilename(
                    fileName,
                    options.uniqueFilenames
                  );
                }
                formData.append(
                  ($.type(options.paramName) === 'array' &&
                    options.paramName[index]) ||
                    paramName,
                  file,
                  fileName
                );
              }
            });
          }
        }
        options.data = formData;
      }
      // Blob reference is not needed anymore, free memory:
      options.blob = null;
    },

    _initIframeSettings: function (options) {
      var targetHost = $('<a></a>').prop('href', options.url).prop('host');
      // Setting the dataType to iframe enables the iframe transport:
      options.dataType = 'iframe ' + (options.dataType || '');
      // The iframe transport accepts a serialized array as form data:
      options.formData = this._getFormData(options);
      // Add redirect url to form data on cross-domain uploads:
      if (options.redirect && targetHost && targetHost !== location.host) {
        options.formData.push({
          name: options.redirectParamName || 'redirect',
          value: options.redirect
        });
      }
    },

    _initDataSettings: function (options) {
      if (this._isXHRUpload(options)) {
        if (!this._chunkedUpload(options, true)) {
          if (!options.data) {
            this._initXHRData(options);
          }
          this._initProgressListener(options);
        }
        if (options.postMessage) {
          // Setting the dataType to postmessage enables the
          // postMessage transport:
          options.dataType = 'postmessage ' + (options.dataType || '');
        }
      } else {
        this._initIframeSettings(options);
      }
    },

    _getParamName: function (options) {
      var fileInput = $(options.fileInput),
        paramName = options.paramName;
      if (!paramName) {
        paramName = [];
        fileInput.each(function () {
          var input = $(this),
            name = input.prop('name') || 'files[]',
            i = (input.prop('files') || [1]).length;
          while (i) {
            paramName.push(name);
            i -= 1;
          }
        });
        if (!paramName.length) {
          paramName = [fileInput.prop('name') || 'files[]'];
        }
      } else if (!$.isArray(paramName)) {
        paramName = [paramName];
      }
      return paramName;
    },

    _initFormSettings: function (options) {
      // Retrieve missing options from the input field and the
      // associated form, if available:
      if (!options.form || !options.form.length) {
        options.form = $(options.fileInput.prop('form'));
        // If the given file input doesn't have an associated form,
        // use the default widget file input's form:
        if (!options.form.length) {
          options.form = $(this.options.fileInput.prop('form'));
        }
      }
      options.paramName = this._getParamName(options);
      if (!options.url) {
        options.url = options.form.prop('action') || location.href;
      }
      // The HTTP request method must be "POST" or "PUT":
      options.type = (
        options.type ||
        ($.type(options.form.prop('method')) === 'string' &&
          options.form.prop('method')) ||
        ''
      ).toUpperCase();
      if (
        options.type !== 'POST' &&
        options.type !== 'PUT' &&
        options.type !== 'PATCH'
      ) {
        options.type = 'POST';
      }
      if (!options.formAcceptCharset) {
        options.formAcceptCharset = options.form.attr('accept-charset');
      }
    },

    _getAJAXSettings: function (data) {
      var options = $.extend({}, this.options, data);
      this._initFormSettings(options);
      this._initDataSettings(options);
      return options;
    },

    // jQuery 1.6 doesn't provide .state(),
    // while jQuery 1.8+ removed .isRejected() and .isResolved():
    _getDeferredState: function (deferred) {
      if (deferred.state) {
        return deferred.state();
      }
      if (deferred.isResolved()) {
        return 'resolved';
      }
      if (deferred.isRejected()) {
        return 'rejected';
      }
      return 'pending';
    },

    // Maps jqXHR callbacks to the equivalent
    // methods of the given Promise object:
    _enhancePromise: function (promise) {
      promise.success = promise.done;
      promise.error = promise.fail;
      promise.complete = promise.always;
      return promise;
    },

    // Creates and returns a Promise object enhanced with
    // the jqXHR methods abort, success, error and complete:
    _getXHRPromise: function (resolveOrReject, context, args) {
      var dfd = $.Deferred(),
        promise = dfd.promise();
      // eslint-disable-next-line no-param-reassign
      context = context || this.options.context || promise;
      if (resolveOrReject === true) {
        dfd.resolveWith(context, args);
      } else if (resolveOrReject === false) {
        dfd.rejectWith(context, args);
      }
      promise.abort = dfd.promise;
      return this._enhancePromise(promise);
    },

    // Adds convenience methods to the data callback argument:
    _addConvenienceMethods: function (e, data) {
      var that = this,
        getPromise = function (args) {
          return $.Deferred().resolveWith(that, args).promise();
        };
      data.process = function (resolveFunc, rejectFunc) {
        if (resolveFunc || rejectFunc) {
          data._processQueue = this._processQueue = (this._processQueue ||
            getPromise([this]))
            [that._promisePipe](function () {
              if (data.errorThrown) {
                return $.Deferred().rejectWith(that, [data]).promise();
              }
              return getPromise(arguments);
            })
            [that._promisePipe](resolveFunc, rejectFunc);
        }
        return this._processQueue || getPromise([this]);
      };
      data.submit = function () {
        if (this.state() !== 'pending') {
          data.jqXHR = this.jqXHR =
            that._trigger(
              'submit',
              $.Event('submit', { delegatedEvent: e }),
              this
            ) !== false && that._onSend(e, this);
        }
        return this.jqXHR || that._getXHRPromise();
      };
      data.abort = function () {
        if (this.jqXHR) {
          return this.jqXHR.abort();
        }
        this.errorThrown = 'abort';
        that._trigger('fail', null, this);
        return that._getXHRPromise(false);
      };
      data.state = function () {
        if (this.jqXHR) {
          return that._getDeferredState(this.jqXHR);
        }
        if (this._processQueue) {
          return that._getDeferredState(this._processQueue);
        }
      };
      data.processing = function () {
        return (
          !this.jqXHR &&
          this._processQueue &&
          that._getDeferredState(this._processQueue) === 'pending'
        );
      };
      data.progress = function () {
        return this._progress;
      };
      data.response = function () {
        return this._response;
      };
    },

    // Parses the Range header from the server response
    // and returns the uploaded bytes:
    _getUploadedBytes: function (jqXHR) {
      var range = jqXHR.getResponseHeader('Range'),
        parts = range && range.split('-'),
        upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);
      return upperBytesPos && upperBytesPos + 1;
    },

    // Uploads a file in multiple, sequential requests
    // by splitting the file up in multiple blob chunks.
    // If the second parameter is true, only tests if the file
    // should be uploaded in chunks, but does not invoke any
    // upload requests:
    _chunkedUpload: function (options, testOnly) {
      options.uploadedBytes = options.uploadedBytes || 0;
      var that = this,
        file = options.files[0],
        fs = file.size,
        ub = options.uploadedBytes,
        mcs = options.maxChunkSize || fs,
        slice = this._blobSlice,
        dfd = $.Deferred(),
        promise = dfd.promise(),
        jqXHR,
        upload;
      if (
        !(
          this._isXHRUpload(options) &&
          slice &&
          (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)
        ) ||
        options.data
      ) {
        return false;
      }
      if (testOnly) {
        return true;
      }
      if (ub >= fs) {
        file.error = options.i18n('uploadedBytes');
        return this._getXHRPromise(false, options.context, [
          null,
          'error',
          file.error
        ]);
      }
      // The chunk upload method:
      upload = function () {
        // Clone the options object for each chunk upload:
        var o = $.extend({}, options),
          currentLoaded = o._progress.loaded;
        o.blob = slice.call(
          file,
          ub,
          ub + ($.type(mcs) === 'function' ? mcs(o) : mcs),
          file.type
        );
        // Store the current chunk size, as the blob itself
        // will be dereferenced after data processing:
        o.chunkSize = o.blob.size;
        // Expose the chunk bytes position range:
        o.contentRange =
          'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;
        // Trigger chunkbeforesend to allow form data to be updated for this chunk
        that._trigger('chunkbeforesend', null, o);
        // Process the upload data (the blob and potential form data):
        that._initXHRData(o);
        // Add progress listeners for this chunk upload:
        that._initProgressListener(o);
        jqXHR = (
          (that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
          that._getXHRPromise(false, o.context)
        )
          .done(function (result, textStatus, jqXHR) {
            ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;
            // Create a progress event if no final progress event
            // with loaded equaling total has been triggered
            // for this chunk:
            if (currentLoaded + o.chunkSize - o._progress.loaded) {
              that._onProgress(
                $.Event('progress', {
                  lengthComputable: true,
                  loaded: ub - o.uploadedBytes,
                  total: ub - o.uploadedBytes
                }),
                o
              );
            }
            options.uploadedBytes = o.uploadedBytes = ub;
            o.result = result;
            o.textStatus = textStatus;
            o.jqXHR = jqXHR;
            that._trigger('chunkdone', null, o);
            that._trigger('chunkalways', null, o);
            if (ub < fs) {
              // File upload not yet complete,
              // continue with the next chunk:
              upload();
            } else {
              dfd.resolveWith(o.context, [result, textStatus, jqXHR]);
            }
          })
          .fail(function (jqXHR, textStatus, errorThrown) {
            o.jqXHR = jqXHR;
            o.textStatus = textStatus;
            o.errorThrown = errorThrown;
            that._trigger('chunkfail', null, o);
            that._trigger('chunkalways', null, o);
            dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);
          })
          .always(function () {
            that._deinitProgressListener(o);
          });
      };
      this._enhancePromise(promise);
      promise.abort = function () {
        return jqXHR.abort();
      };
      upload();
      return promise;
    },

    _beforeSend: function (e, data) {
      if (this._active === 0) {
        // the start callback is triggered when an upload starts
        // and no other uploads are currently running,
        // equivalent to the global ajaxStart event:
        this._trigger('start');
        // Set timer for global bitrate progress calculation:
        this._bitrateTimer = new this._BitrateTimer();
        // Reset the global progress values:
        this._progress.loaded = this._progress.total = 0;
        this._progress.bitrate = 0;
      }
      // Make sure the container objects for the .response() and
      // .progress() methods on the data object are available
      // and reset to their initial state:
      this._initResponseObject(data);
      this._initProgressObject(data);
      data._progress.loaded = data.loaded = data.uploadedBytes || 0;
      data._progress.total = data.total = this._getTotal(data.files) || 1;
      data._progress.bitrate = data.bitrate = 0;
      this._active += 1;
      // Initialize the global progress values:
      this._progress.loaded += data.loaded;
      this._progress.total += data.total;
    },

    _onDone: function (result, textStatus, jqXHR, options) {
      var total = options._progress.total,
        response = options._response;
      if (options._progress.loaded < total) {
        // Create a progress event if no final progress event
        // with loaded equaling total has been triggered:
        this._onProgress(
          $.Event('progress', {
            lengthComputable: true,
            loaded: total,
            total: total
          }),
          options
        );
      }
      response.result = options.result = result;
      response.textStatus = options.textStatus = textStatus;
      response.jqXHR = options.jqXHR = jqXHR;
      this._trigger('done', null, options);
    },

    _onFail: function (jqXHR, textStatus, errorThrown, options) {
      var response = options._response;
      if (options.recalculateProgress) {
        // Remove the failed (error or abort) file upload from
        // the global progress calculation:
        this._progress.loaded -= options._progress.loaded;
        this._progress.total -= options._progress.total;
      }
      response.jqXHR = options.jqXHR = jqXHR;
      response.textStatus = options.textStatus = textStatus;
      response.errorThrown = options.errorThrown = errorThrown;
      this._trigger('fail', null, options);
    },

    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
      // jqXHRorResult, textStatus and jqXHRorError are added to the
      // options object via done and fail callbacks
      this._trigger('always', null, options);
    },

    _onSend: function (e, data) {
      if (!data.submit) {
        this._addConvenienceMethods(e, data);
      }
      var that = this,
        jqXHR,
        aborted,
        slot,
        pipe,
        options = that._getAJAXSettings(data),
        send = function () {
          that._sending += 1;
          // Set timer for bitrate progress calculation:
          options._bitrateTimer = new that._BitrateTimer();
          jqXHR =
            jqXHR ||
            (
              ((aborted ||
                that._trigger(
                  'send',
                  $.Event('send', { delegatedEvent: e }),
                  options
                ) === false) &&
                that._getXHRPromise(false, options.context, aborted)) ||
              that._chunkedUpload(options) ||
              $.ajax(options)
            )
              .done(function (result, textStatus, jqXHR) {
                that._onDone(result, textStatus, jqXHR, options);
              })
              .fail(function (jqXHR, textStatus, errorThrown) {
                that._onFail(jqXHR, textStatus, errorThrown, options);
              })
              .always(function (jqXHRorResult, textStatus, jqXHRorError) {
                that._deinitProgressListener(options);
                that._onAlways(
                  jqXHRorResult,
                  textStatus,
                  jqXHRorError,
                  options
                );
                that._sending -= 1;
                that._active -= 1;
                if (
                  options.limitConcurrentUploads &&
                  options.limitConcurrentUploads > that._sending
                ) {
                  // Start the next queued upload,
                  // that has not been aborted:
                  var nextSlot = that._slots.shift();
                  while (nextSlot) {
                    if (that._getDeferredState(nextSlot) === 'pending') {
                      nextSlot.resolve();
                      break;
                    }
                    nextSlot = that._slots.shift();
                  }
                }
                if (that._active === 0) {
                  // The stop callback is triggered when all uploads have
                  // been completed, equivalent to the global ajaxStop event:
                  that._trigger('stop');
                }
              });
          return jqXHR;
        };
      this._beforeSend(e, options);
      if (
        this.options.sequentialUploads ||
        (this.options.limitConcurrentUploads &&
          this.options.limitConcurrentUploads <= this._sending)
      ) {
        if (this.options.limitConcurrentUploads > 1) {
          slot = $.Deferred();
          this._slots.push(slot);
          pipe = slot[that._promisePipe](send);
        } else {
          this._sequence = this._sequence[that._promisePipe](send, send);
          pipe = this._sequence;
        }
        // Return the piped Promise object, enhanced with an abort method,
        // which is delegated to the jqXHR object of the current upload,
        // and jqXHR callbacks mapped to the equivalent Promise methods:
        pipe.abort = function () {
          aborted = [undefined, 'abort', 'abort'];
          if (!jqXHR) {
            if (slot) {
              slot.rejectWith(options.context, aborted);
            }
            return send();
          }
          return jqXHR.abort();
        };
        return this._enhancePromise(pipe);
      }
      return send();
    },

    _onAdd: function (e, data) {
      var that = this,
        result = true,
        options = $.extend({}, this.options, data),
        files = data.files,
        filesLength = files.length,
        limit = options.limitMultiFileUploads,
        limitSize = options.limitMultiFileUploadSize,
        overhead = options.limitMultiFileUploadSizeOverhead,
        batchSize = 0,
        paramName = this._getParamName(options),
        paramNameSet,
        paramNameSlice,
        fileSet,
        i,
        j = 0;
      if (!filesLength) {
        return false;
      }
      if (limitSize && files[0].size === undefined) {
        limitSize = undefined;
      }
      if (
        !(options.singleFileUploads || limit || limitSize) ||
        !this._isXHRUpload(options)
      ) {
        fileSet = [files];
        paramNameSet = [paramName];
      } else if (!(options.singleFileUploads || limitSize) && limit) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i += limit) {
          fileSet.push(files.slice(i, i + limit));
          paramNameSlice = paramName.slice(i, i + limit);
          if (!paramNameSlice.length) {
            paramNameSlice = paramName;
          }
          paramNameSet.push(paramNameSlice);
        }
      } else if (!options.singleFileUploads && limitSize) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i = i + 1) {
          batchSize += files[i].size + overhead;
          if (
            i + 1 === filesLength ||
            batchSize + files[i + 1].size + overhead > limitSize ||
            (limit && i + 1 - j >= limit)
          ) {
            fileSet.push(files.slice(j, i + 1));
            paramNameSlice = paramName.slice(j, i + 1);
            if (!paramNameSlice.length) {
              paramNameSlice = paramName;
            }
            paramNameSet.push(paramNameSlice);
            j = i + 1;
            batchSize = 0;
          }
        }
      } else {
        paramNameSet = paramName;
      }
      data.originalFiles = files;
      $.each(fileSet || files, function (index, element) {
        var newData = $.extend({}, data);
        newData.files = fileSet ? element : [element];
        newData.paramName = paramNameSet[index];
        that._initResponseObject(newData);
        that._initProgressObject(newData);
        that._addConvenienceMethods(e, newData);
        result = that._trigger(
          'add',
          $.Event('add', { delegatedEvent: e }),
          newData
        );
        return result;
      });
      return result;
    },

    _replaceFileInput: function (data) {
      var input = data.fileInput,
        inputClone = input.clone(true),
        restoreFocus = input.is(document.activeElement);
      // Add a reference for the new cloned file input to the data argument:
      data.fileInputClone = inputClone;
      $('<form></form>').append(inputClone)[0].reset();
      // Detaching allows to insert the fileInput on another form
      // without loosing the file input value:
      input.after(inputClone).detach();
      // If the fileInput had focus before it was detached,
      // restore focus to the inputClone.
      if (restoreFocus) {
        inputClone.trigger('focus');
      }
      // Avoid memory leaks with the detached file input:
      $.cleanData(input.off('remove'));
      // Replace the original file input element in the fileInput
      // elements set with the clone, which has been copied including
      // event handlers:
      this.options.fileInput = this.options.fileInput.map(function (i, el) {
        if (el === input[0]) {
          return inputClone[0];
        }
        return el;
      });
      // If the widget has been initialized on the file input itself,
      // override this.element with the file input clone:
      if (input[0] === this.element[0]) {
        this.element = inputClone;
      }
    },

    _handleFileTreeEntry: function (entry, path) {
      var that = this,
        dfd = $.Deferred(),
        entries = [],
        dirReader,
        errorHandler = function (e) {
          if (e && !e.entry) {
            e.entry = entry;
          }
          // Since $.when returns immediately if one
          // Deferred is rejected, we use resolve instead.
          // This allows valid files and invalid items
          // to be returned together in one set:
          dfd.resolve([e]);
        },
        successHandler = function (entries) {
          that
            ._handleFileTreeEntries(entries, path + entry.name + '/')
            .done(function (files) {
              dfd.resolve(files);
            })
            .fail(errorHandler);
        },
        readEntries = function () {
          dirReader.readEntries(function (results) {
            if (!results.length) {
              successHandler(entries);
            } else {
              entries = entries.concat(results);
              readEntries();
            }
          }, errorHandler);
        };
      // eslint-disable-next-line no-param-reassign
      path = path || '';
      if (entry.isFile) {
        if (entry._file) {
          // Workaround for Chrome bug #149735
          entry._file.relativePath = path;
          dfd.resolve(entry._file);
        } else {
          entry.file(function (file) {
            file.relativePath = path;
            dfd.resolve(file);
          }, errorHandler);
        }
      } else if (entry.isDirectory) {
        dirReader = entry.createReader();
        readEntries();
      } else {
        // Return an empty list for file system items
        // other than files or directories:
        dfd.resolve([]);
      }
      return dfd.promise();
    },

    _handleFileTreeEntries: function (entries, path) {
      var that = this;
      return $.when
        .apply(
          $,
          $.map(entries, function (entry) {
            return that._handleFileTreeEntry(entry, path);
          })
        )
        [this._promisePipe](function () {
          return Array.prototype.concat.apply([], arguments);
        });
    },

    _getDroppedFiles: function (dataTransfer) {
      // eslint-disable-next-line no-param-reassign
      dataTransfer = dataTransfer || {};
      var items = dataTransfer.items;
      if (
        items &&
        items.length &&
        (items[0].webkitGetAsEntry || items[0].getAsEntry)
      ) {
        return this._handleFileTreeEntries(
          $.map(items, function (item) {
            var entry;
            if (item.webkitGetAsEntry) {
              entry = item.webkitGetAsEntry();
              if (entry) {
                // Workaround for Chrome bug #149735:
                entry._file = item.getAsFile();
              }
              return entry;
            }
            return item.getAsEntry();
          })
        );
      }
      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();
    },

    _getSingleFileInputFiles: function (fileInput) {
      // eslint-disable-next-line no-param-reassign
      fileInput = $(fileInput);
      var entries =
          fileInput.prop('webkitEntries') || fileInput.prop('entries'),
        files,
        value;
      if (entries && entries.length) {
        return this._handleFileTreeEntries(entries);
      }
      files = $.makeArray(fileInput.prop('files'));
      if (!files.length) {
        value = fileInput.prop('value');
        if (!value) {
          return $.Deferred().resolve([]).promise();
        }
        // If the files property is not available, the browser does not
        // support the File API and we add a pseudo File object with
        // the input value as name with path information removed:
        files = [{ name: value.replace(/^.*\\/, '') }];
      } else if (files[0].name === undefined && files[0].fileName) {
        // File normalization for Safari 4 and Firefox 3:
        $.each(files, function (index, file) {
          file.name = file.fileName;
          file.size = file.fileSize;
        });
      }
      return $.Deferred().resolve(files).promise();
    },

    _getFileInputFiles: function (fileInput) {
      if (!(fileInput instanceof $) || fileInput.length === 1) {
        return this._getSingleFileInputFiles(fileInput);
      }
      return $.when
        .apply($, $.map(fileInput, this._getSingleFileInputFiles))
        [this._promisePipe](function () {
          return Array.prototype.concat.apply([], arguments);
        });
    },

    _onChange: function (e) {
      var that = this,
        data = {
          fileInput: $(e.target),
          form: $(e.target.form)
        };
      this._getFileInputFiles(data.fileInput).always(function (files) {
        data.files = files;
        if (that.options.replaceFileInput) {
          that._replaceFileInput(data);
        }
        if (
          that._trigger(
            'change',
            $.Event('change', { delegatedEvent: e }),
            data
          ) !== false
        ) {
          that._onAdd(e, data);
        }
      });
    },

    _onPaste: function (e) {
      var items =
          e.originalEvent &&
          e.originalEvent.clipboardData &&
          e.originalEvent.clipboardData.items,
        data = { files: [] };
      if (items && items.length) {
        $.each(items, function (index, item) {
          var file = item.getAsFile && item.getAsFile();
          if (file) {
            data.files.push(file);
          }
        });
        if (
          this._trigger(
            'paste',
            $.Event('paste', { delegatedEvent: e }),
            data
          ) !== false
        ) {
          this._onAdd(e, data);
        }
      }
    },

    _onDrop: function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var that = this,
        dataTransfer = e.dataTransfer,
        data = {};
      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
        e.preventDefault();
        this._getDroppedFiles(dataTransfer).always(function (files) {
          data.files = files;
          if (
            that._trigger(
              'drop',
              $.Event('drop', { delegatedEvent: e }),
              data
            ) !== false
          ) {
            that._onAdd(e, data);
          }
        });
      }
    },

    _onDragOver: getDragHandler('dragover'),

    _onDragEnter: getDragHandler('dragenter'),

    _onDragLeave: getDragHandler('dragleave'),

    _initEventHandlers: function () {
      if (this._isXHRUpload(this.options)) {
        this._on(this.options.dropZone, {
          dragover: this._onDragOver,
          drop: this._onDrop,
          // event.preventDefault() on dragenter is required for IE10+:
          dragenter: this._onDragEnter,
          // dragleave is not required, but added for completeness:
          dragleave: this._onDragLeave
        });
        this._on(this.options.pasteZone, {
          paste: this._onPaste
        });
      }
      if ($.support.fileInput) {
        this._on(this.options.fileInput, {
          change: this._onChange
        });
      }
    },

    _destroyEventHandlers: function () {
      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');
      this._off(this.options.pasteZone, 'paste');
      this._off(this.options.fileInput, 'change');
    },

    _destroy: function () {
      this._destroyEventHandlers();
    },

    _setOption: function (key, value) {
      var reinit = $.inArray(key, this._specialOptions) !== -1;
      if (reinit) {
        this._destroyEventHandlers();
      }
      this._super(key, value);
      if (reinit) {
        this._initSpecialOptions();
        this._initEventHandlers();
      }
    },

    _initSpecialOptions: function () {
      var options = this.options;
      if (options.fileInput === undefined) {
        options.fileInput = this.element.is('input[type="file"]')
          ? this.element
          : this.element.find('input[type="file"]');
      } else if (!(options.fileInput instanceof $)) {
        options.fileInput = $(options.fileInput);
      }
      if (!(options.dropZone instanceof $)) {
        options.dropZone = $(options.dropZone);
      }
      if (!(options.pasteZone instanceof $)) {
        options.pasteZone = $(options.pasteZone);
      }
    },

    _getRegExp: function (str) {
      var parts = str.split('/'),
        modifiers = parts.pop();
      parts.shift();
      return new RegExp(parts.join('/'), modifiers);
    },

    _isRegExpOption: function (key, value) {
      return (
        key !== 'url' &&
        $.type(value) === 'string' &&
        /^\/.*\/[igm]{0,3}$/.test(value)
      );
    },

    _initDataAttributes: function () {
      var that = this,
        options = this.options,
        data = this.element.data();
      // Initialize options set via HTML5 data-attributes:
      $.each(this.element[0].attributes, function (index, attr) {
        var key = attr.name.toLowerCase(),
          value;
        if (/^data-/.test(key)) {
          // Convert hyphen-ated key to camelCase:
          key = key.slice(5).replace(/-[a-z]/g, function (str) {
            return str.charAt(1).toUpperCase();
          });
          value = data[key];
          if (that._isRegExpOption(key, value)) {
            value = that._getRegExp(value);
          }
          options[key] = value;
        }
      });
    },

    _create: function () {
      this._initDataAttributes();
      this._initSpecialOptions();
      this._slots = [];
      this._sequence = this._getXHRPromise(true);
      this._sending = this._active = 0;
      this._initProgressObject(this);
      this._initEventHandlers();
    },

    // This method is exposed to the widget API and allows to query
    // the number of active uploads:
    active: function () {
      return this._active;
    },

    // This method is exposed to the widget API and allows to query
    // the widget upload progress.
    // It returns an object with loaded, total and bitrate properties
    // for the running uploads:
    progress: function () {
      return this._progress;
    },

    // This method is exposed to the widget API and allows adding files
    // using the fileupload API. The data parameter accepts an object which
    // must have a files property and can contain additional options:
    // .fileupload('add', {files: filesList});
    add: function (data) {
      var that = this;
      if (!data || this.options.disabled) {
        return;
      }
      if (data.fileInput && !data.files) {
        this._getFileInputFiles(data.fileInput).always(function (files) {
          data.files = files;
          that._onAdd(null, data);
        });
      } else {
        data.files = $.makeArray(data.files);
        this._onAdd(null, data);
      }
    },

    // This method is exposed to the widget API and allows sending files
    // using the fileupload API. The data parameter accepts an object which
    // must have a files or fileInput property and can contain additional options:
    // .fileupload('send', {files: filesList});
    // The method returns a Promise object for the file upload call.
    send: function (data) {
      if (data && !this.options.disabled) {
        if (data.fileInput && !data.files) {
          var that = this,
            dfd = $.Deferred(),
            promise = dfd.promise(),
            jqXHR,
            aborted;
          promise.abort = function () {
            aborted = true;
            if (jqXHR) {
              return jqXHR.abort();
            }
            dfd.reject(null, 'abort', 'abort');
            return promise;
          };
          this._getFileInputFiles(data.fileInput).always(function (files) {
            if (aborted) {
              return;
            }
            if (!files.length) {
              dfd.reject();
              return;
            }
            data.files = files;
            jqXHR = that._onSend(null, data);
            jqXHR.then(
              function (result, textStatus, jqXHR) {
                dfd.resolve(result, textStatus, jqXHR);
              },
              function (jqXHR, textStatus, errorThrown) {
                dfd.reject(jqXHR, textStatus, errorThrown);
              }
            );
          });
          return this._enhancePromise(promise);
        }
        data.files = $.makeArray(data.files);
        if (data.files.length) {
          return this._onSend(null, data);
        }
      }
      return this._getXHRPromise(false, data && data.context);
    }
  });
});


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/buffer/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/component-bind/index.js":
/*!**********************************************!*\
  !*** ./node_modules/component-bind/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),

/***/ "./node_modules/component-inherit/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-inherit/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),

/***/ "./node_modules/engine.io-client/lib/globalThis.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/globalThis.browser.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = (function () {
  if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')(); // eslint-disable-line no-new-func
  }
})();


/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(/*! ./socket */ "./node_modules/engine.io-client/lib/socket.js");

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");


/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/engine.io-client/node_modules/component-emitter/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:socket');
var index = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/engine.io-client/node_modules/parseuri/index.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/engine.io-client/node_modules/parseqs/index.js");

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(/*! ./transport */ "./node_modules/engine.io-client/lib/transport.js");
Socket.transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
Socket.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/engine.io-client/node_modules/component-emitter/index.js");

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
var XHR = __webpack_require__(/*! ./polling-xhr */ "./node_modules/engine.io-client/lib/transports/polling-xhr.js");
var JSONP = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js");
var websocket = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io-client/lib/transports/websocket.js");

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module requirements.
 */

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    callbacks = globalThis.___eio = (globalThis.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/engine.io-client/node_modules/component-emitter/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:polling-xhr');
var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in globalThis ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/engine.io-client/node_modules/parseqs/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/engine.io-client/node_modules/parseqs/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = __webpack_require__(/*! ws */ 0);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;

  var opts = {};

  if (!this.isReactNative) {
    opts.agent = this.agent;
    opts.perMessageDeflate = this.perMessageDeflate;

    // SSL options for Node.js client
    opts.pfx = this.pfx;
    opts.key = this.key;
    opts.passphrase = this.passphrase;
    opts.cert = this.cert;
    opts.ca = this.ca;
    opts.ciphers = this.ciphers;
    opts.rejectUnauthorized = this.rejectUnauthorized;
  }

  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!*************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");
var globalThis = __webpack_require__(/*! ./globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new globalThis[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/component-emitter/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/component-emitter/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/engine.io-client/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/debug/src/debug.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/engine.io-client/node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/ms/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/parseqs/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/parseqs/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/parseuri/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/parseuri/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var keys = __webpack_require__(/*! ./keys */ "./node_modules/engine.io-parser/lib/keys.js");
var hasBinary = __webpack_require__(/*! has-binary2 */ "./node_modules/has-binary2/index.js");
var sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ "./node_modules/arraybuffer.slice/index.js");
var after = __webpack_require__(/*! after */ "./node_modules/after/index.js");
var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/engine.io-parser/lib/utf8.js");

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(/*! blob */ "./node_modules/blob/index.js");

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/keys.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/utf8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};


/***/ }),

/***/ "./node_modules/has-binary2/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-binary2/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-cors/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/icanhaz/ICanHaz.js":
/*!*****************************************!*\
  !*** ./node_modules/icanhaz/ICanHaz.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
ICanHaz.js version 0.10.2 -- by @HenrikJoreteg
More info at: http://icanhazjs.com
*/
(function () {
/*
  mustache.js — Logic-less templates in JavaScript

  See http://mustache.github.com/ for more info.
*/

var Mustache = function () {
  var _toString = Object.prototype.toString;

  Array.isArray = Array.isArray || function (obj) {
    return _toString.call(obj) == "[object Array]";
  }

  var _trim = String.prototype.trim, trim;

  if (_trim) {
    trim = function (text) {
      return text == null ? "" : _trim.call(text);
    }
  } else {
    var trimLeft, trimRight;

    // IE doesn't match non-breaking spaces with \s.
    if ((/\S/).test("\xA0")) {
      trimLeft = /^[\s\xA0]+/;
      trimRight = /[\s\xA0]+$/;
    } else {
      trimLeft = /^\s+/;
      trimRight = /\s+$/;
    }

    trim = function (text) {
      return text == null ? "" :
        text.toString().replace(trimLeft, "").replace(trimRight, "");
    }
  }

  var escapeMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;'
  };

  function escapeHTML(string) {
    return String(string).replace(/&(?!\w+;)|[<>"']/g, function (s) {
      return escapeMap[s] || s;
    });
  }

  var regexCache = {};
  var Renderer = function () {};

  Renderer.prototype = {
    otag: "{{",
    ctag: "}}",
    pragmas: {},
    buffer: [],
    pragmas_implemented: {
      "IMPLICIT-ITERATOR": true
    },
    context: {},

    render: function (template, context, partials, in_recursion) {
      // reset buffer & set context
      if (!in_recursion) {
        this.context = context;
        this.buffer = []; // TODO: make this non-lazy
      }

      // fail fast
      if (!this.includes("", template)) {
        if (in_recursion) {
          return template;
        } else {
          this.send(template);
          return;
        }
      }

      // get the pragmas together
      template = this.render_pragmas(template);

      // render the template
      var html = this.render_section(template, context, partials);

      // render_section did not find any sections, we still need to render the tags
      if (html === false) {
        html = this.render_tags(template, context, partials, in_recursion);
      }

      if (in_recursion) {
        return html;
      } else {
        this.sendLines(html);
      }
    },

    /*
      Sends parsed lines
    */
    send: function (line) {
      if (line !== "") {
        this.buffer.push(line);
      }
    },

    sendLines: function (text) {
      if (text) {
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
          this.send(lines[i]);
        }
      }
    },

    /*
      Looks for %PRAGMAS
    */
    render_pragmas: function (template) {
      // no pragmas
      if (!this.includes("%", template)) {
        return template;
      }

      var that = this;
      var regex = this.getCachedRegex("render_pragmas", function (otag, ctag) {
        return new RegExp(otag + "%([\\w-]+) ?([\\w]+=[\\w]+)?" + ctag, "g");
      });

      return template.replace(regex, function (match, pragma, options) {
        if (!that.pragmas_implemented[pragma]) {
          throw({message:
            "This implementation of mustache doesn't understand the '" +
            pragma + "' pragma"});
        }
        that.pragmas[pragma] = {};
        if (options) {
          var opts = options.split("=");
          that.pragmas[pragma][opts[0]] = opts[1];
        }
        return "";
        // ignore unknown pragmas silently
      });
    },

    /*
      Tries to find a partial in the curent scope and render it
    */
    render_partial: function (name, context, partials) {
      name = trim(name);
      if (!partials || partials[name] === undefined) {
        throw({message: "unknown_partial '" + name + "'"});
      }
      if (!context || typeof context[name] != "object") {
        return this.render(partials[name], context, partials, true);
      }
      return this.render(partials[name], context[name], partials, true);
    },

    /*
      Renders inverted (^) and normal (#) sections
    */
    render_section: function (template, context, partials) {
      if (!this.includes("#", template) && !this.includes("^", template)) {
        // did not render anything, there were no sections
        return false;
      }

      var that = this;

      var regex = this.getCachedRegex("render_section", function (otag, ctag) {
        // This regex matches _the first_ section ({{#foo}}{{/foo}}), and captures the remainder
        return new RegExp(
          "^([\\s\\S]*?)" +         // all the crap at the beginning that is not {{*}} ($1)

          otag +                    // {{
          "(\\^|\\#)\\s*(.+)\\s*" + //  #foo (# == $2, foo == $3)
          ctag +                    // }}

          "\n*([\\s\\S]*?)" +       // between the tag ($2). leading newlines are dropped

          otag +                    // {{
          "\\/\\s*\\3\\s*" +        //  /foo (backreference to the opening tag).
          ctag +                    // }}

          "\\s*([\\s\\S]*)$",       // everything else in the string ($4). leading whitespace is dropped.

        "g");
      });


      // for each {{#foo}}{{/foo}} section do...
      return template.replace(regex, function (match, before, type, name, content, after) {
        // before contains only tags, no sections
        var renderedBefore = before ? that.render_tags(before, context, partials, true) : "",

        // after may contain both sections and tags, so use full rendering function
            renderedAfter = after ? that.render(after, context, partials, true) : "",

        // will be computed below
            renderedContent,

            value = that.find(name, context);

        if (type === "^") { // inverted section
          if (!value || Array.isArray(value) && value.length === 0) {
            // false or empty list, render it
            renderedContent = that.render(content, context, partials, true);
          } else {
            renderedContent = "";
          }
        } else if (type === "#") { // normal section
          if (Array.isArray(value)) { // Enumerable, Let's loop!
            renderedContent = that.map(value, function (row) {
              return that.render(content, that.create_context(row), partials, true);
            }).join("");
          } else if (that.is_object(value)) { // Object, Use it as subcontext!
            renderedContent = that.render(content, that.create_context(value),
              partials, true);
          } else if (typeof value == "function") {
            // higher order section
            renderedContent = value.call(context, content, function (text) {
              return that.render(text, context, partials, true);
            });
          } else if (value) { // boolean section
            renderedContent = that.render(content, context, partials, true);
          } else {
            renderedContent = "";
          }
        }

        return renderedBefore + renderedContent + renderedAfter;
      });
    },

    /*
      Replace {{foo}} and friends with values from our view
    */
    render_tags: function (template, context, partials, in_recursion) {
      // tit for tat
      var that = this;

      var new_regex = function () {
        return that.getCachedRegex("render_tags", function (otag, ctag) {
          return new RegExp(otag + "(=|!|>|&|\\{|%)?([^#\\^]+?)\\1?" + ctag + "+", "g");
        });
      };

      var regex = new_regex();
      var tag_replace_callback = function (match, operator, name) {
        switch(operator) {
        case "!": // ignore comments
          return "";
        case "=": // set new delimiters, rebuild the replace regexp
          that.set_delimiters(name);
          regex = new_regex();
          return "";
        case ">": // render partial
          return that.render_partial(name, context, partials);
        case "{": // the triple mustache is unescaped
        case "&": // & operator is an alternative unescape method
          return that.find(name, context);
        default: // escape the value
          return escapeHTML(that.find(name, context));
        }
      };
      var lines = template.split("\n");
      for(var i = 0; i < lines.length; i++) {
        lines[i] = lines[i].replace(regex, tag_replace_callback, this);
        if (!in_recursion) {
          this.send(lines[i]);
        }
      }

      if (in_recursion) {
        return lines.join("\n");
      }
    },

    set_delimiters: function (delimiters) {
      var dels = delimiters.split(" ");
      this.otag = this.escape_regex(dels[0]);
      this.ctag = this.escape_regex(dels[1]);
    },

    escape_regex: function (text) {
      // thank you Simon Willison
      if (!arguments.callee.sRE) {
        var specials = [
          '/', '.', '*', '+', '?', '|',
          '(', ')', '[', ']', '{', '}', '\\'
        ];
        arguments.callee.sRE = new RegExp(
          '(\\' + specials.join('|\\') + ')', 'g'
        );
      }
      return text.replace(arguments.callee.sRE, '\\$1');
    },

    /*
      find `name` in current `context`. That is find me a value
      from the view object
    */
    find: function (name, context) {
      name = trim(name);

      // Checks whether a value is thruthy or false or 0
      function is_kinda_truthy(bool) {
        return bool === false || bool === 0 || bool;
      }

      var value;

      // check for dot notation eg. foo.bar
      if (name.match(/([a-z_]+)\./ig)) {
        var childValue = this.walk_context(name, context);
        if (is_kinda_truthy(childValue)) {
          value = childValue;
        }
      } else {
        if (is_kinda_truthy(context[name])) {
          value = context[name];
        } else if (is_kinda_truthy(this.context[name])) {
          value = this.context[name];
        }
      }

      if (typeof value == "function") {
        return value.apply(context);
      }
      if (value !== undefined) {
        return value;
      }
      // silently ignore unkown variables
      return "";
    },

    walk_context: function (name, context) {
      var path = name.split('.');
      // if the var doesn't exist in current context, check the top level context
      var value_context = (context[path[0]] != undefined) ? context : this.context;
      var value = value_context[path.shift()];
      while (value != undefined && path.length > 0) {
        value_context = value;
        value = value[path.shift()];
      }
      // if the value is a function, call it, binding the correct context
      if (typeof value == "function") {
        return value.apply(value_context);
      }
      return value;
    },

    // Utility methods

    /* includes tag */
    includes: function (needle, haystack) {
      return haystack.indexOf(this.otag + needle) != -1;
    },

    // by @langalex, support for arrays of strings
    create_context: function (_context) {
      if (this.is_object(_context)) {
        return _context;
      } else {
        var iterator = ".";
        if (this.pragmas["IMPLICIT-ITERATOR"]) {
          iterator = this.pragmas["IMPLICIT-ITERATOR"].iterator;
        }
        var ctx = {};
        ctx[iterator] = _context;
        return ctx;
      }
    },

    is_object: function (a) {
      return a && typeof a == "object";
    },

    /*
      Why, why, why? Because IE. Cry, cry cry.
    */
    map: function (array, fn) {
      if (typeof array.map == "function") {
        return array.map(fn);
      } else {
        var r = [];
        var l = array.length;
        for(var i = 0; i < l; i++) {
          r.push(fn(array[i]));
        }
        return r;
      }
    },

    getCachedRegex: function (name, generator) {
      var byOtag = regexCache[this.otag];
      if (!byOtag) {
        byOtag = regexCache[this.otag] = {};
      }

      var byCtag = byOtag[this.ctag];
      if (!byCtag) {
        byCtag = byOtag[this.ctag] = {};
      }

      var regex = byCtag[name];
      if (!regex) {
        regex = byCtag[name] = generator(this.otag, this.ctag);
      }

      return regex;
    }
  };

  return({
    name: "mustache.js",
    version: "0.4.0",

    /*
      Turns a template and view into HTML
    */
    to_html: function (template, view, partials, send_fun) {
      var renderer = new Renderer();
      if (send_fun) {
        renderer.send = send_fun;
      }
      renderer.render(template, view || {}, partials);
      if (!send_fun) {
        return renderer.buffer.join("\n");
      }
    }
  });
}();
/*!
  ICanHaz.js -- by @HenrikJoreteg
*/
/*global  */
(function () {
    function trim(stuff) {
        if (''.trim) return stuff.trim();
        else return stuff.replace(/^\s+/, '').replace(/\s+$/, '');
    }

    // Establish the root object, `window` in the browser, or `global` on the server.
    var root = this;

    var ich = {
        VERSION: "0.10.2",
        templates: {},

        // grab jquery or zepto if it's there
        $: (typeof window !== 'undefined') ? window.jQuery || window.Zepto || null : null,

        // public function for adding templates
        // can take a name and template string arguments
        // or can take an object with name/template pairs
        // We're enforcing uniqueness to avoid accidental template overwrites.
        // If you want a different template, it should have a different name.
        addTemplate: function (name, templateString) {
            if (typeof name === 'object') {
                for (var template in name) {
                    this.addTemplate(template, name[template]);
                }
                return;
            }
            if (ich[name]) {
                console.error("Invalid name: " + name + ".");
            } else if (ich.templates[name]) {
                console.error("Template \"" + name + "  \" exists");
            } else {
                ich.templates[name] = templateString;
                ich[name] = function (data, raw) {
                    data = data || {};
                    var result = Mustache.to_html(ich.templates[name], data, ich.templates);
                    return (ich.$ && !raw) ? ich.$(trim(result)) : result;
                };
            }
        },

        // clears all retrieval functions and empties cache
        clearAll: function () {
            for (var key in ich.templates) {
                delete ich[key];
            }
            ich.templates = {};
        },

        // clears/grabs
        refresh: function () {
            ich.clearAll();
            ich.grabTemplates();
        },

        // grabs templates from the DOM and caches them.
        // Loop through and add templates.
        // Whitespace at beginning and end of all templates inside <script> tags will
        // be trimmed. If you want whitespace around a partial, add it in the parent,
        // not the partial. Or do it explicitly using <br/> or &nbsp;
        grabTemplates: function () {
            var i,
                l,
                scripts = document.getElementsByTagName('script'),
                script,
                trash = [];
            for (i = 0, l = scripts.length; i < l; i++) {
                script = scripts[i];
                if (script && script.innerHTML && script.id && (script.type === "text/html" || script.type === "text/x-icanhaz")) {
                    ich.addTemplate(script.id, trim(script.innerHTML));
                    trash.unshift(script);
                }
            }
            for (i = 0, l = trash.length; i < l; i++) {
                trash[i].parentNode.removeChild(trash[i]);
            }
        }
    };

    // Export the ICanHaz object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `ich` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (true) {
        if ( true && module.exports) {
            exports = module.exports = ich;
        }
        exports.ich = ich;
    } else {}

    if (typeof document !== 'undefined') {
        if (ich.$) {
            ich.$(function () {
                ich.grabTemplates();
            });
        } else {
            document.addEventListener('DOMContentLoaded', function () {
                ich.grabTemplates();
            }, true);
        }
    }

})();
})();


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jquery-ui/ui/version.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery-ui/ui/version.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "jquery-ui") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} ( function( $ ) {

$.ui = $.ui || {};

return $.ui.version = "1.12.1";

} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/widget.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery-ui/ui/widget.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "jquery-ui"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}( function( $ ) {

var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

return $.widget;

} ) );


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/socket.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(/*! ./url */ "./node_modules/socket.io-client/lib/url.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js");
var Manager = __webpack_require__(/*! ./manager */ "./node_modules/socket.io-client/lib/manager.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(/*! ./manager */ "./node_modules/socket.io-client/lib/manager.js");
exports.Socket = __webpack_require__(/*! ./socket */ "./node_modules/socket.io-client/lib/socket.js");


/***/ }),

/***/ "./node_modules/socket.io-client/lib/manager.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-client/lib/manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/lib/index.js");
var Socket = __webpack_require__(/*! ./socket */ "./node_modules/socket.io-client/lib/socket.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socket.io-client/node_modules/component-emitter/index.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:manager');
var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    if (timeout === 0) {
      openSub.destroy(); // prevents a race condition with the 'open' event
    }

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),

/***/ "./node_modules/socket.io-client/lib/on.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-client/lib/on.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),

/***/ "./node_modules/socket.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socket.io-client/node_modules/component-emitter/index.js");
var toArray = __webpack_require__(/*! to-array */ "./node_modules/to-array/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:socket');
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/socket.io-client/node_modules/parseqs/index.js");
var hasBin = __webpack_require__(/*! has-binary2 */ "./node_modules/has-binary2/index.js");

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  if (!this.io.reconnecting) this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};


/***/ }),

/***/ "./node_modules/socket.io-client/lib/url.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io-client/lib/url.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/socket.io-client/node_modules/parseuri/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/component-emitter/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/component-emitter/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/socket.io-client/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/debug.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/socket.io-client/node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/ms/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/parseqs/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/parseqs/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/parseuri/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/parseuri/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/binary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/binary.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js");
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-parser');
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socket.io-client/node_modules/component-emitter/index.js");
var binary = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-client/node_modules/socket.io-parser/binary.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js");

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {
module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/to-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/to-array/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),

/***/ "./node_modules/underscore/modules/_baseCreate.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/_baseCreate.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return baseCreate; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");



// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function(){};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype)) return {};
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeCreate"]) return Object(_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeCreate"])(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor;
  Ctor.prototype = null;
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_baseIteratee.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_baseIteratee.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return baseIteratee; });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");








// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) return Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value, context, argCount);
  if (Object(_isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) && !Object(_isArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) return Object(_matcher_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
  return Object(_property_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_cb.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/_cb.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cb; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/underscore/modules/_baseIteratee.js");
/* harmony import */ var _iteratee_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./iteratee.js */ "./node_modules/underscore/modules/iteratee.js");




// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee !== _iteratee_js__WEBPACK_IMPORTED_MODULE_2__["default"]) return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee(value, context);
  return Object(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, context, argCount);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_chainResult.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_chainResult.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chainResult; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? Object(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj).chain() : obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_collectNonEnumProps.js":
/*!*****************************************************************!*\
  !*** ./node_modules/underscore/modules/_collectNonEnumProps.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return collectNonEnumProps; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");




// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function(key) { return hash[key]; },
    push: function(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = _setup_js__WEBPACK_IMPORTED_MODULE_0__["nonEnumerableProps"].length;
  var constructor = obj.constructor;
  var proto = Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(constructor) && constructor.prototype || _setup_js__WEBPACK_IMPORTED_MODULE_0__["ObjProto"];

  // Constructor is a special case.
  var prop = 'constructor';
  if (Object(_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, prop) && !keys.contains(prop)) keys.push(prop);

  while (nonEnumIdx--) {
    prop = _setup_js__WEBPACK_IMPORTED_MODULE_0__["nonEnumerableProps"][nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createAssigner.js":
/*!************************************************************!*\
  !*** ./node_modules/underscore/modules/_createAssigner.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createAssigner; });
// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createEscaper.js":
/*!***********************************************************!*\
  !*** ./node_modules/underscore/modules/_createEscaper.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createEscaper; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function(string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createIndexFinder.js":
/*!***************************************************************!*\
  !*** ./node_modules/underscore/modules/_createIndexFinder.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createIndexFinder; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isNaN_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNaN.js */ "./node_modules/underscore/modules/isNaN.js");




// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function(array, item, idx) {
    var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(_setup_js__WEBPACK_IMPORTED_MODULE_1__["slice"].call(array, i, length), _isNaN_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createPredicateIndexFinder.js":
/*!************************************************************************!*\
  !*** ./node_modules/underscore/modules/_createPredicateIndexFinder.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createPredicateIndexFinder; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
    var length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createReduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_createReduce.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createReduce; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");




// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function(obj, iteratee, memo, initial) {
    var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj),
        length = (_keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  return function(obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context, 4), memo, initial);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createSizePropertyCheck.js":
/*!*********************************************************************!*\
  !*** ./node_modules/underscore/modules/_createSizePropertyCheck.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createSizePropertyCheck; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= _setup_js__WEBPACK_IMPORTED_MODULE_0__["MAX_ARRAY_INDEX"];
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/_deepGet.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/_deepGet.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return deepGet; });
// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_escapeMap.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_escapeMap.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Internal list of HTML entities for escaping.
/* harmony default export */ __webpack_exports__["default"] = ({
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
});


/***/ }),

/***/ "./node_modules/underscore/modules/_executeBound.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_executeBound.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return executeBound; });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/underscore/modules/_baseCreate.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");



// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = Object(_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if (Object(_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) return result;
  return self;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/_flatten.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return flatten; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");





// Internal implementation of a recursive `flatten` function.
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input); i < length; i++) {
    var value = input[i];
    if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_getByteLength.js":
/*!***********************************************************!*\
  !*** ./node_modules/underscore/modules/_getByteLength.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");


// Internal helper to obtain the `byteLength` property of an object.
/* harmony default export */ __webpack_exports__["default"] = (Object(_shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('byteLength'));


/***/ }),

/***/ "./node_modules/underscore/modules/_getLength.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_getLength.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");


// Internal helper to obtain the `length` property of an object.
/* harmony default export */ __webpack_exports__["default"] = (Object(_shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('length'));


/***/ }),

/***/ "./node_modules/underscore/modules/_group.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/_group.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return group; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");



// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function(obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
    Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, function(value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_has.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/_has.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return has; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Internal function to check whether `key` is an own property name of `obj`.
function has(obj, key) {
  return obj != null && _setup_js__WEBPACK_IMPORTED_MODULE_0__["hasOwnProperty"].call(obj, key);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_isArrayLike.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_isArrayLike.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createSizePropertyCheck.js */ "./node_modules/underscore/modules/_createSizePropertyCheck.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
/* harmony default export */ __webpack_exports__["default"] = (Object(_createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/_isBufferLike.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_isBufferLike.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createSizePropertyCheck.js */ "./node_modules/underscore/modules/_createSizePropertyCheck.js");
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");



// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_getByteLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/_keyInObj.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/_keyInObj.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return keyInObj; });
// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_optimizeCb.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/_optimizeCb.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return optimizeCb; });
// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    // The 2-argument case is omitted because we’re not using it.
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_setup.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/_setup.js ***!
  \***************************************************/
/*! exports provided: VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayProto", function() { return ArrayProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjProto", function() { return ObjProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolProto", function() { return SymbolProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "push", function() { return push; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOwnProperty", function() { return hasOwnProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsArrayBuffer", function() { return supportsArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeIsArray", function() { return nativeIsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeKeys", function() { return nativeKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeCreate", function() { return nativeCreate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeIsView", function() { return nativeIsView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isNaN", function() { return _isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isFinite", function() { return _isFinite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasEnumBug", function() { return hasEnumBug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonEnumerableProps", function() { return nonEnumerableProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_ARRAY_INDEX", function() { return MAX_ARRAY_INDEX; });
// Current version.
var VERSION = '1.11.0';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = typeof self == 'object' && self.self === self && self ||
          typeof global == 'object' && global.global === global && global ||
          Function('return this')() ||
          {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create,
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
    _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/underscore/modules/_shallowProperty.js":
/*!*************************************************************!*\
  !*** ./node_modules/underscore/modules/_shallowProperty.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shallowProperty; });
// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_tagTester.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_tagTester.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return tagTester; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  return function(obj) {
    return _setup_js__WEBPACK_IMPORTED_MODULE_0__["toString"].call(obj) === '[object ' + name + ']';
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_unescapeMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_unescapeMap.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invert.js */ "./node_modules/underscore/modules/invert.js");
/* harmony import */ var _escapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeMap.js */ "./node_modules/underscore/modules/_escapeMap.js");



// Internal list of HTML entities for unescaping.
/* harmony default export */ __webpack_exports__["default"] = (Object(_invert_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_escapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/after.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/after.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return after; });
// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function() {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/allKeys.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/allKeys.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return allKeys; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_collectNonEnumProps.js */ "./node_modules/underscore/modules/_collectNonEnumProps.js");




// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["hasEnumBug"]) Object(_collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, keys);
  return keys;
}


/***/ }),

/***/ "./node_modules/underscore/modules/before.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/before.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return before; });
// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function() {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/bind.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/bind.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _executeBound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_executeBound.js */ "./node_modules/underscore/modules/_executeBound.js");




// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, context, args) {
  if (!Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func)) throw new TypeError('Bind must be called on a function');
  var bound = Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(callArgs) {
    return Object(_executeBound_js__WEBPACK_IMPORTED_MODULE_2__["default"])(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/bindAll.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/bindAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _bind_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bind.js */ "./node_modules/underscore/modules/bind.js");




// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  keys = Object(_flatten_js__WEBPACK_IMPORTED_MODULE_1__["default"])(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = Object(_bind_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj[key], obj);
  }
  return obj;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/chain.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/chain.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chain; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = Object(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  instance._chain = true;
  return instance;
}


/***/ }),

/***/ "./node_modules/underscore/modules/chunk.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/chunk.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chunk; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0, length = array.length;
  while (i < length) {
    result.push(_setup_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(array, i, i += count));
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/clone.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/clone.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return clone; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extend.js */ "./node_modules/underscore/modules/extend.js");




// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return obj;
  return Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) ? obj.slice() : Object(_extend_js__WEBPACK_IMPORTED_MODULE_2__["default"])({}, obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/compact.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/compact.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compact; });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");


// Trim out all falsy values from an array.
function compact(array) {
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, Boolean);
}


/***/ }),

/***/ "./node_modules/underscore/modules/compose.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/compose.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compose; });
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return constant; });
// Predicate-generating function. Often useful outside of Underscore.
function constant(value) {
  return function() {
    return value;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/contains.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/contains.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return contains; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _indexOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./indexOf.js */ "./node_modules/underscore/modules/indexOf.js");




// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) obj = Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return Object(_indexOf_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, item, fromIndex) >= 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/countBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/countBy.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if (Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key)) result[key]++; else result[key] = 1;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/create.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/create.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return create; });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/underscore/modules/_baseCreate.js");
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");



// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = Object(_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype);
  if (props) Object(_extendOwn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, props);
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/debounce.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/debounce.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return debounce; });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");



// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, result;

  var later = function(context, args) {
    timeout = null;
    if (args) result = func.apply(context, args);
  };

  var debounced = Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(args) {
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      var callNow = !timeout;
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(this, args);
    } else {
      timeout = Object(_delay_js__WEBPACK_IMPORTED_MODULE_1__["default"])(later, wait, this, args);
    }

    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = null;
  };

  return debounced;
}


/***/ }),

/***/ "./node_modules/underscore/modules/defaults.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/defaults.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");



// Fill in a given object with default properties.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_allKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"], true));


/***/ }),

/***/ "./node_modules/underscore/modules/defer.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/defer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");




// Defers a function, scheduling it to run after the current call stack has
// cleared.
/* harmony default export */ __webpack_exports__["default"] = (Object(_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_delay_js__WEBPACK_IMPORTED_MODULE_1__["default"], _underscore_js__WEBPACK_IMPORTED_MODULE_2__["default"], 1));


/***/ }),

/***/ "./node_modules/underscore/modules/delay.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/delay.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");


// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/difference.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/difference.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");





// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, rest) {
  rest = Object(_flatten_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rest, true, true);
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, function(value){
    return !Object(_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(rest, value);
  });
}));


/***/ }),

/***/ "./node_modules/underscore/modules/each.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/each.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return each; });
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var i, length;
  if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/escape.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createEscaper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createEscaper.js */ "./node_modules/underscore/modules/_createEscaper.js");
/* harmony import */ var _escapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeMap.js */ "./node_modules/underscore/modules/_escapeMap.js");



// Function for escaping strings to HTML interpolation.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createEscaper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_escapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/every.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/every.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return every; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/underscore/modules/extend.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/extend.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");



// Extend a given object with all the properties in passed-in object(s).
/* harmony default export */ __webpack_exports__["default"] = (Object(_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_allKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/extendOwn.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/extendOwn.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
/* harmony default export */ __webpack_exports__["default"] = (Object(_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/filter.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/filter.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return filter; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");



// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/find.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/find.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return find; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _findKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./findKey.js */ "./node_modules/underscore/modules/findKey.js");




// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? _findIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _findKey_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}


/***/ }),

/***/ "./node_modules/underscore/modules/findIndex.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/findIndex.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createPredicateIndexFinder.js */ "./node_modules/underscore/modules/_createPredicateIndexFinder.js");


// Returns the first index on an array-like that passes a truth test.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1));


/***/ }),

/***/ "./node_modules/underscore/modules/findKey.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/findKey.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return findKey; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/findLastIndex.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/findLastIndex.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createPredicateIndexFinder.js */ "./node_modules/underscore/modules/_createPredicateIndexFinder.js");


// Returns the last index on an array-like that passes a truth test.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-1));


/***/ }),

/***/ "./node_modules/underscore/modules/findWhere.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/findWhere.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return findWhere; });
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find.js */ "./node_modules/underscore/modules/find.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");



// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return Object(_find_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(attrs));
}


/***/ }),

/***/ "./node_modules/underscore/modules/first.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/first.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return first; });
/* harmony import */ var _initial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initial.js */ "./node_modules/underscore/modules/initial.js");


// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return Object(_initial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, array.length - n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/flatten.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/flatten.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return flatten; });
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");


// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten(array, depth) {
  return Object(_flatten_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, depth, false);
}


/***/ }),

/***/ "./node_modules/underscore/modules/functions.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/functions.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return functions; });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");


// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj[key])) names.push(key);
  }
  return names.sort();
}


/***/ }),

/***/ "./node_modules/underscore/modules/groupBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/groupBy.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if (Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key)) result[key].push(value); else result[key] = [value];
}));


/***/ }),

/***/ "./node_modules/underscore/modules/has.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/has.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return has; });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");




// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has(obj, path) {
  if (!Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path)) {
    return Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, path);
  }
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (obj == null || !_setup_js__WEBPACK_IMPORTED_MODULE_2__["hasOwnProperty"].call(obj, key)) {
      return false;
    }
    obj = obj[key];
  }
  return !!length;
}


/***/ }),

/***/ "./node_modules/underscore/modules/identity.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/identity.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return identity; });
// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}


/***/ }),

/***/ "./node_modules/underscore/modules/index-all.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/index-all.js ***!
  \******************************************************/
/*! exports provided: default, VERSION, restArguments, isObject, isNull, isUndefined, isBoolean, isElement, isString, isNumber, isDate, isRegExp, isError, isSymbol, isMap, isWeakMap, isSet, isWeakSet, isArrayBuffer, isDataView, isArray, isFunction, isArguments, isFinite, isNaN, isTypedArray, isEmpty, isMatch, isEqual, keys, allKeys, values, pairs, invert, functions, methods, extend, extendOwn, assign, defaults, create, clone, tap, has, mapObject, identity, constant, noop, property, propertyOf, matcher, matches, times, random, now, escape, unescape, templateSettings, template, result, uniqueId, chain, iteratee, partial, bind, bindAll, memoize, delay, defer, throttle, debounce, wrap, negate, compose, after, before, once, findKey, findIndex, findLastIndex, sortedIndex, indexOf, lastIndexOf, find, detect, findWhere, each, forEach, map, collect, reduce, foldl, inject, reduceRight, foldr, filter, select, reject, every, all, some, any, contains, includes, include, invoke, pluck, where, max, min, shuffle, sample, sortBy, groupBy, indexBy, countBy, partition, toArray, size, pick, omit, first, head, take, initial, last, rest, tail, drop, compact, flatten, without, uniq, unique, union, intersection, difference, unzip, transpose, zip, object, range, chunk, mixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_default_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-default.js */ "./node_modules/underscore/modules/index-default.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _index_default_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/underscore/modules/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["VERSION"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restArguments", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["restArguments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isNull"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isBoolean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isDate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRegExp", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isRegExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isError", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSymbol", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isSymbol"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakMap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isWeakMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSet", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakSet", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isWeakSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDataView", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isFunction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArguments", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isArguments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isFinite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isNaN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTypedArray", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isTypedArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isEmpty"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMatch", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isMatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["keys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allKeys", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["allKeys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["values"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["pairs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["invert"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "functions", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["functions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "methods", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["methods"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["extend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendOwn", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["extendOwn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["assign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["defaults"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["create"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["tap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["has"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapObject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["mapObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constant", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["constant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["noop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propertyOf", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["propertyOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["matcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["matches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "times", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["times"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "random", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["random"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["escape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unescape", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["unescape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "templateSettings", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["templateSettings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "template", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["template"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "result", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["result"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["uniqueId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["chain"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iteratee", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["iteratee"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["partial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["bind"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindAll", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["bindAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoize", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["memoize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["delay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["defer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["throttle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["debounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["wrap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["negate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["compose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "after", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["after"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "before", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["before"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "once", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["once"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findKey", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findIndex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findLastIndex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortedIndex", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["sortedIndex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["indexOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["lastIndexOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["find"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detect", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["detect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findWhere", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findWhere"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "each", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["each"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["map"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "collect", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["collect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["reduce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldl", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["foldl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["inject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["reduceRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldr", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["foldr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["filter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["select"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["reject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "every", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["every"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["all"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "some", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["some"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["any"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["contains"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["includes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "include", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["include"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invoke", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["invoke"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["pluck"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["where"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["shuffle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["sample"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["sortBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["groupBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["indexBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "countBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["countBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["partition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["toArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "size", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["size"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["pick"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["omit"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "first", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["first"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "head", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["head"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["take"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initial", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["initial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["last"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rest", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["rest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["tail"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["drop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compact", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["compact"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["flatten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "without", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["without"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["uniq"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["unique"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["union"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["intersection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["difference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unzip", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["unzip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["zip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "object", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["object"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chunk", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["chunk"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixin", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["mixin"]; });

// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.




/***/ }),

/***/ "./node_modules/underscore/modules/index-default.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/index-default.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/underscore/modules/index.js");
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```



// Add all of the Underscore functions to the wrapper object.
var _ = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["mixin"])(_index_js__WEBPACK_IMPORTED_MODULE_0__);
// Legacy Node.js API.
_._ = _;
// Export the Underscore API.
/* harmony default export */ __webpack_exports__["default"] = (_);


/***/ }),

/***/ "./node_modules/underscore/modules/index.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/index.js ***!
  \**************************************************/
/*! exports provided: VERSION, restArguments, isObject, isNull, isUndefined, isBoolean, isElement, isString, isNumber, isDate, isRegExp, isError, isSymbol, isMap, isWeakMap, isSet, isWeakSet, isArrayBuffer, isDataView, isArray, isFunction, isArguments, isFinite, isNaN, isTypedArray, isEmpty, isMatch, isEqual, keys, allKeys, values, pairs, invert, functions, methods, extend, extendOwn, assign, defaults, create, clone, tap, has, mapObject, identity, constant, noop, property, propertyOf, matcher, matches, times, random, now, escape, unescape, templateSettings, template, result, uniqueId, chain, iteratee, partial, bind, bindAll, memoize, delay, defer, throttle, debounce, wrap, negate, compose, after, before, once, findKey, findIndex, findLastIndex, sortedIndex, indexOf, lastIndexOf, find, detect, findWhere, each, forEach, map, collect, reduce, foldl, inject, reduceRight, foldr, filter, select, reject, every, all, some, any, contains, includes, include, invoke, pluck, where, max, min, shuffle, sample, sortBy, groupBy, indexBy, countBy, partition, toArray, size, pick, omit, first, head, take, initial, last, rest, tail, drop, compact, flatten, without, uniq, unique, union, intersection, difference, unzip, transpose, zip, object, range, chunk, mixin, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _setup_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"]; });

/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restArguments", function() { return _restArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _isNull_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isNull.js */ "./node_modules/underscore/modules/isNull.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return _isNull_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _isUndefined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isUndefined.js */ "./node_modules/underscore/modules/isUndefined.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return _isUndefined_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _isBoolean_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isBoolean.js */ "./node_modules/underscore/modules/isBoolean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return _isBoolean_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _isElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isElement.js */ "./node_modules/underscore/modules/isElement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return _isElement_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return _isString_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./isNumber.js */ "./node_modules/underscore/modules/isNumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _isNumber_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _isDate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./isDate.js */ "./node_modules/underscore/modules/isDate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return _isDate_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _isRegExp_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isRegExp.js */ "./node_modules/underscore/modules/isRegExp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRegExp", function() { return _isRegExp_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _isError_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./isError.js */ "./node_modules/underscore/modules/isError.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isError", function() { return _isError_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/underscore/modules/isSymbol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSymbol", function() { return _isSymbol_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _isMap_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isMap.js */ "./node_modules/underscore/modules/isMap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMap", function() { return _isMap_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _isWeakMap_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isWeakMap.js */ "./node_modules/underscore/modules/isWeakMap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakMap", function() { return _isWeakMap_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _isSet_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./isSet.js */ "./node_modules/underscore/modules/isSet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSet", function() { return _isSet_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _isWeakSet_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./isWeakSet.js */ "./node_modules/underscore/modules/isWeakSet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakSet", function() { return _isWeakSet_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./isArrayBuffer.js */ "./node_modules/underscore/modules/isArrayBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDataView", function() { return _isDataView_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _isArray_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return _isFunction_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArguments", function() { return _isArguments_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _isFinite_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./isFinite.js */ "./node_modules/underscore/modules/isFinite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _isFinite_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _isNaN_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./isNaN.js */ "./node_modules/underscore/modules/isNaN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _isNaN_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/underscore/modules/isTypedArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTypedArray", function() { return _isTypedArray_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _isEmpty_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./isEmpty.js */ "./node_modules/underscore/modules/isEmpty.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _isEmpty_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _isMatch_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./isMatch.js */ "./node_modules/underscore/modules/isMatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMatch", function() { return _isMatch_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _isEqual_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./isEqual.js */ "./node_modules/underscore/modules/isEqual.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return _isEqual_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _keys_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allKeys", function() { return _allKeys_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _values_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _pairs_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./pairs.js */ "./node_modules/underscore/modules/pairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _pairs_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _invert_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./invert.js */ "./node_modules/underscore/modules/invert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return _invert_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./functions.js */ "./node_modules/underscore/modules/functions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "functions", function() { return _functions_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "methods", function() { return _functions_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./extend.js */ "./node_modules/underscore/modules/extend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _extend_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendOwn", function() { return _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/underscore/modules/defaults.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return _defaults_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./create.js */ "./node_modules/underscore/modules/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./clone.js */ "./node_modules/underscore/modules/clone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _clone_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _tap_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./tap.js */ "./node_modules/underscore/modules/tap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _tap_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./has.js */ "./node_modules/underscore/modules/has.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has", function() { return _has_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _mapObject_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./mapObject.js */ "./node_modules/underscore/modules/mapObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapObject", function() { return _mapObject_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _identity_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./constant.js */ "./node_modules/underscore/modules/constant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constant", function() { return _constant_js__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./noop.js */ "./node_modules/underscore/modules/noop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _noop_js__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _property_js__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _propertyOf_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./propertyOf.js */ "./node_modules/underscore/modules/propertyOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propertyOf", function() { return _propertyOf_js__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _times_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./times.js */ "./node_modules/underscore/modules/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "times", function() { return _times_js__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./random.js */ "./node_modules/underscore/modules/random.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "random", function() { return _random_js__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _now_js__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./escape.js */ "./node_modules/underscore/modules/escape.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return _escape_js__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./unescape.js */ "./node_modules/underscore/modules/unescape.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unescape", function() { return _unescape_js__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./templateSettings.js */ "./node_modules/underscore/modules/templateSettings.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "templateSettings", function() { return _templateSettings_js__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./template.js */ "./node_modules/underscore/modules/template.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "template", function() { return _template_js__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony import */ var _result_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./result.js */ "./node_modules/underscore/modules/result.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "result", function() { return _result_js__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony import */ var _uniqueId_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./uniqueId.js */ "./node_modules/underscore/modules/uniqueId.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return _uniqueId_js__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony import */ var _chain_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./chain.js */ "./node_modules/underscore/modules/chain.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return _chain_js__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony import */ var _iteratee_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./iteratee.js */ "./node_modules/underscore/modules/iteratee.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iteratee", function() { return _iteratee_js__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return _partial_js__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony import */ var _bind_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./bind.js */ "./node_modules/underscore/modules/bind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return _bind_js__WEBPACK_IMPORTED_MODULE_60__["default"]; });

/* harmony import */ var _bindAll_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./bindAll.js */ "./node_modules/underscore/modules/bindAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindAll", function() { return _bindAll_js__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./memoize.js */ "./node_modules/underscore/modules/memoize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoize", function() { return _memoize_js__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _delay_js__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony import */ var _defer_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./defer.js */ "./node_modules/underscore/modules/defer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return _defer_js__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/underscore/modules/throttle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _throttle_js__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/underscore/modules/debounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _debounce_js__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/underscore/modules/wrap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return _wrap_js__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return _negate_js__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./compose.js */ "./node_modules/underscore/modules/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose_js__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _after_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./after.js */ "./node_modules/underscore/modules/after.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "after", function() { return _after_js__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./before.js */ "./node_modules/underscore/modules/before.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "before", function() { return _before_js__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony import */ var _once_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./once.js */ "./node_modules/underscore/modules/once.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "once", function() { return _once_js__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony import */ var _findKey_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./findKey.js */ "./node_modules/underscore/modules/findKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findKey", function() { return _findKey_js__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _findIndex_js__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony import */ var _findLastIndex_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./findLastIndex.js */ "./node_modules/underscore/modules/findLastIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return _findLastIndex_js__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony import */ var _sortedIndex_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./sortedIndex.js */ "./node_modules/underscore/modules/sortedIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortedIndex", function() { return _sortedIndex_js__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony import */ var _indexOf_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./indexOf.js */ "./node_modules/underscore/modules/indexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return _indexOf_js__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony import */ var _lastIndexOf_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./lastIndexOf.js */ "./node_modules/underscore/modules/lastIndexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return _lastIndexOf_js__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./find.js */ "./node_modules/underscore/modules/find.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _find_js__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detect", function() { return _find_js__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony import */ var _findWhere_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./findWhere.js */ "./node_modules/underscore/modules/findWhere.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findWhere", function() { return _findWhere_js__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "each", function() { return _each_js__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _each_js__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map_js__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "collect", function() { return _map_js__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony import */ var _reduce_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./reduce.js */ "./node_modules/underscore/modules/reduce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _reduce_js__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldl", function() { return _reduce_js__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return _reduce_js__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony import */ var _reduceRight_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./reduceRight.js */ "./node_modules/underscore/modules/reduceRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return _reduceRight_js__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldr", function() { return _reduceRight_js__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _filter_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _filter_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony import */ var _reject_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./reject.js */ "./node_modules/underscore/modules/reject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return _reject_js__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony import */ var _every_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./every.js */ "./node_modules/underscore/modules/every.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "every", function() { return _every_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _every_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony import */ var _some_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./some.js */ "./node_modules/underscore/modules/some.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "some", function() { return _some_js__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _some_js__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "include", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony import */ var _invoke_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./invoke.js */ "./node_modules/underscore/modules/invoke.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invoke", function() { return _invoke_js__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _pluck_js__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony import */ var _where_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./where.js */ "./node_modules/underscore/modules/where.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _where_js__WEBPACK_IMPORTED_MODULE_92__["default"]; });

/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./max.js */ "./node_modules/underscore/modules/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max_js__WEBPACK_IMPORTED_MODULE_93__["default"]; });

/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./min.js */ "./node_modules/underscore/modules/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min_js__WEBPACK_IMPORTED_MODULE_94__["default"]; });

/* harmony import */ var _shuffle_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./shuffle.js */ "./node_modules/underscore/modules/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _shuffle_js__WEBPACK_IMPORTED_MODULE_95__["default"]; });

/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./sample.js */ "./node_modules/underscore/modules/sample.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return _sample_js__WEBPACK_IMPORTED_MODULE_96__["default"]; });

/* harmony import */ var _sortBy_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./sortBy.js */ "./node_modules/underscore/modules/sortBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return _sortBy_js__WEBPACK_IMPORTED_MODULE_97__["default"]; });

/* harmony import */ var _groupBy_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./groupBy.js */ "./node_modules/underscore/modules/groupBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _groupBy_js__WEBPACK_IMPORTED_MODULE_98__["default"]; });

/* harmony import */ var _indexBy_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./indexBy.js */ "./node_modules/underscore/modules/indexBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexBy", function() { return _indexBy_js__WEBPACK_IMPORTED_MODULE_99__["default"]; });

/* harmony import */ var _countBy_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./countBy.js */ "./node_modules/underscore/modules/countBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "countBy", function() { return _countBy_js__WEBPACK_IMPORTED_MODULE_100__["default"]; });

/* harmony import */ var _partition_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./partition.js */ "./node_modules/underscore/modules/partition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _partition_js__WEBPACK_IMPORTED_MODULE_101__["default"]; });

/* harmony import */ var _toArray_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./toArray.js */ "./node_modules/underscore/modules/toArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _toArray_js__WEBPACK_IMPORTED_MODULE_102__["default"]; });

/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./size.js */ "./node_modules/underscore/modules/size.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "size", function() { return _size_js__WEBPACK_IMPORTED_MODULE_103__["default"]; });

/* harmony import */ var _pick_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./pick.js */ "./node_modules/underscore/modules/pick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return _pick_js__WEBPACK_IMPORTED_MODULE_104__["default"]; });

/* harmony import */ var _omit_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./omit.js */ "./node_modules/underscore/modules/omit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return _omit_js__WEBPACK_IMPORTED_MODULE_105__["default"]; });

/* harmony import */ var _first_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./first.js */ "./node_modules/underscore/modules/first.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "first", function() { return _first_js__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "head", function() { return _first_js__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _first_js__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony import */ var _initial_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./initial.js */ "./node_modules/underscore/modules/initial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initial", function() { return _initial_js__WEBPACK_IMPORTED_MODULE_107__["default"]; });

/* harmony import */ var _last_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./last.js */ "./node_modules/underscore/modules/last.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _last_js__WEBPACK_IMPORTED_MODULE_108__["default"]; });

/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./rest.js */ "./node_modules/underscore/modules/rest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rest", function() { return _rest_js__WEBPACK_IMPORTED_MODULE_109__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return _rest_js__WEBPACK_IMPORTED_MODULE_109__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return _rest_js__WEBPACK_IMPORTED_MODULE_109__["default"]; });

/* harmony import */ var _compact_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./compact.js */ "./node_modules/underscore/modules/compact.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compact", function() { return _compact_js__WEBPACK_IMPORTED_MODULE_110__["default"]; });

/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./flatten.js */ "./node_modules/underscore/modules/flatten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _flatten_js__WEBPACK_IMPORTED_MODULE_111__["default"]; });

/* harmony import */ var _without_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./without.js */ "./node_modules/underscore/modules/without.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "without", function() { return _without_js__WEBPACK_IMPORTED_MODULE_112__["default"]; });

/* harmony import */ var _uniq_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./uniq.js */ "./node_modules/underscore/modules/uniq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return _uniq_js__WEBPACK_IMPORTED_MODULE_113__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return _uniq_js__WEBPACK_IMPORTED_MODULE_113__["default"]; });

/* harmony import */ var _union_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./union.js */ "./node_modules/underscore/modules/union.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _union_js__WEBPACK_IMPORTED_MODULE_114__["default"]; });

/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./intersection.js */ "./node_modules/underscore/modules/intersection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return _intersection_js__WEBPACK_IMPORTED_MODULE_115__["default"]; });

/* harmony import */ var _difference_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./difference.js */ "./node_modules/underscore/modules/difference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _difference_js__WEBPACK_IMPORTED_MODULE_116__["default"]; });

/* harmony import */ var _unzip_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./unzip.js */ "./node_modules/underscore/modules/unzip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unzip", function() { return _unzip_js__WEBPACK_IMPORTED_MODULE_117__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _unzip_js__WEBPACK_IMPORTED_MODULE_117__["default"]; });

/* harmony import */ var _zip_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./zip.js */ "./node_modules/underscore/modules/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip_js__WEBPACK_IMPORTED_MODULE_118__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./object.js */ "./node_modules/underscore/modules/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "object", function() { return _object_js__WEBPACK_IMPORTED_MODULE_119__["default"]; });

/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./range.js */ "./node_modules/underscore/modules/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range_js__WEBPACK_IMPORTED_MODULE_120__["default"]; });

/* harmony import */ var _chunk_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./chunk.js */ "./node_modules/underscore/modules/chunk.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chunk", function() { return _chunk_js__WEBPACK_IMPORTED_MODULE_121__["default"]; });

/* harmony import */ var _mixin_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./mixin.js */ "./node_modules/underscore/modules/mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixin", function() { return _mixin_js__WEBPACK_IMPORTED_MODULE_122__["default"]; });

/* harmony import */ var _underscore_array_methods_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./underscore-array-methods.js */ "./node_modules/underscore/modules/underscore-array-methods.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _underscore_array_methods_js__WEBPACK_IMPORTED_MODULE_123__["default"]; });

// Named Exports
// =============

//     Underscore.js 1.11.0
//     https://underscorejs.org
//     (c) 2009-2020 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

// Baseline setup.



// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.

// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.



























// Functions that treat an object as a dictionary of key-value pairs.















// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.


















// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.















// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.









// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
























// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.



// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.

















// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.




/***/ }),

/***/ "./node_modules/underscore/modules/indexBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/indexBy.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");


// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  result[key] = value;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/indexOf.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/indexOf.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sortedIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sortedIndex.js */ "./node_modules/underscore/modules/sortedIndex.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _createIndexFinder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_createIndexFinder.js */ "./node_modules/underscore/modules/_createIndexFinder.js");




// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createIndexFinder_js__WEBPACK_IMPORTED_MODULE_2__["default"])(1, _findIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"], _sortedIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/initial.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/initial.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return initial; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial(array, n, guard) {
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}


/***/ }),

/***/ "./node_modules/underscore/modules/intersection.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/intersection.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return intersection; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");



// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array); i < length; i++) {
    var item = array[i];
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/invert.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/invert.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return invert; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/invoke.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/invoke.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");






// Invoke a method (with arguments) on every item in a collection.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, path, args) {
  var contextPath, func;
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path)) {
    func = path;
  } else if (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path)) {
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return Object(_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = Object(_deepGet_js__WEBPACK_IMPORTED_MODULE_4__["default"])(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
}));


/***/ }),

/***/ "./node_modules/underscore/modules/isArguments.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/isArguments.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



var isArguments = Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, 'callee');
    };
  }
}());

/* harmony default export */ __webpack_exports__["default"] = (isArguments);


/***/ }),

/***/ "./node_modules/underscore/modules/isArray.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isArray.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");



// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
/* harmony default export */ __webpack_exports__["default"] = (_setup_js__WEBPACK_IMPORTED_MODULE_0__["nativeIsArray"] || Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_1__["default"])('Array'));


/***/ }),

/***/ "./node_modules/underscore/modules/isArrayBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/isArrayBuffer.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('ArrayBuffer'));


/***/ }),

/***/ "./node_modules/underscore/modules/isBoolean.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isBoolean.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isBoolean; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || _setup_js__WEBPACK_IMPORTED_MODULE_0__["toString"].call(obj) === '[object Boolean]';
}


/***/ }),

/***/ "./node_modules/underscore/modules/isDataView.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/isDataView.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('DataView'));


/***/ }),

/***/ "./node_modules/underscore/modules/isDate.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/isDate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Date'));


/***/ }),

/***/ "./node_modules/underscore/modules/isElement.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isElement.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isElement; });
// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isEmpty.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isEmpty.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isEmpty; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");






// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) && (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) || Object(_isString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj) || Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj))) return obj.length === 0;
  return Object(_keys_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj).length === 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isEqual.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isEqual.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isEqual; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/underscore/modules/isTypedArray.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");








// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]) a = a._wrapped;
  if (b instanceof _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = _setup_js__WEBPACK_IMPORTED_MODULE_1__["toString"].call(a);
  if (className !== _setup_js__WEBPACK_IMPORTED_MODULE_1__["toString"].call(b)) return false;
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return _setup_js__WEBPACK_IMPORTED_MODULE_1__["SymbolProto"].valueOf.call(a) === _setup_js__WEBPACK_IMPORTED_MODULE_1__["SymbolProto"].valueOf.call(b);
    case '[object ArrayBuffer]':
      // Coerce to `DataView` so we can fall through to the next case.
      return deepEq(new DataView(a), new DataView(b), aStack, bStack);
    case '[object DataView]':
      var byteLength = Object(_getByteLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(a);
      if (byteLength !== Object(_getByteLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) {
        return false;
      }
      while (byteLength--) {
        if (a.getUint8(byteLength) !== b.getUint8(byteLength)) {
          return false;
        }
      }
      return true;
  }

  if (Object(_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(a)) {
    // Coerce typed arrays to `DataView`.
    return deepEq(new DataView(a.buffer), new DataView(b.buffer), aStack, bStack);
  }

  var areArrays = className === '[object Array]';
  if (!areArrays) {
    if (typeof a != 'object' || typeof b != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_4__["default"])(aCtor) && aCtor instanceof aCtor &&
                             Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_4__["default"])(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_5__["default"])(a), key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (Object(_keys_js__WEBPACK_IMPORTED_MODULE_5__["default"])(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!(Object(_has_js__WEBPACK_IMPORTED_MODULE_6__["default"])(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isError.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isError.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Error'));


/***/ }),

/***/ "./node_modules/underscore/modules/isFinite.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isFinite.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isFinite; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/underscore/modules/isSymbol.js");



// Is a given object a finite number?
function isFinite(obj) {
  return !Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_setup_js__WEBPACK_IMPORTED_MODULE_0__["_isFinite"])(obj) && !isNaN(parseFloat(obj));
}


/***/ }),

/***/ "./node_modules/underscore/modules/isFunction.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/isFunction.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");



var isFunction = Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = _setup_js__WEBPACK_IMPORTED_MODULE_1__["root"].document && _setup_js__WEBPACK_IMPORTED_MODULE_1__["root"].document.childNodes;
if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  isFunction = function(obj) {
    return typeof obj == 'function' || false;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (isFunction);


/***/ }),

/***/ "./node_modules/underscore/modules/isMap.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isMap.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Map'));


/***/ }),

/***/ "./node_modules/underscore/modules/isMatch.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isMatch.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isMatch; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(attrs), length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNaN.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isNaN.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isNaN; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNumber.js */ "./node_modules/underscore/modules/isNumber.js");



// Is the given value `NaN`?
function isNaN(obj) {
  return Object(_isNumber_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_setup_js__WEBPACK_IMPORTED_MODULE_0__["_isNaN"])(obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNull.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/isNull.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isNull; });
// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNumber.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isNumber.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Number'));


/***/ }),

/***/ "./node_modules/underscore/modules/isObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isObject.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isObject; });
// Is a given variable an object?
function isObject(obj) {
  var type = typeof obj;
  return type === 'function' || type === 'object' && !!obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isRegExp.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isRegExp.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('RegExp'));


/***/ }),

/***/ "./node_modules/underscore/modules/isSet.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isSet.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Set'));


/***/ }),

/***/ "./node_modules/underscore/modules/isString.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isString.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('String'));


/***/ }),

/***/ "./node_modules/underscore/modules/isSymbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isSymbol.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Symbol'));


/***/ }),

/***/ "./node_modules/underscore/modules/isTypedArray.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/isTypedArray.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/underscore/modules/constant.js");
/* harmony import */ var _isBufferLike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isBufferLike.js */ "./node_modules/underscore/modules/_isBufferLike.js");





// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__["nativeIsView"] ? (Object(_setup_js__WEBPACK_IMPORTED_MODULE_0__["nativeIsView"])(obj) && !Object(_isDataView_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) :
                Object(_isBufferLike_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj) && typedArrayPattern.test(_setup_js__WEBPACK_IMPORTED_MODULE_0__["toString"].call(obj));
}

/* harmony default export */ __webpack_exports__["default"] = (_setup_js__WEBPACK_IMPORTED_MODULE_0__["supportsArrayBuffer"] ? isTypedArray : Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(false));


/***/ }),

/***/ "./node_modules/underscore/modules/isUndefined.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/isUndefined.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isUndefined; });
// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isWeakMap.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isWeakMap.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('WeakMap'));


/***/ }),

/***/ "./node_modules/underscore/modules/isWeakSet.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isWeakSet.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('WeakSet'));


/***/ }),

/***/ "./node_modules/underscore/modules/iteratee.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/iteratee.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return iteratee; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/underscore/modules/_baseIteratee.js");



// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee(value, context) {
  return Object(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, context, Infinity);
}
_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee = iteratee;


/***/ }),

/***/ "./node_modules/underscore/modules/keys.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/keys.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return keys; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_collectNonEnumProps.js */ "./node_modules/underscore/modules/_collectNonEnumProps.js");





// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys(obj) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return [];
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeKeys"]) return Object(_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeKeys"])(obj);
  var keys = [];
  for (var key in obj) if (Object(_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["hasEnumBug"]) Object(_collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, keys);
  return keys;
}


/***/ }),

/***/ "./node_modules/underscore/modules/last.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/last.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return last; });
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest.js */ "./node_modules/underscore/modules/rest.js");


// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return Object(_rest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, Math.max(0, array.length - n));
}


/***/ }),

/***/ "./node_modules/underscore/modules/lastIndexOf.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/lastIndexOf.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _findLastIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findLastIndex.js */ "./node_modules/underscore/modules/findLastIndex.js");
/* harmony import */ var _createIndexFinder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_createIndexFinder.js */ "./node_modules/underscore/modules/_createIndexFinder.js");



// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createIndexFinder_js__WEBPACK_IMPORTED_MODULE_1__["default"])(-1, _findLastIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/map.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/map.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return map; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Return the results of applying the iteratee to each element.
function map(obj, iteratee, context) {
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length,
      results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/mapObject.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/mapObject.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mapObject; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject(obj, iteratee, context) {
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj),
      length = _keys.length,
      results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/matcher.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/matcher.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return matcher; });
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");
/* harmony import */ var _isMatch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isMatch.js */ "./node_modules/underscore/modules/isMatch.js");



// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher(attrs) {
  attrs = Object(_extendOwn_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, attrs);
  return function(obj) {
    return Object(_isMatch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, attrs);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/max.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/max.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return max; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");





// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity, lastComputed = -Infinity,
      value, computed;
  if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
    obj = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj : Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context);
    Object(_each_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/memoize.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/memoize.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return memoize; });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");


// Memoize an expensive function by storing its results.
function memoize(func, hasher) {
  var memoize = function(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!Object(_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}


/***/ }),

/***/ "./node_modules/underscore/modules/min.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/min.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return min; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");





// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
    obj = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj : Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context);
    Object(_each_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || computed === Infinity && result === Infinity) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/mixin.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/mixin.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mixin; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/underscore/modules/functions.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _chainResult_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_chainResult.js */ "./node_modules/underscore/modules/_chainResult.js");






// Add your own custom functions to the Underscore object.
function mixin(obj) {
  Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_functions_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj), function(name) {
    var func = _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"][name] = obj[name];
    _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
      var args = [this._wrapped];
      _setup_js__WEBPACK_IMPORTED_MODULE_3__["push"].apply(args, arguments);
      return Object(_chainResult_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this, func.apply(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"], args));
    };
  });
  return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"];
}


/***/ }),

/***/ "./node_modules/underscore/modules/negate.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/negate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return negate; });
// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/noop.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/noop.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noop; });
// Predicate-generating function. Often useful outside of Underscore.
function noop(){}


/***/ }),

/***/ "./node_modules/underscore/modules/now.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/now.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// A (possibly faster) way to get the current timestamp as an integer.
/* harmony default export */ __webpack_exports__["default"] = (Date.now || function() {
  return new Date().getTime();
});


/***/ }),

/***/ "./node_modules/underscore/modules/object.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return object; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");


// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object(list, values) {
  var result = {};
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/omit.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/omit.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");
/* harmony import */ var _pick_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pick.js */ "./node_modules/underscore/modules/pick.js");








// Return a copy of the object without the disallowed properties.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  var iteratee = keys[0], context;
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
    iteratee = Object(_negate_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = Object(_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_flatten_js__WEBPACK_IMPORTED_MODULE_4__["default"])(keys, false, false), String);
    iteratee = function(value, key) {
      return !Object(_contains_js__WEBPACK_IMPORTED_MODULE_5__["default"])(keys, key);
    };
  }
  return Object(_pick_js__WEBPACK_IMPORTED_MODULE_6__["default"])(obj, iteratee, context);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/once.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/once.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./before.js */ "./node_modules/underscore/modules/before.js");



// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
/* harmony default export */ __webpack_exports__["default"] = (Object(_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_before_js__WEBPACK_IMPORTED_MODULE_1__["default"], 2));


/***/ }),

/***/ "./node_modules/underscore/modules/pairs.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/pairs.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pairs; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs(obj) {
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}


/***/ }),

/***/ "./node_modules/underscore/modules/partial.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/partial.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _executeBound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_executeBound.js */ "./node_modules/underscore/modules/_executeBound.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");




// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return Object(_executeBound_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, bound, this, this, args);
  };
  return bound;
});

partial.placeholder = _underscore_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ __webpack_exports__["default"] = (partial);


/***/ }),

/***/ "./node_modules/underscore/modules/partition.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/partition.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");


// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true));


/***/ }),

/***/ "./node_modules/underscore/modules/pick.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/pick.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");
/* harmony import */ var _keyInObj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_keyInObj.js */ "./node_modules/underscore/modules/_keyInObj.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");







// Return a copy of the object only containing the allowed properties.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  var result = {}, iteratee = keys[0];
  if (obj == null) return result;
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
    if (keys.length > 1) iteratee = Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, keys[1]);
    keys = Object(_allKeys_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj);
  } else {
    iteratee = _keyInObj_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    keys = Object(_flatten_js__WEBPACK_IMPORTED_MODULE_5__["default"])(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/pluck.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/pluck.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pluck; });
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");



// Convenience version of a common use case of `_.map`: fetching a property.
function pluck(obj, key) {
  return Object(_map_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_property_js__WEBPACK_IMPORTED_MODULE_1__["default"])(key));
}


/***/ }),

/***/ "./node_modules/underscore/modules/property.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/property.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return property; });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");




// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  if (!Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path)) {
    return Object(_shallowProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  }
  return function(obj) {
    return Object(_deepGet_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, path);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/propertyOf.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/propertyOf.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return propertyOf; });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");



// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) {
    return function(){};
  }
  return function(path) {
    return !Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path) ? obj[path] : Object(_deepGet_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, path);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/random.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/random.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return random; });
// Return a random integer between `min` and `max` (inclusive).
function random(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}


/***/ }),

/***/ "./node_modules/underscore/modules/range.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/range.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return range; });
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/underscore/modules/reduce.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/reduce.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createReduce.js */ "./node_modules/underscore/modules/_createReduce.js");


// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1));


/***/ }),

/***/ "./node_modules/underscore/modules/reduceRight.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/reduceRight.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createReduce.js */ "./node_modules/underscore/modules/_createReduce.js");


// The right-associative version of reduce, also known as `foldr`.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-1));


/***/ }),

/***/ "./node_modules/underscore/modules/reject.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/reject.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return reject; });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");




// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_negate_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(predicate)), context);
}


/***/ }),

/***/ "./node_modules/underscore/modules/rest.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/rest.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rest; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest(array, n, guard) {
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(array, n == null || guard ? 1 : n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/restArguments.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/restArguments.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return restArguments; });
// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, arguments[0], rest);
      case 2: return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/result.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/result.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return result; });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");



// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result(obj, path, fallback) {
  if (!Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path)) path = [path];
  var length = path.length;
  if (!length) {
    return Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(prop) ? prop.call(obj) : prop;
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/sample.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/sample.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sample; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clone.js */ "./node_modules/underscore/modules/clone.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./random.js */ "./node_modules/underscore/modules/random.js");






// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) obj = Object(_values_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
    return obj[Object(_random_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj.length - 1)];
  }
  var sample = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? Object(_clone_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) : Object(_values_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
  var length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_3__["default"])(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = Object(_random_js__WEBPACK_IMPORTED_MODULE_4__["default"])(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/shuffle.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/shuffle.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shuffle; });
/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sample.js */ "./node_modules/underscore/modules/sample.js");


// Shuffle a collection.
function shuffle(obj) {
  return Object(_sample_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Infinity);
}


/***/ }),

/***/ "./node_modules/underscore/modules/size.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/size.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return size; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj.length : Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj).length;
}


/***/ }),

/***/ "./node_modules/underscore/modules/some.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/some.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return some; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}


/***/ }),

/***/ "./node_modules/underscore/modules/sortBy.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/sortBy.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sortBy; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");




// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  return Object(_pluck_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_map_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, function(value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}


/***/ }),

/***/ "./node_modules/underscore/modules/sortedIndex.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/sortedIndex.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sortedIndex; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex(array, obj, iteratee, context) {
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0, high = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
  }
  return low;
}


/***/ }),

/***/ "./node_modules/underscore/modules/tap.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/tap.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return tap; });
// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/template.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/template.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return template; });
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/underscore/modules/defaults.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templateSettings.js */ "./node_modules/underscore/modules/templateSettings.js");




// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

function escapeChar(match) {
  return '\\' + escapes[match];
}

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = Object(_defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, settings, _underscore_js__WEBPACK_IMPORTED_MODULE_1__["default"].templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;

    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";

  // If a variable is not specified, place data values in local scope.
  if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

  source = "var __t,__p='',__j=Array.prototype.join," +
    "print=function(){__p+=__j.call(arguments,'');};\n" +
    source + 'return __p;\n';

  var render;
  try {
    render = new Function(settings.variable || 'obj', '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  var template = function(data) {
    return render.call(this, data, _underscore_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
  };

  // Provide the compiled source as a convenience for precompilation.
  var argument = settings.variable || 'obj';
  template.source = 'function(' + argument + '){\n' + source + '}';

  return template;
}


/***/ }),

/***/ "./node_modules/underscore/modules/templateSettings.js":
/*!*************************************************************!*\
  !*** ./node_modules/underscore/modules/templateSettings.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
/* harmony default export */ __webpack_exports__["default"] = (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
});


/***/ }),

/***/ "./node_modules/underscore/modules/throttle.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/throttle.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return throttle; });
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");


// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}


/***/ }),

/***/ "./node_modules/underscore/modules/times.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/times.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return times; });
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");


// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}


/***/ }),

/***/ "./node_modules/underscore/modules/toArray.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/toArray.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toArray; });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");








// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return _setup_js__WEBPACK_IMPORTED_MODULE_1__["slice"].call(obj);
  if (Object(_isString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)) return Object(_map_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
  return Object(_values_js__WEBPACK_IMPORTED_MODULE_6__["default"])(obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/underscore-array-methods.js":
/*!*********************************************************************!*\
  !*** ./node_modules/underscore/modules/underscore-array-methods.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _chainResult_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chainResult.js */ "./node_modules/underscore/modules/_chainResult.js");





// Add all mutator `Array` functions to the wrapper.
Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
  var method = _setup_js__WEBPACK_IMPORTED_MODULE_2__["ArrayProto"][name];
  _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return Object(_chainResult_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(['concat', 'join', 'slice'], function(name) {
  var method = _setup_js__WEBPACK_IMPORTED_MODULE_2__["ArrayProto"][name];
  _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return Object(_chainResult_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this, obj);
  };
});

/* harmony default export */ __webpack_exports__["default"] = (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/underscore/modules/underscore.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/underscore.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}

_.VERSION = _setup_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"];

// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

_.prototype.toString = function() {
  return String(this._wrapped);
};


/***/ }),

/***/ "./node_modules/underscore/modules/unescape.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/unescape.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createEscaper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createEscaper.js */ "./node_modules/underscore/modules/_createEscaper.js");
/* harmony import */ var _unescapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unescapeMap.js */ "./node_modules/underscore/modules/_unescapeMap.js");



// Function for unescaping strings from HTML interpolation.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createEscaper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_unescapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/union.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/union.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _uniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniq.js */ "./node_modules/underscore/modules/uniq.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");




// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(arrays) {
  return Object(_uniq_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_flatten_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arrays, true, true));
}));


/***/ }),

/***/ "./node_modules/underscore/modules/uniq.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/uniq.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniq; });
/* harmony import */ var _isBoolean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isBoolean.js */ "./node_modules/underscore/modules/isBoolean.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");





// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!Object(_isBoolean_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array); i < length; i++) {
    var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!Object(_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!Object(_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(result, value)) {
      result.push(value);
    }
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/uniqueId.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/uniqueId.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniqueId; });
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}


/***/ }),

/***/ "./node_modules/underscore/modules/unzip.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/unzip.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return unzip; });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ "./node_modules/underscore/modules/max.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");




// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = array && Object(_max_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, _getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]).length || 0;
  var result = Array(length);

  for (var index = 0; index < length; index++) {
    result[index] = Object(_pluck_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, index);
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/values.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/values.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return values; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Retrieve the values of an object's properties.
function values(obj) {
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}


/***/ }),

/***/ "./node_modules/underscore/modules/where.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/where.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return where; });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");



// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(attrs));
}


/***/ }),

/***/ "./node_modules/underscore/modules/without.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/without.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _difference_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./difference.js */ "./node_modules/underscore/modules/difference.js");



// Return a version of the array that does not contain the specified value(s).
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, otherArrays) {
  return Object(_difference_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, otherArrays);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/wrap.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/wrap.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return wrap; });
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");


// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return Object(_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wrapper, func);
}


/***/ }),

/***/ "./node_modules/underscore/modules/zip.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/zip.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _unzip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unzip.js */ "./node_modules/underscore/modules/unzip.js");



// Zip together multiple lists into a single array -- elements that share
// an index go together.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_unzip_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ "./src/grid-editor/frameworks/jquery.iframe-transport.js":
/*!***************************************************************!*\
  !*** ./src/grid-editor/frameworks/jquery.iframe-transport.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * jQuery Iframe Transport Plugin 1.7
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint unparam: true, nomen: true */

/*global define, window, document */
(function (factory) {
  'use strict';

  if (true) {
    // Register as an anonymous AMD module:
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery-ui")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  'use strict'; // Helper variable to create unique names for the transport iframes:

  var counter = 0; // The iframe transport accepts three additional options:
  // options.fileInput: a jQuery collection of file input fields
  // options.paramName: the parameter name for the file form data,
  //  overrides the name property of the file input field(s),
  //  can be a string or an array of strings.
  // options.formData: an array of objects with name and value properties,
  //  equivalent to the return data of .serializeArray(), e.g.:
  //  [{name: 'a', value: 1}, {name: 'b', value: 2}]

  $.ajaxTransport('iframe', function (options) {
    if (options.async) {
      var form, iframe, addParamChar;
      return {
        send: function send(_, completeCallback) {
          form = $('<form style="display:none;"></form>');
          form.attr('accept-charset', options.formAcceptCharset);
          addParamChar = /\?/.test(options.url) ? '&' : '?'; // XDomainRequest only supports GET and POST:

          if (options.type === 'DELETE') {
            options.url = options.url + addParamChar + '_method=DELETE';
            options.type = 'POST';
          } else if (options.type === 'PUT') {
            options.url = options.url + addParamChar + '_method=PUT';
            options.type = 'POST';
          } else if (options.type === 'PATCH') {
            options.url = options.url + addParamChar + '_method=PATCH';
            options.type = 'POST';
          } // javascript:false as initial iframe src
          // prevents warning popups on HTTPS in IE6.
          // IE versions below IE8 cannot set the name property of
          // elements that have already been added to the DOM,
          // so we set the name along with the iframe HTML markup:


          counter += 1;
          iframe = $('<iframe src="javascript:false;" name="iframe-transport-' + counter + '"></iframe>').bind('load', function () {
            var fileInputClones,
                paramNames = $.isArray(options.paramName) ? options.paramName : [options.paramName];
            iframe.unbind('load').bind('load', function () {
              var response; // Wrap in a try/catch block to catch exceptions thrown
              // when trying to access cross-domain iframe contents:

              try {
                response = iframe.contents(); // Google Chrome and Firefox do not throw an
                // exception when calling iframe.contents() on
                // cross-domain requests, so we unify the response:

                if (!response.length || !response[0].firstChild) {
                  throw new Error();
                }
              } catch (e) {
                response = undefined;
              } // The complete callback returns the
              // iframe content document as response object:


              completeCallback(200, 'success', {
                'iframe': response
              }); // Fix for IE endless progress bar activity bug
              // (happens on form submits to iframe targets):

              $('<iframe src="javascript:false;"></iframe>').appendTo(form);
              window.setTimeout(function () {
                // Removing the form in a setTimeout call
                // allows Chrome's developer tools to display
                // the response result
                form.remove();
              }, 0);
            });
            form.prop('target', iframe.prop('name')).prop('action', options.url).prop('method', options.type);

            if (options.formData) {
              $.each(options.formData, function (index, field) {
                $('<input type="hidden"/>').prop('name', field.name).val(field.value).appendTo(form);
              });
            }

            if (options.fileInput && options.fileInput.length && options.type === 'POST') {
              fileInputClones = options.fileInput.clone(); // Insert a clone for each file input field:

              options.fileInput.after(function (index) {
                return fileInputClones[index];
              });

              if (options.paramName) {
                options.fileInput.each(function (index) {
                  $(this).prop('name', paramNames[index] || options.paramName);
                });
              } // Appending the file input fields to the hidden form
              // removes them from their original location:


              form.append(options.fileInput).prop('enctype', 'multipart/form-data') // enctype must be set as encoding for IE:
              .prop('encoding', 'multipart/form-data');
            }

            form.submit(); // Insert the file input fields at their original location
            // by replacing the clones with the originals:

            if (fileInputClones && fileInputClones.length) {
              options.fileInput.each(function (index, input) {
                var clone = $(fileInputClones[index]);
                $(input).prop('name', clone.prop('name'));
                clone.replaceWith(input);
              });
            }
          });
          form.append(iframe).appendTo(document.body);
        },
        abort: function abort() {
          if (iframe) {
            // javascript:false as iframe src aborts the request
            // and prevents warning popups on HTTPS in IE6.
            // concat is used to avoid the "Script URL" JSLint error:
            iframe.unbind('load').prop('src', 'javascript'.concat(':false;'));
          }

          if (form) {
            form.remove();
          }
        }
      };
    }
  }); // The iframe transport returns the iframe content document as response.
  // The following adds converters from iframe to text, json, html, xml
  // and script.
  // Please note that the Content-Type for JSON responses has to be text/plain
  // or text/html, if the browser doesn't include application/json in the
  // Accept header, else IE will show a download dialog.
  // The Content-Type for XML responses on the other hand has to be always
  // application/xml or text/xml, so IE properly parses the XML response.
  // See also
  // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation

  $.ajaxSetup({
    converters: {
      'iframe text': function iframeText(iframe) {
        return iframe && $(iframe[0].body).text();
      },
      'iframe json': function iframeJson(iframe) {
        return iframe && $.parseJSON($(iframe[0].body).text());
      },
      'iframe html': function iframeHtml(iframe) {
        return iframe && $(iframe[0].body).html();
      },
      'iframe xml': function iframeXml(iframe) {
        var xmlDoc = iframe && iframe[0];
        return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc : $.parseXML(xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml || $(xmlDoc.body).html());
      },
      'iframe script': function iframeScript(iframe) {
        return iframe && $.globalEval($(iframe[0].body).text());
      }
    }
  });
});

/***/ }),

/***/ "./src/grid-editor/frameworks/jquery.ui.touch-punch.js":
/*!*************************************************************!*\
  !*** ./src/grid-editor/frameworks/jquery.ui.touch-punch.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 2011–2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
(function ($) {
  // Detect touch support
  $.support.touch = 'ontouchend' in document; // Ignore browsers without touch support

  if (!$.support.touch) {
    return;
  }

  var mouseProto = $.ui.mouse.prototype,
      _mouseInit = mouseProto._mouseInit,
      _mouseDestroy = mouseProto._mouseDestroy,
      touchHandled;
  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */

  function simulateMouseEvent(event, simulatedType) {
    // Ignore multi-touch events
    if (event.originalEvent.touches.length > 1) {
      return;
    }

    event.preventDefault();
    var touch = event.originalEvent.changedTouches[0],
        simulatedEvent = document.createEvent('MouseEvents'); // Initialize the simulated mouse event using the touch event's coordinates

    simulatedEvent.initMouseEvent(simulatedType, // type
    true, // bubbles                    
    true, // cancelable                 
    window, // view                       
    1, // detail                     
    touch.screenX, // screenX                    
    touch.screenY, // screenY                    
    touch.clientX, // clientX                    
    touch.clientY, // clientY                    
    false, // ctrlKey                    
    false, // altKey                     
    false, // shiftKey                   
    false, // metaKey                    
    0, // button                     
    null // relatedTarget              
    ); // Dispatch the simulated event to the target element

    event.target.dispatchEvent(simulatedEvent);
  }
  /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */


  mouseProto._touchStart = function (event) {
    var self = this; // Ignore the event if another widget is already being handled

    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
      return;
    } // Set the flag to prevent other widgets from inheriting the touch event


    touchHandled = true; // Track movement to determine if interaction was a click

    self._touchMoved = false; // Simulate the mouseover event

    simulateMouseEvent(event, 'mouseover'); // Simulate the mousemove event

    simulateMouseEvent(event, 'mousemove'); // Simulate the mousedown event

    simulateMouseEvent(event, 'mousedown');
  };
  /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */


  mouseProto._touchMove = function (event) {
    // Ignore event if not handled
    if (!touchHandled) {
      return;
    } // Interaction was not a click


    this._touchMoved = true; // Simulate the mousemove event

    simulateMouseEvent(event, 'mousemove');
  };
  /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */


  mouseProto._touchEnd = function (event) {
    // Ignore event if not handled
    if (!touchHandled) {
      return;
    } // Simulate the mouseup event


    simulateMouseEvent(event, 'mouseup'); // Simulate the mouseout event

    simulateMouseEvent(event, 'mouseout'); // If the touch interaction did not move, it should trigger a click

    if (!this._touchMoved) {
      // Simulate the click event
      simulateMouseEvent(event, 'click');
    } // Unset the flag to allow other widgets to inherit the touch event


    touchHandled = false;
  };
  /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */


  mouseProto._mouseInit = function () {
    var self = this; // Delegate the touch handlers to the widget's element

    self.element.bind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    }); // Call the original $.ui.mouse init method

    _mouseInit.call(self);
  };
  /**
   * Remove the touch event handlers
   */


  mouseProto._mouseDestroy = function () {
    var self = this; // Delegate the touch handlers to the widget's element

    self.element.unbind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    }); // Call the original $.ui.mouse destroy method

    _mouseDestroy.call(self);
  };
})(jQuery);

/***/ }),

/***/ "./src/grid-editor/frameworks/mutate.events.js":
/*!*****************************************************!*\
  !*** ./src/grid-editor/frameworks/mutate.events.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function ($) {
  mutate_event_stack = [{
    name: 'width',
    handler: function handler(elem) {
      n = {
        el: elem
      };
      if (!$(n.el).data('mutate-width')) $(n.el).data('mutate-width', $(n.el).width());

      if ($(n.el).data('mutate-width') && $(n.el).width() != $(n.el).data('mutate-width')) {
        $(n.el).data('mutate-width', $(n.el).width());
        return true;
      }

      return false;
    }
  }, {
    name: 'height',
    handler: function handler(n) {
      element = n;
      if (!$(element).data('mutate-height')) $(element).data('mutate-height', $(element).height());

      if ($(element).data('mutate-height') && $(element).height() != $(element).data('mutate-height')) {
        $(element).data('mutate-height', $(element).height());
        return true;
      }
    }
  }, {
    name: 'top',
    handler: function handler(n) {
      if (!$(n).data('mutate-top')) $(n).data('mutate-top', $(n).css('top'));

      if ($(n).data('mutate-top') && $(n).css('top') != $(n).data('mutate-top')) {
        $(n).data('mutate-top', $(n).css('top'));
        return true;
      }
    }
  }, {
    name: 'bottom',
    handler: function handler(n) {
      if (!$(n).data('mutate-bottom')) $(n).data('mutate-bottom', $(n).css('bottom'));

      if ($(n).data('mutate-bottom') && $(n).css('bottom') != $(n).data('mutate-bottom')) {
        $(n).data('mutate-bottom', $(n).css('bottom'));
        return true;
      }
    }
  }, {
    name: 'right',
    handler: function handler(n) {
      if (!$(n).data('mutate-right')) $(n).data('mutate-right', $(n).css('right'));

      if ($(n).data('mutate-right') && $(n).css('right') != $(n).data('mutate-right')) {
        $(n).data('mutate-right', $(n).css('right'));
        return true;
      }
    }
  }, {
    name: 'left',
    handler: function handler(n) {
      if (!$(n).data('mutate-left')) $(n).data('mutate-left', $(n).css('left'));

      if ($(n).data('mutate-left') && $(n).css('left') != $(n).data('mutate-left')) {
        $(n).data('mutate-left', $(n).css('left'));
        return true;
      }
    }
  }, {
    name: 'hide',
    handler: function handler(n) {
      if ($(n).is(':hidden')) return true;
    }
  }, {
    name: 'show',
    handler: function handler(n) {
      if ($(n).is(':visible')) return true;
    }
  }, {
    name: 'scrollHeight',
    handler: function handler(n) {
      if (!$(n).data('prev-scrollHeight')) $(n).data('prev-scrollHeight', $(n)[0].scrollHeight);

      if ($(n).data('prev-scrollHeight') && $(n)[0].scrollHeight != $(n).data('prev-scrollHeight')) {
        $(n).data('prev-scrollHeight', $(n)[0].scrollHeight);
        return true;
      }
    }
  }, {
    name: 'scrollWidth',
    handler: function handler(n) {
      if (!$(n).data('prev-scrollWidth')) $(n).data('prev-scrollWidth', $(n)[0].scrollWidth);

      if ($(n).data('prev-scrollWidth') && $(n)[0].scrollWidth != $(n).data('prev-scrollWidth')) {
        $(n).data('prev-scrollWidth', $(n)[0].scrollWidth);
        return true;
      }
    }
  }, {
    name: 'scrollTop',
    handler: function handler(n) {
      if (!$(n).data('prev-scrollTop')) $(n).data('prev-scrollTop', $(n)[0].scrollTop());

      if ($(n).data('prev-scrollTop') && $(n)[0].scrollTop() != $(n).data('prev-scrollTop')) {
        $(n).data('prev-scrollTop', $(n)[0].scrollTop());
        return true;
      }
    }
  }, {
    name: 'scrollLeft',
    handler: function handler(n) {
      if (!$(n).data('prev-scrollLeft')) $(n).data('prev-scrollLeft', $(n)[0].scrollLeft());

      if ($(n).data('prev-scrollLeft') && $(n)[0].scrollLeft() != $(n).data('prev-scrollLeft')) {
        $(n).data('prev-scrollLeft', $(n)[0].scrollLeft());
        return true;
      }
    }
  }];
})(jQuery);

/***/ }),

/***/ "./src/grid-editor/frameworks/mutate.min.js":
/*!**************************************************!*\
  !*** ./src/grid-editor/frameworks/mutate.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @license jQuery-mutate
 * Licensed under the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 * Date: 2014-02-04
 */
;

(function ($) {
  mutate = {
    speed: 1,
    event_stack: mutate_event_stack,
    stack: [],
    events: {},
    add_event: function add_event(evt) {
      mutate.events[evt.name] = evt.handler;
    },
    add: function add(event_name, selector, callback, false_callback) {
      mutate.stack[mutate.stack.length] = {
        event_name: event_name,
        selector: selector,
        callback: callback,
        false_callback: false_callback
      };
    }
  };

  function reset() {
    var parent = mutate;

    if (parent.event_stack != 'undefined' && parent.event_stack.length) {
      $.each(parent.event_stack, function (j, k) {
        mutate.add_event(k);
      });
    }

    parent.event_stack = [];
    $.each(parent.stack, function (i, n) {
      $(n.selector).each(function (a, b) {
        if (parent.events[n.event_name](b) === true) {
          if (n['callback']) n.callback(b, n);
        } else {
          if (n['false_callback']) n.false_callback(b, n);
        }
      });
    });
    setTimeout(reset, mutate.speed);
  }

  reset();
  $.fn.extend({
    mutate: function (_mutate) {
      function mutate() {
        return _mutate.apply(this, arguments);
      }

      mutate.toString = function () {
        return _mutate.toString();
      };

      return mutate;
    }(function () {
      var event_name = false,
          callback = arguments[1],
          selector = this,
          false_callback = arguments[2] ? arguments[2] : function () {};

      if (arguments[0].toLowerCase() == 'extend') {
        mutate.add_event(callback);
        return this;
      }

      $.each($.trim(arguments[0]).split(' '), function (i, n) {
        event_name = n;
        mutate.add(event_name, selector, callback, false_callback);
      });
      return this;
    })
  });
})(jQuery);

/***/ }),

/***/ "./src/grid-editor/grid-editor.js":
/*!****************************************!*\
  !*** ./src/grid-editor/grid-editor.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery-ui */ "jquery-ui");
/* harmony import */ var jquery_ui__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_ui__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _frameworks_jquery_ui_touch_punch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./frameworks/jquery.ui.touch-punch.js */ "./src/grid-editor/frameworks/jquery.ui.touch-punch.js");
/* harmony import */ var _frameworks_jquery_ui_touch_punch_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_frameworks_jquery_ui_touch_punch_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _frameworks_jquery_iframe_transport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./frameworks/jquery.iframe-transport.js */ "./src/grid-editor/frameworks/jquery.iframe-transport.js");
/* harmony import */ var _frameworks_jquery_iframe_transport_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_frameworks_jquery_iframe_transport_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var blueimp_file_upload__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blueimp-file-upload */ "./node_modules/blueimp-file-upload/js/jquery.fileupload.js");
/* harmony import */ var blueimp_file_upload__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(blueimp_file_upload__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _frameworks_mutate_events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./frameworks/mutate.events.js */ "./src/grid-editor/frameworks/mutate.events.js");
/* harmony import */ var _frameworks_mutate_events_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_frameworks_mutate_events_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _frameworks_mutate_min_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./frameworks/mutate.min.js */ "./src/grid-editor/frameworks/mutate.min.js");
/* harmony import */ var _frameworks_mutate_min_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_frameworks_mutate_min_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _lib_GridViews_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/GridViews.js */ "./src/grid-editor/lib/GridViews.js");
/* harmony import */ var _lib_views_GridContainerEditorView_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/views/GridContainerEditorView.js */ "./src/grid-editor/lib/views/GridContainerEditorView.js");
/* harmony import */ var _lib_views_GridBoxEditorView_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/views/GridBoxEditorView.js */ "./src/grid-editor/lib/views/GridBoxEditorView.js");
/* harmony import */ var _lib_views_EditorWidgets_autocomplete_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/views/EditorWidgets/autocomplete.js */ "./src/grid-editor/lib/views/EditorWidgets/autocomplete.js");
/* harmony import */ var _lib_views_EditorWidgets_autocomplete_with_links_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/views/EditorWidgets/autocomplete_with_links.js */ "./src/grid-editor/lib/views/EditorWidgets/autocomplete_with_links.js");
/* harmony import */ var _lib_views_EditorWidgets_checkbox_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/views/EditorWidgets/checkbox.js */ "./src/grid-editor/lib/views/EditorWidgets/checkbox.js");
/* harmony import */ var _lib_views_EditorWidgets_file_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/views/EditorWidgets/file.js */ "./src/grid-editor/lib/views/EditorWidgets/file.js");
/* harmony import */ var _lib_views_EditorWidgets_hidden_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/views/EditorWidgets/hidden.js */ "./src/grid-editor/lib/views/EditorWidgets/hidden.js");
/* harmony import */ var _lib_views_EditorWidgets_html_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/views/EditorWidgets/html.js */ "./src/grid-editor/lib/views/EditorWidgets/html.js");
/* harmony import */ var _lib_views_EditorWidgets_info_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/views/EditorWidgets/info.js */ "./src/grid-editor/lib/views/EditorWidgets/info.js");
/* harmony import */ var _lib_views_EditorWidgets_input_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/views/EditorWidgets/input.js */ "./src/grid-editor/lib/views/EditorWidgets/input.js");
/* harmony import */ var _lib_views_EditorWidgets_list_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/views/EditorWidgets/list.js */ "./src/grid-editor/lib/views/EditorWidgets/list.js");
/* harmony import */ var _lib_views_EditorWidgets_multi_autocomplete_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/views/EditorWidgets/multi-autocomplete.js */ "./src/grid-editor/lib/views/EditorWidgets/multi-autocomplete.js");
/* harmony import */ var _lib_views_EditorWidgets_number_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/views/EditorWidgets/number.js */ "./src/grid-editor/lib/views/EditorWidgets/number.js");
/* harmony import */ var _lib_views_EditorWidgets_select_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/views/EditorWidgets/select.js */ "./src/grid-editor/lib/views/EditorWidgets/select.js");
/* harmony import */ var _lib_views_EditorWidgets_text_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/views/EditorWidgets/text.js */ "./src/grid-editor/lib/views/EditorWidgets/text.js");
/* harmony import */ var _lib_views_EditorWidgets_textarea_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/views/EditorWidgets/textarea.js */ "./src/grid-editor/lib/views/EditorWidgets/textarea.js");
/* harmony import */ var _lib_views_EditorWidgets_wp_mediaselect_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/views/EditorWidgets/wp_mediaselect.js */ "./src/grid-editor/lib/views/EditorWidgets/wp_mediaselect.js");
/* harmony import */ var _lib_views_GridRevisionsView_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/views/GridRevisionsView.js */ "./src/grid-editor/lib/views/GridRevisionsView.js");
/* harmony import */ var _lib_views_GridToolbarView_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/views/GridToolbarView.js */ "./src/grid-editor/lib/views/GridToolbarView.js");
/* harmony import */ var _lib_views_GridToolContainersView_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lib/views/GridToolContainersView.js */ "./src/grid-editor/lib/views/GridToolContainersView.js");
/* harmony import */ var _lib_views_GridToolBoxTypesView_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./lib/views/GridToolBoxTypesView.js */ "./src/grid-editor/lib/views/GridToolBoxTypesView.js");
/* harmony import */ var _lib_views_GridToolBoxBlueprintsView_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./lib/views/GridToolBoxBlueprintsView.js */ "./src/grid-editor/lib/views/GridToolBoxBlueprintsView.js");
/* harmony import */ var _lib_views_GridSlotStyleChangerView_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./lib/views/GridSlotStyleChangerView.js */ "./src/grid-editor/lib/views/GridSlotStyleChangerView.js");
/* harmony import */ var _lib_views_GridAuthorsView_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./lib/views/GridAuthorsView.js */ "./src/grid-editor/lib/views/GridAuthorsView.js");
/* harmony import */ var _lib_views_GridAuthorView_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./lib/views/GridAuthorView.js */ "./src/grid-editor/lib/views/GridAuthorView.js");
/* harmony import */ var _lib_GridModels_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./lib/GridModels.js */ "./src/grid-editor/lib/GridModels.js");
/* harmony import */ var _lib_models_GridBoxBlueprint_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./lib/models/GridBoxBlueprint.js */ "./src/grid-editor/lib/models/GridBoxBlueprint.js");
/* harmony import */ var _lib_models_GridRights_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./lib/models/GridRights.js */ "./src/grid-editor/lib/models/GridRights.js");
/* harmony import */ var _lib_models_GridAuthor_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./lib/models/GridAuthor.js */ "./src/grid-editor/lib/models/GridAuthor.js");
/* harmony import */ var _lib_GridCollections_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./lib/GridCollections.js */ "./src/grid-editor/lib/GridCollections.js");
/* harmony import */ var _lib_collections_GridBoxBlueprints_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./lib/collections/GridBoxBlueprints.js */ "./src/grid-editor/lib/collections/GridBoxBlueprints.js");
/* harmony import */ var _lib_collections_GridAuthors_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./lib/collections/GridAuthors.js */ "./src/grid-editor/lib/collections/GridAuthors.js");
/* harmony import */ var _lib_GridSync_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./lib/GridSync.js */ "./src/grid-editor/lib/GridSync.js");
/* harmony import */ var _lib_GridAsync_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./lib/GridAsync.js */ "./src/grid-editor/lib/GridAsync.js");
/* harmony import */ var _lib_Grid_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./lib/Grid.js */ "./src/grid-editor/lib/Grid.js");
/* harmony import */ var _language_grid_en_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./language/grid-en.js */ "./src/grid-editor/language/grid-en.js");
/* harmony import */ var _language_grid_en_js__WEBPACK_IMPORTED_MODULE_42___default = /*#__PURE__*/__webpack_require__.n(_language_grid_en_js__WEBPACK_IMPORTED_MODULE_42__);
// ----------------------------------------------------
// frameworks
// ----------------------------------------------------





 // ----------------------------------------------------
// grid custom javascript
// ----------------------------------------------------







































/***/ }),

/***/ "./src/grid-editor/language/grid-en.js":
/*!*********************************************!*\
  !*** ./src/grid-editor/language/grid-en.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// English
document.lang_values = {
  // Texts
  "btn-publish": "Publish",
  "btn-revert": "Revert",
  "btn-revisions": "Revisions",
  "btn-preview": "Preview",
  "btn-toggle-boxes": "Toggle boxes",
  "btn-add-container": "Add container",
  "btn-add-box": "Add box",
  "btn-cancle": "Cancel",
  "btn-save": "Save",
  "btn-make-reusable": "Make reusable",
  "btn-wp-media": "Mediendatei einfügen",
  "state-display": {
    "published": "Published!",
    "draft": "Is draft…"
  },
  "default-style": "Default style",
  "rev-by-author": "by",
  // Placeholder
  "placeholder-search-box": "Search boxes",
  // Titles
  "title-tab-containers": "New container",
  "title-tab-reuse-container": "Reusable container",
  "title-wp-media": "Choose an image",
  // Editor labels
  "label-title": "Title:",
  "label-title-url": "Title URL (for internals links please use a relative path starting with '/'):",
  "label-prolog": "Prolog:",
  "label-epilog": "Epilog:",
  "label-readmore": "Read more link label:",
  "label-readmore-url": "Read more link URL (for internals links please use a relative path starting with '/'):",
  "label-style": "Style:",
  "label-b-before": "Prolog",
  "label-b-dynamic": "Box specific settings",
  "label-b-after": "Epilog",
  // Errors: Something went wrong.
  "err_publish": "Could not publish…",
  "err_revert": "Could not revert Grid…",
  "err_container_reuse": "Error while trying to make container reusable!",
  "err_container_save": "Could not save container.",
  "err_container_delete": "Could not delete container.",
  "err_slot_style": "Could not save slot style.",
  "err_box_trash": "Could not delete box.",
  "err_move_container": "Could not move containers. Site will reload!",
  "err-move-box": "Error while moving box!",
  "err-box-reuse": "Could not make box reusable. Please reload the page and try again.",
  "err-box-save": "Could not save the box. Please reload the page and try again.",
  // Warnings: Nothing went wrong, but please do it another way.
  "warn_container_edited": "Please finish container editing first.",
  "warn_container_reuse_need_title": "The container needs a title to be reusable. Please try again.",
  "warn_toggle_boxes_container_edited": "Please finish the container editing first.",
  // Prompt
  "prom_container_reuse_title": "Once a container is reusable you cannot modify it within this grid anymore. " + "If you want to proceed choose a Reuse-Title and confirm:",
  // Confirm
  "confirm-box-reuse": "Once a box is reusable you cannot modify it within this grid anymore.\nProceed?",
  "confirm-leave-page": "Do you really want to leave Grid?",
  "confirm-grid-revert": "Delete all changes?",
  "info-wp-hide-adminbar": "You can expand the admin menu here. Grid needs some more space, so the admin menu is automatically collapsed."
};

/***/ }),

/***/ "./src/grid-editor/lib/Grid.js":
/*!*************************************!*\
  !*** ./src/grid-editor/lib/Grid.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GridAsync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GridAsync */ "./src/grid-editor/lib/GridAsync.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


/**
*	IE JS console fix
*/

(function () {
  var method;

  var noop = function noop() {};

  var methods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];
  var length = methods.length;
  var console = window.console = window.console || {};

  while (length--) {
    method = methods[length]; // Only stub undefined methods.

    if (!console[method]) {
      console[method] = noop;
    }
  }
})();
/** public object */


window.GRID = {};
var GRID = window.GRID = {
  $body: null,
  dom_root: "#new-grid-wrapper",
  $root: null,
  dom_root_editor: "#new-grid-editor-wrapper",
  $root_editor: null,
  dom_root_authors: "#grid-authors-wrapper",
  $root_authors: null,
  ID: null,
  // enable or disable debugging output
  DEBUGGING: false,
  // the server URL
  SERVER: "/grid_ajax_endpoint",
  // Pattern for preview URL
  PREVIEW_URL: window.location.pathname + '/preview',
  PREVIEW_PATTERN: window.location.pathname + '/{REV}/preview',
  // initializes the grid
  grid: null,
  gridView: null,
  types_box: null,
  types_container: null,
  reusable_containers: null,
  styles_container: null,
  styles_slot: null,
  styles_box: null,
  revisions: null,
  async: null,
  authors: null,
  init: function init() {
    // initialize constants
    this._initConstants();

    if (typeof GRID.ID === "undefined" || GRID.ID === null) return false;
    /**
     * loading indicator before grid is ready
     *
     */

    GRID.$loading = icanhaz__WEBPACK_IMPORTED_MODULE_0___default.a.tpl_loading();
    this.$root.append(GRID.$loading);
    GRID.$loading.addClass("grid-init-loading"); // load all model classes for grid works

    this.getBoxTypes().fetch();
    this.getContainerTypes().fetch();
    this.getReusableContainers().fetch();
    this.getContainerStyles().fetch();
    this.getSlotStyles().fetch();
    this.getBoxStyles().fetch();
    /**
     * init async websocket magic
     * @type {GridAsync}
     */

    this.async = new _GridAsync__WEBPACK_IMPORTED_MODULE_1__["GridAsync"]();
    this.authors = new GridAuthors();
    this.async.addObserver(this);
    this.async.addObserver(this.authors);
    this.getRights().fetch({
      success: function success() {
        // load the grid + view
        GRID.grid = new Grid({
          id: GRID.ID,
          SERVER: GRID.SERVER,
          PREVIEW_URL: GRID.PREVIEW_URL,
          DEBUGGING: GRID.DEBUGGING,
          fn_success: GRID.new_grid_success
        });
      }
    });
    var $body = this.$body;
    $body.on("keydown", function (e) {
      altModificationClass(e.altKey);
    }).on("keyup", function (e) {
      altModificationClass(e.altKey);
    });

    function altModificationClass(isPressed) {
      if (isPressed) {
        $body.addClass("is-alt-pressed");
      } else {
        $body.removeClass("is-alt-pressed");
      }
    }

    return this;
  },
  reload: function reload() {
    this.grid.destroy();
    this.grid = null;
    this.$root_authors.empty();

    if (this.gridView != null) {
      this.gridView.remove();
    }

    this.newGrid();
  },
  newGrid: function newGrid() {
    // load the grid + view
    this.grid = new Grid({
      id: GRID.ID,
      SERVER: this.SERVER,
      PREVIEW_URL: this.PREVIEW_URL,
      DEBUGGING: this.DEBUGGING,
      fn_success: GRID.new_grid_success
    });
    return this;
  },
  new_grid_success: function new_grid_success(data) {
    GRID.$root.empty();
    GRID.$root.append(GRID.$loading);
    GRID.gridview = new GridView({
      model: GRID.getModel()
    }); // handle rights

    GRID.gridview.listenTo(GRID.getRights(), "change", GRID.onRights);
    GRID.$root.append(GRID.getView().render().el);

    GRID._initializeContainerSortable();

    GRID._initializeBoxSortable(); // load the revisions


    GRID.revisions = new Revisions({
      grid: GRID.getModel()
    });
    GRID.revisions.fetch(); // init toolbar

    GRID.toolbar = new GridToolbarView({
      model: GRID.getModel()
    });
    GRID.async.addObserver(GRID.toolbar);
    GRID.$root.prepend(GRID.toolbar.render().el);
    GRID.$loading.removeClass("grid-init-loading");
    /**
     * init async connection on grid loading done
     */

    GRID.async.init();
    /**
     * listen to changes of window size
     */

    jQuery(window).resize(function () {
      GRID.toolbar.onResize();
    }).trigger("resize");
  },
  getModel: function getModel() {
    return this.grid;
  },
  getView: function getView() {
    return this.gridview;
  },
  // type collections
  getContainerTypes: function getContainerTypes() {
    if (!(this.types_container instanceof ContainerTypes)) {
      this.types_container = new ContainerTypes();
    }

    return this.types_container;
  },
  getReusableContainers: function getReusableContainers() {
    if (!(this.reusable_containers instanceof ReusableContainers)) {
      this.reusable_containers = new ReusableContainers();
    }

    return this.reusable_containers;
  },
  getBoxTypes: function getBoxTypes() {
    if (!(this.types_box instanceof BoxTypes)) {
      this.types_box = new BoxTypes();
    }

    return this.types_box;
  },
  // style collections
  getContainerStyles: function getContainerStyles() {
    if (!(this.styles_container instanceof Styles)) {
      this.styles_container = new Styles({
        type: "container"
      });
    }

    return this.styles_container;
  },
  getSlotStyles: function getSlotStyles() {
    if (!(this.styles_slot instanceof Styles)) {
      this.styles_slot = new Styles({
        type: "slot"
      });
    }

    return this.styles_slot;
  },
  getBoxStyles: function getBoxStyles() {
    if (!(this.styles_box instanceof Styles)) {
      this.styles_box = new Styles({
        type: "box"
      });
    }

    return this.styles_box;
  },
  getRights: function getRights() {
    if (!(this.rights instanceof GridRights)) {
      this.rights = new GridRights();
    }

    return this.rights;
  },
  // revisions
  setToRevision: function setToRevision(revision) {
    if (GRID.locked()) return;
    GridRequest.grid.update(GRID.grid, {
      action: "setToRevision",
      revision: revision
    });
  },
  // onRightsChange
  onRights: function onRights(rights) {
    GRID.log(["onrights", rights]);
    GRID.getView().render();
    GRID.toolbar.render();
  },
  // initializes the constatns
  _initConstants: function _initConstants() {
    // root elements
    this.$body = jQuery("body");
    this.$root = jQuery(this.dom_root);
    this.$root_editor = jQuery(this.dom_root_editor);
    this.$root_authors = jQuery(this.dom_root_authors); // constants from CMS

    this.mode = document.gridmode;
    this.$root.addClass('gridmode-' + this.mode);
    this.DEBUGGING = document.grid_debug_mode;
    this.ID = document.ID;
    this.SERVER = "/grid_ajax_endpoint";

    if (typeof document.gridajax != "undefined" && document.gridajax != null && document.gridajax != "") {
      this.SERVER = document.gridajax;
    }

    this.PREVIEW_URL = this.PREVIEW_URL.replace("//", "/");

    if (_typeof(document.previewurl) != ( true ? "undefined" : undefined) && document.previewurl != null && document.previewurl != "") {
      this.PREVIEW_URL = document.previewurl;
    }

    var PREVIEW_PATTERN = window.location.pathname + '/{REV}/preview';

    if (_typeof(document.previewpattern) != ( true ? "undefined" : undefined) && document.previewpattern != null && document.previewpattern != "") {
      PREVIEW_PATTERN = document.previewpattern;
    }

    this.PREVIEW_PATTERN = PREVIEW_PATTERN;
  },
  // publishes the grid
  publish: function publish() {
    if (!GRID.getRights().get("publish") || GRID.locked()) {
      alert("Sorry you have no rights for that...");
      return false;
    }

    new GridAjax("publishDraft", [GRID.ID]);
  },
  // revert to old revision
  revert: function revert() {
    if (GRID.locked()) return;
    GridRequest.grid.update(GRID.grid, {
      action: "revertDraft"
    });
  },
  // console logging just with DEBUGGING enabled
  log: function log(string) {
    if (this.DEBUGGING) {
      console.log(string);
    }
  },

  /**
   * change to box and container editor
   */
  showEditor: function showEditor(callback) {
    GRID.$root.animate({
      width: 0
    }, 220, function () {
      GRID.$root.hide();
    });
    setTimeout(function () {
      GRID.$root_editor.show();
      GRID.$root_editor.animate({
        width: "100%"
      }, 250, function () {
        callback();
      });
      window.scrollTo(0, 0);
    }, 50);
  },
  hideEditor: function hideEditor(callback) {
    GRID.$root_editor.animate({
      width: "0%"
    }, 220, function () {
      GRID.$root_editor.hide();
    });
    setTimeout(function () {
      GRID.$root.show();
      GRID.$root.animate({
        width: "100%"
      }, 220, function () {
        callback();
      });
      window.scrollTo(0, 0);
    }, 50);
  },

  /**
   * change to authors
   */
  toggleAuthors: function toggleAuthors() {
    if (GRID.$root_authors.html() == "") {
      GRID.$root_authors.empty();
      var authors = new Authors();
      GRID.$root_authors.append(authors.render().$el);
      authors.listenTo(GRID.toolbar, 'toolbar_resize', authors.onResize);
    }

    GRID.$root.toggleClass("is-active-authors");
    GRID.$root_authors.toggleClass("is-active");
    GRID.toolbar.onResize();
  },
  showAuthors: function showAuthors() {
    this.hideAuthors();
    this.toggleAuthors();
  },
  hideAuthors: function hideAuthors() {
    GRID.$root.removeClass("is-active-authors");
    GRID.$root_authors.removeClass("is-active");
  },
  locked: function locked() {
    return !GRID.authors.haveLock();
  },
  async_locking_is_locked: function async_locking_is_locked() {
    if (GRID.locked()) {
      GRID.$root.addClass("grid-is-locked");
      GRID.showAuthors();
    } else if (GRID.$root.hasClass("grid-is-locked")) {
      GRID.reload();
      GRID.$root.removeClass("grid-is-locked");
      this.hideAuthors();
    }
  },
  async_disconnect: function async_disconnect() {
    this.async_locking_is_locked();
  },
  // initializes function to sort the containers
  _initializeContainerSortable: function _initializeContainerSortable() {
    if (!GRID.getRights().get("move-container") || GRID.locked()) return false;
    var container_deleted;
    container_deleted = false;
    var container;
    var self = this;
    jQuery(this.getView().el).sortable({
      handle: ".grid-container-sorthandle, .grid-container-reused-layer",
      items: ".grid-container:not(.grid-container-type-sc)",
      placeholder: "grid-container-sort-placeholder",
      pullPlaceholder: true,
      appendTo: this.getView().$el,
      refreshPositions: true,
      helper: function helper(event, element) {
        return jQuery("<div class='dragger-helper'></div>");
      },
      cursorAt: {
        left: 30,
        bottom: 30
      },
      start: function start(event, ui) {
        GRID.log(["container sort START"], event, ui);
        var old_container_id = ui.item.data("id");
        jQuery(".grid-element-trash").addClass("grid-active").droppable({
          accept: '.grid-container',
          hoverClass: 'grid-hover',
          drop: function drop(e, ui) {
            container = GRID.getModel().getContainers().get(old_container_id);
            container_deleted = true;
          }
        });
      },
      stop: function stop(event, ui) {
        jQuery(".grid-element-trash").removeClass('grid-active');

        if (container_deleted) {
          container.destroy();
        }
      },
      update: function update(event, ui) {
        if (container_deleted) return;
        var containerview = ui.item.attr("data-cid");
        var newIndex = ui.item.index();
        var containermodel = GRID.getModel().getContainers().get(containerview);
        var oldIndex = GRID.getModel().getContainers().indexOf(containermodel);
        GRID.getModel().getContainers().move(containermodel, newIndex);
      }
    });
  },
  // initializes function to sort the containers
  _initializeBoxSortable: function _initializeBoxSortable() {
    if (!GRID.getRights().get("move-box") || GRID.locked()) return false;
    var old_box_index, old_slot_id, old_container_id, new_box_index, new_slot_id, new_container_id, box_deleted, box_duplicated;
    box_deleted = false;
    box_duplicated = false;
    jQuery(this.getView().el).find(".grid-container-type-c[data-reused=false] .grid-boxes-wrapper, .grid-container-type-sc .grid-boxes-wrapper").sortable({
      items: ".grid-box",
      handle: ".grid-box-controls",
      //cancel: ".grid-box-edit, .grid-box-delete",
      connectWith: ".grid-container-type-c[data-reused=false] .grid-boxes-wrapper, .grid-element-trash",
      placeholder: "grid-box-sort-placeholder",
      forcePlaceholderSize: true,
      distance: 10,
      refreshPositions: true,
      helper: function helper(event, element) {
        return jQuery("<div class='dragger-helper'></div>");
      },
      cursorAt: {
        left: 30,
        top: 30
      },
      start: function start(e, ui) {
        box_duplicated = false;
        box_deleted = false;
        old_box_index = ui.item.index();
        old_slot_id = ui.item.parents(".grid-slot").data("id");
        old_container_id = ui.item.parents(".grid-container").data("id");
        GRID.log(["START BOX SORT", old_box_index, old_slot_id, old_container_id]);
        jQuery(".grid-element-trash").addClass("grid-active").droppable({
          accept: '.grid-slot .grid-box',
          hoverClass: 'grid-hover',
          over: function over() {
            box_deleted = true;
          },
          out: function out() {
            box_deleted = false;
          },
          drop: function drop(e, ui) {
            var box = GRID.getModel().getContainers().get(old_container_id).getSlots().get(old_slot_id).getBox(old_box_index);
            box.destroy();
            box_deleted = true;
          }
        });
        jQuery(".grid-element-duplicate").addClass("grid-active").droppable({
          accept: '.grid-slot .grid-box',
          hoverClass: 'grid-hover',
          over: function over() {
            box_duplicated = true;
          },
          out: function out() {
            box_duplicated = false;
          },
          drop: function drop(e, ui) {
            box_duplicated = true;
            var box = GRID.getModel().getContainers().get(old_container_id).getSlots().get(old_slot_id).getBox(old_box_index);
            GRID.getModel().duplicateBox(box, old_box_index + 1);
          }
        });
      },
      beforeStop: function beforeStop(e, ui) {
        jQuery(".grid-element-trash").removeClass("grid-active");
        jQuery(".grid-element-duplicate").removeClass("grid-active");

        if (box_deleted || box_duplicated) {
          e.preventDefault();
        }
      },
      stop: function stop(e, ui) {
        new_container_id = ui.item.parents(".grid-container").data("id");
        new_slot_id = ui.item.parents(".grid-slot").data("id");
        new_box_index = ui.item.index();
        GRID.log(["STOP BOX SORT", old_box_index, old_slot_id, old_container_id, new_box_index, new_slot_id, new_container_id]);

        if (old_container_id == new_container_id && old_slot_id == new_slot_id && old_box_index == new_box_index) {
          return;
        }

        var box = GRID.getModel().getContainers().get(old_container_id).getSlots().get(old_slot_id).getBox(old_box_index);
        var new_slot = GRID.getModel().getContainers().get(new_container_id).getSlots().get(new_slot_id);
        GRID.getModel().moveBox(box, new_slot, new_box_index);
      }
    });
  },
  flash: function flash() {
    GRID.gridview.$el.fadeIn(100).fadeOut(100).fadeIn(100);
  },
  startLoading: function startLoading() {
    clearTimeout(GRID.loading_hide_timeout);
    GRID.$loading.show();
    GRID.$loading.addClass("loading");
  },
  finishLoading: function finishLoading() {
    GRID.$loading.removeClass("loading");
    clearTimeout(GRID.loading_hide_timeout);
    GRID.loading_hide_timeout = setTimeout(function () {
      GRID.$loading.hide();
    }, 1200);
  }
};
jQuery(function () {
  GRID.init();
});

/***/ }),

/***/ "./src/grid-editor/lib/GridAsync.js":
/*!******************************************!*\
  !*** ./src/grid-editor/lib/GridAsync.js ***!
  \******************************************/
/*! exports provided: GridAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridAsync", function() { return GridAsync; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ "./node_modules/socket.io-client/lib/index.js");
/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(socket_io_client__WEBPACK_IMPORTED_MODULE_1__);


function GridAsync() {
  var self = this;
  this.domain = document.grid.async.domain;
  this.path = document.grid.async.path;
  this.author = document.grid.async.author;
  this.timeout = document.grid.async.timeout;
  this.observers = [];
  this.browser_identifier = window.localStorage.getItem("grid_browser_identifier");

  if (this.browser_identifier == null) {
    this.browser_identifier = Math.random().toString(36).substring(7);
    window.localStorage.setItem("grid_browser_identifier", this.browser_identifier);
  }

  this.last_time = new Date().getTime();

  this._onIdleInterval = function () {
    var time = new Date().getTime();
    var diff = time - self.last_time;

    if (diff >= this.timeout * 1000 && GRID.authors.length > 0 && GRID.authors.haveLock()) {
      window.location.reload(true);
    }
  };

  var idle_interval = setInterval(function () {
    self._onIdleInterval();
  }, 1000);

  this._onActivity = function () {
    self.last_time = new Date().getTime();
  };

  jQuery('body').on('mousemove', function () {
    self._onActivity();
  }).on('keypress', function () {
    self._onActivity();
  });
  /**
   * init function
   */

  this.init = function () {
    if (document.grid.async.service != '') {
      this.socket = socket_io_client__WEBPACK_IMPORTED_MODULE_1___default()(document.grid.async.service);
      this.initEvents();
    }
  };

  this.addObserver = function (observer) {
    this.observers.push(observer);
  };

  this.removeObserver = function (observer) {
    this.observers = underscore__WEBPACK_IMPORTED_MODULE_0__["default"].without(this.observers, observer);
  };

  this.notifyAll = function (_event, data) {
    underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(this.observers, function (_observer, index, list) {
      if (typeof _observer["async_" + _event] == "function") {
        _observer["async_" + _event](data);
      }
    });
  };
  /**
   * Grid Async server events
   */


  this.initEvents = function () {
    this.on("connect", "connect");
    this.on("disconnect", "disconnect"); // authors

    this.on("authors.list", "authors_list");
    this.on("authors.joined", "authors_joined");
    this.on("authors.left", "authors_left");
    this.on("authors.multiplehits", "authors_multihit"); // locking

    this.on("locking.isLocked", "locking_is_locked");
    this.on("locking.lockRequested", "locking_lock_requested"); // ping

    this.on('ping.send', "ping_send");
  };

  this.on = function (e, f) {
    var self = this;
    this.socket.on(e, function (data) {
      self[f](data);
    });
  };

  this.connect = function (data) {
    this.authors_join();
  };

  this.disconnect = function (data) {
    this.notifyAll("disconnect");
    this.notifyAll("locking_is_locked");
  };
  /**
   * authors
   */


  this.authors_join = function () {
    this.socket.emit("authors.join", {
      domain: this.domain,
      path: this.path,
      author: this.author,
      identity: this.browser_identifier
    });
  };
  /**
   * locking
   */


  this.locking_request_lock = function () {
    this.socket.emit("locking.requestLock");
  };

  this.locking_handover = function (identifier) {
    GRID.authors.each(function (author) {
      author.set("request_lock", false);
    });
    this.socket.emit("locking.handover", identifier);
  };

  this.locking_deny_handover = function (identifier) {
    this.socket.emit("locking.denyHandover", identifier);
  };
  /**
   * authors events
   */


  this.authors_list = function (data) {
    this.notifyAll("authors_list", data);
  };

  this.authors_joined = function (data) {
    this.notifyAll("authors_joined", data);
  };

  this.authors_left = function (id) {
    this.notifyAll("authors_left", id);
  };

  this.authors_multihit = function (count) {
    alert("You have opened this grid on " + count + " browser windows. As parallel editing is not allowed you're locked out here.");
  };
  /**
   * locking events
   */


  this.locking_is_locked = function (data) {
    GRID.authors.resetLock();

    if (data.isLocked) {
      GRID.authors.setLock(data.identifier);
    }

    this.notifyAll("locking_is_locked");
  };

  this.locking_lock_requested = function (data) {
    var author = GRID.authors.get(data.identifier);

    if (author instanceof GridAuthor) {
      author.set("request_lock", true);
    }

    this.notifyAll("request_lock");
  };
  /**
   * ping events
   */


  var _ping_timeout = null;

  this.ping_send = function () {
    self.socket.emit('ping.received');
  };
}

/***/ }),

/***/ "./src/grid-editor/lib/GridCollections.js":
/*!************************************************!*\
  !*** ./src/grid-editor/lib/GridCollections.js ***!
  \************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

window.Revisions = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: Revision,
  initialize: function initialize(spec) {
    if (!spec || !spec.grid || !(spec.grid instanceof Grid)) {
      throw "InvalidConstructArgs Revisions need a Grid";
    }

    this.grid = spec.grid;
  },
  getGridID: function getGridID() {
    GRID.log(this);
    return this.grid.getGridID();
  },
  sync: function sync(method, collection, options) {
    GridRequest.revisions(collection, options);
  }
}); // type collections

window.ContainerTypes = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: ContainerType,
  sync: function sync(method, collection, options) {
    GridRequest.containertypes(collection, options);
  }
});
window.ReusableContainers = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: ContainerType,
  sync: function sync(method, collection, options) {
    GridRequest.reusablecontainers(collection, options);
  }
});
window.BoxTypes = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: BoxType,
  sync: function sync(method, collection, options) {
    GridRequest.boxtypes(collection, options);
  }
});
window.Styles = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: StyleType,
  initialize: function initialize(spec) {
    if (!spec || !spec.type) {
      throw "InvalidConstructArgs Styles";
    }

    this.type = spec.type;
  },
  sync: function sync(method, collection, options) {
    GridRequest.styles(collection, options);
  }
}); // element collections

window.Containers = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: Container,
  move: function move(container, to_index) {
    var self = this;
    GridRequest.container.update(container, {
      action: "move",
      index: to_index,
      success: function success(data) {
        self.remove(container);
        self.add(container, {
          at: to_index
        });
      }
    });
    return this;
  }
});
window.Slots = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: Slot
});
window.Boxes = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: Box
});

/***/ }),

/***/ "./src/grid-editor/lib/GridModels.js":
/*!*******************************************!*\
  !*** ./src/grid-editor/lib/GridModels.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

 // ----------------------
// type models
// ---------------------

window.ContainerType = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  getDimension: function getDimension() {
    var dimension = "";
    var i = 0;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.get("type").split("-"), function (value, key, list) {
      if (value == 0 || i++ == 0) return;
      dimension += "-" + value;
    });

    return dimension.substring(1);
  },
  getType: function getType() {
    return this.get("type").split("-")[0];
  }
});
window.BoxType = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  defaults: function defaults() {
    return {
      type: null,
      criteria: null,
      blueprints: null
    };
  },
  getBlueprints: function getBlueprints() {
    if (!(this.blueprints instanceof GridBoxBlueprints)) {
      this.blueprints = new GridBoxBlueprints();
    }

    return this.blueprints;
  },
  searchBoxes: function searchBoxes() {
    GRID.log(["BoxType->searchBoxes", this]);
    var blueprints = this.getBlueprints();
    blueprints.fetch({
      type: this.get("type"),
      criteria: this.get("criteria"),
      searchString: ""
    });
    this.set("blueprints", blueprints);
    return blueprints;
  },
  search: function search(query, criteria) {
    var blueprints = new GridBoxBlueprints();
    blueprints.fetch({
      type: this.get("type"),
      criteria: criteria,
      searchString: query
    });
    return blueprints;
  }
});
window.StyleType = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({}); // --------------------------
// Revisions model
//  -----------------------

window.Revision = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  initialize: function initialize(spec) {
    this.set("id", spec.revision);
  }
}); // ----------------------------------------
// Main model.
// this is the wrapper of the grid elements
//
// -----------------------------------------

window.Grid = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  defaults: function defaults() {
    return {
      id: -1,
      // enable or disable debugging output
      DEBUGGING: false,
      // the server URL
      SERVER: "/grid_ajax_endpoint",
      // Pattern for preview URL
      PREVIEW_URL: window.location.pathname + '/preview',
      // 0 == false == unknown, 1 published, 2 draft
      isDraft: true
    };
  },
  getGridID: function getGridID() {
    return GRID.ID;
  },
  // invokes when the model is created
  initialize: function initialize(spec) {
    // Grid object needs an ID
    if (!spec || !spec.id) {
      throw "InvalidConstructArgs";
    }

    var self = this;
    this.fetch({
      success: spec.fn_success
    });
  },
  createContainer: function createContainer(type, index, reused) {
    var self = this;
    var container = new Container({
      type: type,
      parent: this
    });

    if (typeof reused === "undefined") {
      container.set("reused", false);
    } else {
      container.set("reused", reused);
    }

    container.save(null, {
      index: index,
      action: "create",
      // resoinse is always undefined, because we are not using backbones ajax call
      success: function success(container, response, options) {
        GRID.log("CreateContainerSuccess::");
        GRID.log([container, response, options]);
        self.addContainer(container, index);
      },
      error: function error(container, response, options) {
        GRID.log("CreateContainerror::");
        GRID.log([container, response, options]);
      }
    });
  },
  addContainer: function addContainer(element, index) {
    if (!(element instanceof Container)) throw "Try to add an not Container Object: Grid.addContainer";
    var args = {};
    if (typeof index === "number") args.at = index;
    element.set("parent", this);
    this.getContainers().add(element, args);
  },
  addReuseContainer: function addReuseContainer(containertype, index) {
    var self = this;
    GridRequest.grid.addReuseContainer(containertype, index, function (data) {
      self.addContainer(new Container(data.result), index);
    });
    return this;
  },
  getContainers: function getContainers() {
    if (!this.get("collection_containers")) {
      this.set("collection_containers", new Containers());
    }

    return this.get("collection_containers");
  },
  getContainer: function getContainer(index) {
    return this.getContainers().at(index);
  },
  moveBox: function moveBox(box, new_slot, new_box_index) {
    GridRequest.grid.moveBox(box, new_slot, new_box_index, function (data) {
      var clone = box.clone();
      box.getSlot().getBoxes().remove(box);
      new_slot.addBox(clone, new_box_index);
    });
  },
  duplicateBox: function duplicateBox(box, toIndex) {
    var clone = box.clone();
    GridRequest.box.create(clone, {
      index: toIndex,
      success: function success() {
        clone.setDuplicated();
        box.getSlot().addBox(clone, toIndex);
      }
    });
  },
  checkIsDraft: function checkIsDraft() {
    GridRequest.grid.read(this, {
      action: "checkdraft"
    });
  },
  // handles all Server communication
  sync: function sync(method, model, options) {
    if (typeof GridRequest.grid[method] == "function") {
      GridRequest.grid[method](model, options);
    } else {
      GRID.log("grid sync metod not defined " + method);
    }
  }
}); //---------------------
// element models
// -------------------

window.Container = ContainerType.extend({
  getGrid: function getGrid() {
    return this.get("parent");
  },
  getGridID: function getGridID() {
    return this.get("parent").getGridID();
  },
  initialize: function initialize(spec) {
    var self = this;
    this.setSlots(spec.slots);
    this.set("left_space", this.getSpace("left"));
    this.set("right_space", this.getSpace("right"));
  },
  getSpace: function getSpace(side) {
    if (typeof side === "undefined") side = "left";
    var space = this.get("space_to_" + side);
    if (space == "" || typeof space === "undefined" || space === null) return 0;
    var space_arr = space.split("d");
    return space_arr[0] / space_arr[1];
  },
  getIndex: function getIndex() {
    return this.get("parent").getContainers().indexOf(this);
  },
  setSlots: function setSlots(slots_array) {
    this.getSlots().reset();
    var self = this;
    var slots_dimension = this.getDimension().split("-");
    var i = 0;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(slots_array, function (slot) {
      slot.dimension = slots_dimension[i++];
      self.addSlot(new Slot(slot));
    });
  },
  addSlot: function addSlot(element, index) {
    if (!(element instanceof Slot)) throw "Try to add an not Slot Object: Container.addSlot";
    var args = {};
    if (typeof index === "number") args.at = index;
    element.set("parent", this);
    this.getSlots().add(element, args);
  },
  getSlots: function getSlots() {
    if (!this.get("collection_slots")) {
      this.set("collection_slots", new Slots());
    }

    return this.get("collection_slots");
  },
  getSlot: function getSlot(index) {
    return this.getSlots().at(index);
  },
  // handles all Server communication
  sync: function sync(method, model, options) {
    GridRequest.container[method](model, options);
  }
});
window.Slot = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  getGrid: function getGrid() {
    return this.get("parent").getGrid();
  },
  getGridID: function getGridID() {
    return this.get("parent").getGridID();
  },
  getContainer: function getContainer() {
    return this.get("parent");
  },
  initialize: function initialize(spec) {
    var self = this;
    GRID.log("init Slot");
    GRID.log(spec);

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(spec.boxes, function (box) {
      GRID.log("add Box");
      self.addBox(new Box(box));
    });
  },
  createBox: function createBox(blueprint, index) {
    var self = this;
    var json = blueprint.toJSON();
    json.parent = this;
    var box = new Box(json);
    box.save(null, {
      index: index,
      // response is always undefined, because we are not using backbones ajax call
      success: function success(box, response, options) {
        GRID.log("CreateboxSuccess::");
        GRID.log([box, response, options]);
        self.addBox(box, index);
      },
      error: function error(box, response, options) {
        GRID.log("Createboxrror::");
        GRID.log([box, response, options]);
      }
    });
  },
  addBox: function addBox(element, index) {
    if (!(element instanceof Box)) throw "Try to add an not Box Object: Slot.addBox";
    var args = {};
    if (typeof index === "number") args.at = index;
    element.set("parent", this);
    this.getBoxes().add(element, args);
  },
  getBoxes: function getBoxes() {
    if (!this.get("collection_boxes")) {
      this.set("collection_boxes", new Boxes());
    }

    return this.get("collection_boxes");
  },
  getBox: function getBox(index) {
    return this.getBoxes().at(index);
  },
  sync: function sync(method, model, options) {
    GridRequest.slot[method](model, options);
  }
});
window.Box = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  unsetDuplicated: function unsetDuplicated() {
    this.unset("isDuplicated");
  },
  setDuplicated: function setDuplicated() {
    this.set("isDuplicated", true);
  },
  isDuplicated: function isDuplicated() {
    return this.get("isDuplicated") === true;
  },
  getGrid: function getGrid() {
    return this.get("parent").getGrid();
  },
  getGridID: function getGridID() {
    return this.get("parent").getGridID();
  },
  getSlot: function getSlot() {
    return this.get("parent");
  },
  getContainer: function getContainer() {
    return this.getSlot().getContainer();
  },
  initialize: function initialize(spec) {},
  getIndex: function getIndex() {
    return this.get("parent").getBoxes().indexOf(this);
  },
  duplicate: function duplicate() {
    this.getGrid().duplicateBox(this, this.getIndex() + 1);
  },
  // handles all Server communication
  sync: function sync(method, model, options) {
    GridRequest.box[method](model, options);
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/GridSync.js":
/*!*****************************************!*\
  !*** ./src/grid-editor/lib/GridSync.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/
 // ------------------------------------
// ajax Object
// -----------------------------------

window.GridAjax = function GridAjax(method, params_array, settings) {
  // two required variables
  var json = {};
  json["method"] = method;
  json["params"] = params_array;

  if (_typeof(settings) != "object") {
    settings = {};
  }

  if (typeof settings.checkIsDraft === "undefined") {
    settings.checkIsDraft = true;
  } // default settings


  this.settings = {
    url: GRID.SERVER,
    async: true,
    type: 'POST',
    dataType: 'json',
    contentType: "application/json; charset=utf-8",
    error: function error(jqXHR, textStatus, _error) {
      GRID.finishLoading(); // 			GRID.log("!--- error Method: "+method);
      // GRID.log(jqXHR);
      // GRID.log(textStatus);
      // GRID.log(error);
      // GRID.log(json);
      // GRID.log("--------!");

      if (GRID.DEBUGGING) {
        GRID.log(jqXHR.responseText);
        jQuery(".error-messages").html("Method: " + method + "<br>" + "Status: (" + jqXHR.status + ") -> " + textStatus + "<br>" + "ResponseText: <br><pre>" + jqXHR.responseText + "</pre>").show();
      }

      if (typeof settings.error_fn == 'function') {
        settings.error_fn(jqXHR, textStatus, _error);
      }
    },
    beforeSend: function beforeSend(jqXHR, settings) {
      GRID.startLoading();
    },
    success: function success(data, textStatus, jqXHR) {
      GRID.finishLoading(); // 			GRID.log("!--- success Method: "+method);
      // GRID.log(data);
      // GRID.log(textStatus);
      // GRID.log(jqXHR);
      // GRID.log(json);
      // GRID.log("---------!");

      GRID.log(["AJAX Success", settings]);

      if (typeof settings.success_fn == 'function') {
        settings.success_fn(data, textStatus, jqXHR);
      }

      if (settings.checkIsDraft == true) {
        GRID.getModel().checkIsDraft();
        GRID.revisions.fetch();
      }
    },
    data: JSON.stringify(json),
    wait: false
  }; // overwrite settings

  jQuery.extend(true, this.settings, settings); // sends the request to the server

  this.send = function () {
    jQuery.ajax(this.settings);
  };

  if (!this.settings.wait) {
    this.send();
  }
}; // -------------------
// Method-map that uses the GridAjax object for server communication
// ------------------


window.GridRequest = {
  grid: {
    create: function create(grid, options) {
      GRID.log("Request grid create");
    },
    read: function read(grid, options) {
      GRID.log("Grid->update " + options.action);

      switch (options.action) {
        case "checkdraft":
          // get status draft oder published
          new GridAjax("checkDraftStatus", [grid.getGridID()], {
            success_fn: function success_fn(data) {
              grid.set("isDraft", data.result);
            },
            checkIsDraft: false
          });
          break;

        default:
          // load whole grid
          new GridAjax("loadGrid", [grid.getGridID()], {
            success_fn: function success_fn(data) {
              grid.attributes = underscore__WEBPACK_IMPORTED_MODULE_0__["default"].extend(grid.attributes, data.result);
              grid.getContainers().reset();

              underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result.container, function (container) {
                GRID.log("Add new Container");
                grid.addContainer(new Container(container));
              });

              options.success();

              if (options.reverted) {
                GRID.flash();
              }
            }
          });
      }
    },
    update: function update(grid, options) {
      GRID.log("Grid->update");

      switch (options.action) {
        case "revertDraft":
          new GridAjax("revertDraft", [grid.getGridID()], {
            success_fn: function success_fn(data) {
              GRID.log(["revertDraft success", data]);
              grid.fetch();
            }
          });
          break;

        case "setToRevision":
          var params = [grid.getGridID(), options.revision];
          new GridAjax("setToRevision", params, {
            success_fn: function success_fn(data) {
              GRID.log("setToRevision success");
              GRID.log(data);
              grid.fetch({
                reverted: true
              });
            }
          });
          break;

        default:
          // publish
          new GridAjax("publishDraft", [grid.getGridID()], {
            success_fn: function success_fn(data) {
              GRID.log("publishDraft success");
              GRID.log(data);
              grid.set("isDraft", false);
            }
          });
      }
    },
    moveBox: function moveBox(box, new_slot, new_box_index, success) {
      var params = [box.getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), new_slot.getContainer().get("id"), new_slot.get("id"), new_box_index];
      new GridAjax("moveBox", params, {
        success_fn: success
      });
    },
    addReuseContainer: function addReuseContainer(containertype, index, success) {
      var params = [GRID.ID, index, containertype.get("id")];
      new GridAjax("addReuseContainer", params, {
        success_fn: success
      });
    },
    destroy: function destroy(grid, options) {
      GRID.log("Grid->destroy"); // no need to. CMS creates and deletes grids
    }
  },
  revisions: function revisions(_revisions, options) {
    GRID.log("revisions->read");
    var page = _typeof(options.page) != ( true ? "undefined" : undefined) ? options.page : 0;
    _revisions.nextpage = -1;
    new GridAjax("getGridRevisions", [_revisions.getGridID(), page], {
      success_fn: function success_fn(data) {
        GRID.log("getGridRevisions succes");

        if (data.result.length > 0) {
          _revisions.nextpage = page + 1;
        }

        if (page == 0) {
          _revisions.reset();
        }

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (revision) {
          _revisions.add(new Revision(revision));
        });
      },
      checkIsDraft: false
    });
  },
  // type model calls
  containertypes: function containertypes(_containertypes, options) {
    GRID.log("Containertypes->read");
    new GridAjax("getContainerTypes", [GRID.ID], {
      success_fn: function success_fn(data) {
        GRID.log("getContainerTypes succes");
        GRID.log(data);

        _containertypes.reset();

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (containertype) {
          _containertypes.add(new ContainerType(containertype));
        });
      },
      checkIsDraft: false
    });
  },
  reusablecontainers: function reusablecontainers(collection, options) {
    new GridAjax("getReusableContainers", [GRID.ID], {
      success_fn: function success_fn(data) {
        GRID.log(["reusablecontainers data", data]);

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (container) {
          collection.add(new ContainerType(container));
        });
      },
      checkIsDraft: false
    });
  },
  boxtypes: function boxtypes(_boxtypes, options) {
    GRID.log("Boxtypes->read");
    new GridAjax("getMetaTypesAndSearchCriteria", [GRID.ID], {
      success_fn: function success_fn(data) {
        GRID.log("getMetaTypesAndSearchCriteria succes");
        GRID.log(data);

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (boxtype) {
          _boxtypes.add(new BoxType(boxtype));
        });
      },
      checkIsDraft: false
    });
  },
  boxblueprints: function boxblueprints(_boxblueprints, options) {
    var params = [GRID.ID, options.type, options.searchString, options.criteria];
    GRID.log(["blueprints", _boxblueprints, options, params]);
    new GridAjax("Search", params, {
      success_fn: function success_fn(data) {
        GRID.log(["blueprints search", data]);

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (value, key, list) {
          var blueprint = new GridBoxBlueprint(value);

          _boxblueprints.add(blueprint);
        });
      },
      checkIsDraft: false
    });
  },
  styles: function styles(_styles, options) {
    GRID.log(_styles.type + "Styles->read");
    new GridAjax("get" + _styles.type + "Styles", [], {
      success_fn: function success_fn(data) {
        GRID.log("get" + _styles.type + "Styles succes");
        GRID.log(data);

        _styles.reset();

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (style) {
          _styles.add(new StyleType(style));
        });
      },
      checkIsDraft: false
    });
  },
  rights: function rights(_rights, options) {
    GRID.log("Rights->read");
    new GridAjax("Rights", [], {
      success_fn: function success_fn(data) {
        GRID.log(["rights", data]);

        underscore__WEBPACK_IMPORTED_MODULE_0__["default"].each(data.result, function (value, key, list) {
          _rights.set(value, true);
        }); //rights.setNoRights();


        if (_typeof(options) == _typeof({}) && typeof options.success == "function") {
          options.success(data);
        }
      },
      checkIsDraft: false
    });
  },
  // element model calls
  container: {
    create: function create(container, options) {
      GRID.log("Container->create");
      var params = [container.getGridID(), container.get("type"), options.index];
      GRID.log(params);
      new GridAjax("addContainer", params, {
        success_fn: function success_fn(data) {
          GRID.log("addContainer success");
          GRID.log(data);
          container.set("id", data.result.id);
          container.set("slots", data.result.slots);
          container.set("style", data.result.style);
          container.set("space_to_right", data.result.space_to_right);
          container.set("space_to_left", data.result.space_to_left);
          container.setSlots(data.result.slots);
          options.success();
        }
      });
    },
    read: function read(container, options) {
      GRID.log("Container->read"); // no need to at the moment
    },
    update: function update(container, options) {
      GRID.log("Container->update");

      switch (options.action) {
        case "reuse":
          var params = [container.getGridID(), container.get("id"), options.reusetitle];
          new GridAjax("reuseContainer", params, {
            success_fn: function success_fn(data) {
              container.set("reused", true);
              options.success(data);
            },
            checkIsDraft: false
          });
          break;

        case "move":
          var params = [container.getGridID(), container.get("id"), options.index];
          new GridAjax("moveContainer", params, {
            success_fn: options.success
          });
          break;

        default:
          var attributes = underscore__WEBPACK_IMPORTED_MODULE_0__["default"].clone(container.attributes);

          delete attributes.slots;
          delete attributes.collection_slots;
          delete attributes.classes;
          delete attributes.parent;
          var params = [container.getGridID(), container.get("id"), attributes];
          GRID.log(params);
          new GridAjax("updateContainer", params, {
            success_fn: function success_fn(data) {
              options.success();
            },
            error_fn: options.error
          });
          break;
      }
    },
    "delete": function _delete(container, options) {
      var params = [container.getGridID(), container.get("id")];
      GRID.log(params);
      new GridAjax("deleteContainer", params, {
        success_fn: function success_fn(data) {
          GRID.getModel().getContainers().remove(container);
          options.success();
        }
      });
    }
  },
  slot: {
    create: function create(slot, options) {
      GRID.log("slot->create"); // no need to, because they are hard connected to their container
    },
    read: function read(slot, option) {
      GRID.log("slot->read"); // no need to at the moment
    },
    update: function update(slot, options) {
      GRID.log("slot->update");
      var params = [slot.getGridID(), slot.get("parent").get("id"), slot.get("id"), slot.get("style")];
      GRID.log(params);
      new GridAjax("updateSlotStyle", params, {
        success_fn: function success_fn(data) {
          GRID.log("updateSlotStyle success");
          options.success();
        }
      });
    },
    "delete": function _delete(slot, options) {
      GRID.log("slot->destroy"); // not possible
    }
  },
  box: {
    create: function create(box, options) {
      GRID.log("box->create"); // create a new box

      var params = [box.getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), // index position in slot
      options.index, box.get("type"), box.get("content")];
      new GridAjax("createBox", params, {
        success_fn: function success_fn(data) {
          GRID.log("createBox success");
          GRID.log(data);
          box.set("id", data.result.id);
          options.success();
        }
      });
    },
    read: function read(box, option) {
      GRID.log("box->read");
      var params = [box.getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex()];
      GRID.log(params);
      new GridAjax("fetchBox", params, {
        success_fn: function success_fn(data) {
          GRID.log("fetchBox success");
          GRID.log(data);
          box.attributes = underscore__WEBPACK_IMPORTED_MODULE_0__["default"].extend(box.attributes, data.result);
          box.trigger('change');
        },
        checkIsDraft: false
      });
    },
    update: function update(box, options) {
      GRID.log("box->update " + options.action); // needs a switch for different actions

      switch (options.action) {
        case "reuse":
          var params = [box.getGridID(), box.getSlot().getContainer().get("id"), box.getSlot().get("id"), box.getIndex()];
          GRID.log(params);
          new GridAjax("reuseBox", params, {
            success_fn: function success_fn(data) {
              box.attributes = data.result;
              box.trigger('change');
            },
            checkIsDraft: false
          });
          break;

        case "move":
          // for moving the box from one to another position
          break;

        default:
          //update attributes
          var attributes = underscore__WEBPACK_IMPORTED_MODULE_0__["default"].clone(box.attributes);

          GRID.log("attributes");
          GRID.log(attributes);
          delete attributes.classes;
          delete attributes.contentstructure;
          delete attributes.parent;
          var params = [box.getGridID(), box.getSlot().getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), attributes];
          GRID.log(params);
          new GridAjax("UpdateBox", params, {
            success_fn: function success_fn(data) {
              GRID.log("UpdateBox success");
              GRID.log(data);
              options.success();
              box.fetch();
            }
          });
      }
    },
    "delete": function _delete(box, options) {
      GRID.log("box->destroy");
      var params = [box.getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex()];
      GRID.log(params);
      new GridAjax("removeBox", params, {
        success_fn: function success_fn(data) {
          GRID.log("removeBox success");
          GRID.log(data);
          options.success();
        }
      });
    }
  }
};

/***/ }),

/***/ "./src/grid-editor/lib/GridViews.js":
/*!******************************************!*\
  !*** ./src/grid-editor/lib/GridViews.js ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_2__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/



window.GridView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: 'div',
  className: 'grid-wrapper',
  initialize: function initialize() {
    this._containersView = new ContainersView({
      collection: this.model.getContainers()
    });
  },
  render: function render() {
    this.$el.empty();
    this.$el.append(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_grid(this.model.toJSON()));
    this.renderContainers();
    return this;
  },
  renderContainers: function renderContainers() {
    this.$el.find(".containers-wrapper").replaceWith(this._containersView.render().el);
    return this;
  }
});
window.ContainersView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: 'div',
  className: 'grid-containers-wrapper containers-wrapper',
  initialize: function initialize() {
    this.listenTo(this.collection, 'add', this.render);
    this.listenTo(this.collection, 'remove', this.render);
  },
  render: function render() {
    var self = this;
    this.$el.empty();
    this.collection.each(function (container) {
      var containerview = new ContainerView({
        model: container
      });
      self.$el.append(containerview.render().el);
    });

    GRID._initializeBoxSortable();

    return this;
  }
});
window.ContainerView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: 'grid-container',
  events: {
    "click [role=trash]": "selfdestruct",
    "click [role=edit]": "onEdit",
    "click [role=reuse]": "onReuse",
    "click [role=toggleslotstyles]": "onToggleSlotStyles"
  },
  initialize: function initialize() {
    var self = this;
    var listen_to = ["title", "titleurl", "prolog", "epilog", "readmore", "readmoreurl", "style", "style_label"];

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(listen_to, function (value, key, list) {
      self.listenTo(self.model, 'change:' + value, self.render);
    });

    this._slotsView = new SlotsView({
      collection: this.model.getSlots()
    });
  },
  render: function render() {
    var json = this.model.toJSON();
    this.$el.attr("data-id", json.id).attr("data-type", json.type).attr("data-style", json.style).attr("data-reused", json.reused).attr("data-cid", this.model.cid).attr("data-space-left", this.model.getSpace("left")).attr("data-space-right", this.model.getSpace("right"));
    this.$el.addClass('grid-container-type-' + this.model.getType());
    this.$el.addClass('grid-container-' + json.type);
    this.$el.addClass('grid-container-left-space-' + json.space_to_left);
    this.$el.addClass('grid-container-right-space-' + json.space_to_right); // shorten title, prolog and epilog

    var cut = 60;

    if (json.title) {
      json.title_short = json.title.length <= cut ? json.title : json.title.substring(0, cut) + "&hellip;";
    }

    if (json.prolog) {
      var prolog = jQuery("<div>" + json.prolog + "</div>").text();
      json.prolog_short = "<p>" + (prolog.length <= cut ? prolog : prolog.substring(0, cut) + "&hellip;") + "</p>";
    }

    if (json.epilog) {
      var epilog = jQuery("<div>" + json.epilog + "</div>").text();
      json.epilog_short = "<p>" + (epilog.length <= cut ? epilog : epilog.substring(0, cut) + "&hellip;") + "</p>";
    }

    json.right_edit = GRID.getRights().get("edit-container");
    json.right_delete = GRID.getRights().get("delete-container");
    json.right_options = true;

    if (!json.right_delete && (!json.right_edit || json.reused)) {
      json.right_options = false;
    }

    json.right_move = GRID.getRights().get("move-container");
    json.isSidebar = json.type.startsWith("s");
    this.$el.empty();
    this.$el.append(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_container(json));
    this.$slots_wrapper = this.$el.find(".grid-slots-wrapper");
    this.$slots_wrapper.replaceWith(this._slotsView.render().el);
    return this;
  },
  onEdit: function onEdit() {
    var editor = new GridContainerEditor({
      model: this.model
    });
    GRID.showEditor(function () {
      GRID.$root_editor.html(editor.render().el);
    });
  },
  saveEditor: function saveEditor() {
    var self = this;
    console.debug("ContainerView saveEditor", self);
    jQuery.each(this.$el.find(".form-val"), function (index, element) {
      var $this = jQuery(element);
      var scope = $this.attr("scope");
      self.model.set(scope, $this.val());
    });
    this.model.save();
    return this.render();
  },
  onReuse: function onReuse() {
    var reusetitle = prompt("Bitte gib einen Titel für den Container ein");

    if (reusetitle == "" || reusetitle == false || reusetitle == null) {
      return false;
    }

    var self = this;
    this.model.save(null, {
      reusetitle: reusetitle,
      action: "reuse",
      success: function success(data) {
        self.render();
      }
    });
    return this;
  },
  onToggleSlotStyles: function onToggleSlotStyles() {
    this.$el.toggleClass('grid-container-show-slot-styles');
  },
  selfdestruct: function selfdestruct() {
    this.model.destroy({
      wait: true
    });
    this.remove();
  }
});
window.SlotsView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: 'div',
  className: 'grid-slots-wrapper slots-wrapper',
  initialize: function initialize() {
    this.collection.bind('add', this.render, this);
    this.collection.bind('remove', this.render, this);
  },
  render: function render() {
    var self = this;
    this.$el.empty();
    this.collection.each(function (slot) {
      var slotview = new SlotView({
        model: slot
      });
      slotview._parentView = self;
      self.$el.append(slotview.render().el);
    });
    return this;
  }
});
window.SlotView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: 'div',
  className: 'grid-slot',
  initialize: function initialize() {
    this._boxesView = new BoxesView({
      collection: this.model.getBoxes()
    });

    if (GRID.mode != "box") {
      this._slotStyleChangerView = new GridSlotStyleChangerView({
        model: this.model
      });
    }

    this.listenTo(this.model, 'change', this.render);
  },
  render: function render() {
    var json = this.model.toJSON();
    this.$el.attr("data-style", json.style).attr("data-id", json.id).attr("data-dimension", json.dimension);
    this.$el.addClass('grid-slot-' + json.dimension);
    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_slot(this.model.toJSON()));

    if (GRID.mode != "box") {
      this.$el.find(".style-changer").replaceWith(this._slotStyleChangerView.render().el);

      this._slotStyleChangerView.delegateEvents();
    }

    this._boxesView.render();

    this.$el.find(".boxes-wrapper").replaceWith(this._boxesView.$el);
    return this;
  }
});
window.BoxesView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: 'div',
  className: 'grid-boxes-wrapper boxes-wrapper',
  initialize: function initialize() {
    this.collection.bind('add', this.render, this);
  },
  render: function render() {
    var self = this;
    this.$el.empty();
    this.collection.each(function (box) {
      var boxview = new BoxView({
        model: box
      });
      boxview._parentView = self;
      self.$el.append(boxview.render().el);
    });
    return this;
  }
});
window.BoxView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-box box",
  events: {
    'click .grid-box-edit': 'edit',
    'click .grid-box-delete': 'deleteBox',
    'click .grid-box-duplicate': 'duplicateBox'
  },
  initialize: function initialize() {
    this.listenTo(this.model, 'change', this.render);
    this.listenTo(this.model, 'destroy', this.selfdestruct);
  },
  render: function render() {
    var json = this.model.toJSON();
    this.$el.attr("data-id", json.id).attr("data-type", json.type).attr("data-style", json.style);
    this.$el.addClass("grid-box-" + json.type);

    if (json.type == "reference") {
      json.reference = true;
    }

    json.right_move = GRID.getRights().get("move-box");
    json.right_edit = GRID.getRights().get("edit-box");
    json.right_create = GRID.getRights().get("create-box");
    json.right_delete = GRID.getRights().get("delete-box");
    json.right_none = false;

    if (!(json.right_move || json.right_edit || json.right_delete)) {
      json.right_none = true;
    }

    GRID.log(["render box", json]);
    var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

    while (SCRIPT_REGEX.test(json.html)) {
      json.html = json.html.replace(SCRIPT_REGEX, "");
    }

    while (SCRIPT_REGEX.test(json.epilog)) {
      json.epilog = json.epilog.replace(SCRIPT_REGEX, "");
    }

    while (SCRIPT_REGEX.test(json.prolog)) {
      json.prolog = json.prolog.replace(SCRIPT_REGEX, "");
    }

    if (this.model.isDuplicated()) {
      this.model.unsetDuplicated();
      this.$el.addClass("is-duplicated");
    }

    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_box(json));
    return this;
  },
  edit: function edit() {
    var editor = new BoxEditor({
      model: this.model
    });
    GRID.showEditor(function () {
      GRID.$root_editor.html(editor.render().el);
    });
  },
  deleteBox: function deleteBox() {
    this.model.destroy();
  },
  duplicateBox: function duplicateBox() {
    this.model.duplicate();
  },
  selfdestruct: function selfdestruct() {
    this.remove();
  }
});
window.BoxEditor = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  events: {
    'click .btn-cancel': 'onCancel',
    'click .grid-editor-legend': 'onToggle',
    'click .btn-save': 'onSave',
    'click .btn-make-reusable': 'onMakeReusable'
  },
  initialize: function initialize() {},
  render: function render() {
    GRID.log(this.model.toJSON());
    var styles = GRID.getBoxStyles().toJSON();
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(styles, function (elem) {
      if (elem.slug == self.model.get("style")) elem.selected = "selected";else elem.selected = "";
    });

    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_boxeditor({
      'lang_values': document.lang_values,
      'box': this.model.toJSON(),
      'b_index': this.model.getIndex(),
      'c_id': this.model.getContainer().get("id"),
      's_id': this.model.getSlot().get("id"),
      'styles': styles
    }));
    var contentstructure = this.model.get("contentstructure");
    var fieldcontainer = jQuery(this.$el).find(".dynamic-fields .field-wrapper");
    var views = [];
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(contentstructure, function (elem) {
      var type = elem.type;
      var view = new boxEditorControls[type]({
        model: {
          structure: elem,
          container: self.model.get("content"),
          box: self.model,
          parentpath: ""
        }
      });
      views.push(view);
      fieldcontainer.append(view.render().el);
    });

    this.views = views;
    jQuery.each(jQuery(this.$el).find(".form-html"), function (index, element) {
      CKEDITOR.replace(element, {
        customConfig: document.PathToConfig
      });
    });

    if (GRID.getBoxStyles().length < 1) {
      jQuery(this.$el).find(".box-styles-wrapper").hide();
    }

    return this;
  },
  onCancel: function onCancel() {
    GRID.hideBoxEditor(function () {
      jQuery("div#new-grid-boxeditor").html("");
    });
  },
  onToggle: function onToggle(e) {
    jQuery(e.target).siblings(".field-wrapper").slideToggle(300);
  },
  onMakeReusable: function onMakeReusable(e) {
    if (!confirm(document.lang_values["confirm-box-reuse"])) return;
    this.model.save(null, {
      action: "reuse"
    });
    GRID.hideBoxEditor(function () {
      jQuery("div#new-grid-boxeditor").html("");
    });
  },
  onSave: function onSave(e) {
    var obj = {};

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.views, function (view) {
      obj[view.model.structure.key] = view.fetchValue();
    });

    this.model.set('content', obj);
    this.model.set('title', jQuery(this.$el).find(".f-b-title").val());
    this.model.set('titleurl', jQuery(this.$el).find(".f-b-titleurl").val());
    this.model.set('prolog', CKEDITOR.instances["f-b-prolog"].getData());
    this.model.set('epilog', CKEDITOR.instances['f-b-epilog'].getData());
    this.model.set('readmore', jQuery(this.$el).find('.f-b-readmore').val());
    this.model.set('readmoreurl', jQuery(this.$el).find('.f-b-readmoreurl').val());
    this.model.set('style', jQuery(this.$el).find(".box-styles-wrapper select").val());
    this.model.save();
    GRID.hideBoxEditor(function () {
      jQuery("div#new-grid-boxeditor").html("");
    });
  }
});
window.boxEditorControls = {};

/***/ }),

/***/ "./src/grid-editor/lib/collections/GridAuthors.js":
/*!********************************************************!*\
  !*** ./src/grid-editor/lib/collections/GridAuthors.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.GridAuthors = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: GridAuthor,
  async_authors_list: function async_authors_list(data) {
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(data, function (item) {
      self.add({
        id: item.identifier,
        name: item.author
      });
    });
  },
  resetLock: function resetLock() {
    this.each(function (author) {
      author.set("has_lock", false);
    });
  },
  setLock: function setLock(id) {
    this.get(id).set("has_lock", true);
  },
  haveLock: function haveLock() {
    return typeof this.findWhere({
      has_lock: true
    }) === "undefined";
  },
  getCount: function getCount() {
    // +1 is us self
    return this.length + 1;
  },
  async_authors_joined: function async_authors_joined(data) {
    this.add({
      id: data.identifier,
      name: data.author
    });
  },
  async_authors_left: function async_authors_left(data) {
    this.remove(this.get(data));
  },
  async_disconnect: function async_disconnect() {
    this.reset();
    this.resetLock();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/collections/GridBoxBlueprints.js":
/*!**************************************************************!*\
  !*** ./src/grid-editor/lib/collections/GridBoxBlueprints.js ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

window.GridBoxBlueprints = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Collection.extend({
  model: GridBoxBlueprint,
  initialize: function initialize(spec) {},
  sync: function sync(method, collection, options) {
    GridRequest.boxblueprints(collection, options);
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/models/GridAuthor.js":
/*!**************************************************!*\
  !*** ./src/grid-editor/lib/models/GridAuthor.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

window.GridAuthor = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  defaults: function defaults() {
    return {
      has_lock: false,
      request_lock: false
    };
  },
  initialize: function initialize(spec) {
    if (!spec) throw "No parameters in constructor of author";
    if (!spec.id) throw "InvalidConstructArgs GridAuthor needs id";
    if (!spec.name) throw "InvalidConstructArgs GridAuthor needs name";
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/models/GridBoxBlueprint.js":
/*!********************************************************!*\
  !*** ./src/grid-editor/lib/models/GridBoxBlueprint.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

window.GridBoxBlueprint = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  initialize: function initialize(spec) {
    if (!spec || !spec.type || spec.type == "") throw "InvalidConstructArgs GridBoxBlueprint: needs type";
    if (!spec.content || _typeof(spec.content) != "object") throw "InvalidConstructArgs GridBoxBlueprint: needs content";
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/models/GridRights.js":
/*!**************************************************!*\
  !*** ./src/grid-editor/lib/models/GridRights.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.GridRights = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.Model.extend({
  initialize: function initialize(spec) {},
  setNoRights: function setNoRights() {
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.attributes, function (value, key, list) {
      self.set(key, false);
    });
  },
  logRights: function logRights() {
    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.attributes, function (value, key, list) {
      GRID.log(key + " " + value);
    });
  },
  sync: function sync(method, model, options) {
    GridRequest.rights(model, options);
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/utils.js":
/*!**************************************!*\
  !*** ./src/grid-editor/lib/utils.js ***!
  \**************************************/
/*! exports provided: hasHTMLEditor, getHTMLEditor, initHTMLEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasHTMLEditor", function() { return hasHTMLEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHTMLEditor", function() { return getHTMLEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initHTMLEditor", function() { return initHTMLEditor; });
var hasHTMLEditor = function hasHTMLEditor(element) {
  return getHTMLEditor(element);
};
var getHTMLEditor = function getHTMLEditor(element) {
  return jQuery(element).data("ckeditor");
};
var initHTMLEditor = function initHTMLEditor(element) {
  return new Promise(function (resolve, reject) {
    if (hasHTMLEditor(element)) {
      resolve(getHTMLEditor(element));
      return;
    } // from CDN in /templates/editor/grid.tpl


    resolve(CKEDITOR.replace(element, {
      customConfig: document.PathToConfig
    }));
  });
};

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/autocomplete.js":
/*!*****************************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/autocomplete.js ***!
  \*****************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


boxEditorControls['autocomplete'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-autocomplete",
  events: {
    "keyup .i-autocomplete": "keyup",
    "click .suggestion-list li": "listItemSelected",
    "click .cancel": "cancelSelection"
  },
  initialize: function initialize() {},
  render: function render() {
    var html = "<label>" + this.model.structure.label + "</label>";
    var classes = "autocomplete-wrapper form-autocomplete dynamic-value";
    var readonly = "";
    var fetch = false;
    var key_value = this.model.container[this.model.structure.key];

    if (_typeof(key_value) !== ( true ? "undefined" : undefined) && key_value !== '') {
      classes += " locked";
      readonly = "readonly=readonly";
      fetch = true;
    }

    html += "<div class='" + classes + "'><input type=text class='form-text autocomplete i-autocomplete' " + readonly + "/>";
    html += "<div class='loading'></div>";
    html += "<div class='cancel icon-cancel'></div>";
    html += "<ul class='suggestion-list'></ul>";
    this.$el.html(html);

    if (fetch) {
      this.$el.find(".loading").addClass("go");
      this.$el.find("input.i-autocomplete").data("key", key_value);
      var box = this.model.box;
      var self = this;
      new GridAjax("typeAheadGetText", [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), this.model.parentpath + this.model.structure.key, key_value], {
        success_fn: function success_fn(data) {
          self.$el.find(".loading").removeClass("go");
          self.$el.find("input.i-autocomplete").val(data.result);
        }
      });
    }

    return this;
  },
  fetchValue: function fetchValue() {
    return this.$el.find("input.i-autocomplete").data("key");
  },
  keyup: function keyup(e) {
    if (e.which == 13) {
      this.selectItem(this.$el.find(".suggestion-list li").first());
    } else {
      var search = this.$el.find("input.i-autocomplete").val();
      this.$el.find(".loading").addClass("go");
      clearTimeout(this.searching);
      var self = this;
      this.searching = setTimeout(function () {
        self.doSearch(search);
      }, 1000);
    }
  },
  doSearch: function doSearch(search) {
    var self = this;
    var box = this.model.box;
    new GridAjax("typeAheadSearch", [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), this.model.parentpath + this.model.structure.key, search], {
      success_fn: function success_fn(data) {
        self.$el.find(".suggestion-list").empty();

        underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(data.result, function (elem) {
          self.$el.find(".suggestion-list").append(jQuery("<li/>").text(elem.value).attr("data-key", elem.key));
        });

        self.$el.find(".loading").removeClass("go");
      }
    });
  },
  selectItem: function selectItem($item) {
    var key_value = $item.data("key");
    var name = $item.text();
    this.$el.find(".autocomplete-wrapper").addClass("locked");
    this.$el.find("input.i-autocomplete").val(name).attr("readonly", "readonly").data("key", key_value);
    this.$el.find(".suggestion-list").empty();
  },
  listItemSelected: function listItemSelected(e) {
    this.selectItem(jQuery(e.target));
  },
  cancelSelection: function cancelSelection(e) {
    this.$el.find(".autocomplete-wrapper").removeClass("locked");
    this.$el.find("input.i-autocomplete").data("key", "").removeAttr("readonly").val("");
    this.old_search_string = "";
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/autocomplete_with_links.js":
/*!****************************************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/autocomplete_with_links.js ***!
  \****************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


boxEditorControls['autocomplete-with-links'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-autocomplete-with-links",
  events: {
    "keyup .i-autocomplete": "keyup",
    "click .suggestion-list li": "listItemSelected",
    "click .cancel": "cancelSelection"
  },
  initialize: function initialize() {},
  render: function render() {
    var html = "<label>" + this.model.structure.label + "</label>";
    var classes = "autocomplete-wrapper form-autocomplete dynamic-value";
    var readonly = "";
    var fetch = false;
    var key_value = this.model.container[this.model.structure.key];

    if (_typeof(key_value) !== ( true ? "undefined" : undefined) && key_value !== '') {
      classes += " locked";
      readonly = "readonly";
      fetch = true;
    }

    html += "<div class='" + classes + "'>";
    html += "<input type=text class='form-text autocomplete i-autocomplete' " + readonly + "/>";
    html += "<div class='cancel'><span class='icon-cancel'></span></div>";
    html += "<ul class='suggestion-list'></ul>";
    html += '<p class="links">';
    html += '<a class="empty" data-raw="' + this.model.structure.emptyurl + '" href="' + this.model.structure.emptyurl + '" target="_blank">' + this.model.structure.emptylinktext + '</a>';
    html += '<a class="full" data-raw="' + this.model.structure.url + '" href="" target="_blank">' + this.model.structure.linktext + '</a>';
    html += '</p>';
    html += "</div>";
    jQuery(this.$el).html(html);

    if (fetch) {
      this.$el.find("input.i-autocomplete").data("key", key_value);
      var box = this.model.box;
      var self = this;
      new GridAjax("typeAheadGetText", [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), this.model.parentpath + this.model.structure.key, key_value], {
        success_fn: function success_fn(data) {
          self.$el.find("input.i-autocomplete").val(data.result);
        }
      });
      var $linkUrl = this.$el.find("a.full");
      $linkUrl.attr('href', $linkUrl.data('raw').replace('%', key_value));
    }

    return this;
  },
  fetchValue: function fetchValue() {
    return this.$el.find("input.i-autocomplete").data("key");
  },
  keyup: function keyup(e) {
    var $input = this.$el.find("input.i-autocomplete");
    if (typeof $input.attr('readonly') !== 'undefined' || $input.attr('readonly') === false) return;

    if (e.which === 13) {
      this.selectItem(this.$el.find(".suggestion-list li").first());
    } else {
      var search = this.$el.find("input.i-autocomplete").val();
      if (search == this.old_search_string) return;
      var self = this;
      this.$el.find(".loading").show();
      clearTimeout(this.searching);
      this.searching = setTimeout(function () {
        self.doSearch(search);
      }, 1000);
    }
  },
  doSearch: function doSearch(search) {
    var self = this;
    var box = this.model.box;
    new GridAjax("typeAheadSearch", [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), this.model.parentpath + this.model.structure.key, search], {
      success_fn: function success_fn(data) {
        self.old_search_string = search;
        self.$el.find(".suggestion-list").empty();

        underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(data.result, function (elem) {
          self.$el.find(".suggestion-list").append(jQuery("<li/>").text(elem.value).attr("data-key", elem.key));
        });

        self.$el.find(".loading").hide();
      }
    });
  },
  selectItem: function selectItem($item) {
    var key_value = $item.data("key");
    var name = $item.text();
    this.$el.find(".autocomplete-wrapper").addClass("locked");
    this.$el.find("input.i-autocomplete").val(name).attr("readonly", "readonly").data("key", key_value);
    this.$el.find(".suggestion-list").empty();
    var $linkUrl = this.$el.find("a.full");
    $linkUrl.attr('href', $linkUrl.data('raw').replace('%', key_value));
  },
  listItemSelected: function listItemSelected(e) {
    this.selectItem(jQuery(e.target));
  },
  cancelSelection: function cancelSelection(e) {
    this.$el.find(".autocomplete-wrapper").removeClass("locked");
    this.$el.find("input.i-autocomplete").data("key", "").removeAttr("readonly").val("");
    this.old_search_string = "";
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/checkbox.js":
/*!*************************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/checkbox.js ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['checkbox'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-checkbox",
  render: function render() {
    var value = this.model.container[this.model.structure.key];
    var checked = value ? 'checked=checked' : '';
    var html = "<label><input type='checkbox' " + checked + " /> " + this.model.structure.label + "</label>";
    this.$el.html(html);
    return this;
  },
  fetchValue: function fetchValue() {
    return this.$el.find("input[type=checkbox]").is(":checked");
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/file.js":
/*!*********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/file.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['file'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-file",
  initialize: function initialize() {},
  render: function render() {
    var $ = jQuery;
    var val = this.model.container[this.model.structure.key];
    var $upload_form_item = jQuery("<div class='form-item file-upload'>");
    $upload_form_item.append("<label>" + this.model.structure.label + "</label>");
    this.$preview = jQuery("<div></div>").addClass("file-upload-preview");
    $upload_form_item.append(this.$preview);
    var $file_input = jQuery("<input type='file' data-path='" + this.model.parentpath + this.model.structure.key + "' class='form-file' />");
    $upload_form_item.append($file_input);
    var fid = this.model.container[this.model.structure.key];
    this.$key_field = jQuery("<input type='hidden' data-key='" + this.model.structure.key + "' " + "value='" + (_typeof(fid) !== ( true ? "undefined" : undefined) ? fid : '') + "' class='dynamic-value' />");
    $upload_form_item.append(this.$key_field);
    this.$progress_display = jQuery("<p>").addClass("progress");
    this.$progress_bar_wrapper = jQuery("<div class='progress-bar-wrapper'><div class='bar'></div>");
    this.$progress_bar_status = this.$progress_bar_wrapper.children(".bar");

    if (this.model.container[this.model.structure.key] === "" || this.model.container[this.model.structure.key] === undefined) {
      this.$progress_display.text(this.getFileChooseHelp());
    } else {
      this.$progress_display.text(this.getFileReplaceHelp());
      this.$progress_bar_status.addClass("done");
    }

    $upload_form_item.append(this.$progress_display).append(this.$progress_bar_wrapper);
    var self = this;
    $file_input.fileupload({
      url: this.model.structure.uploadpath,
      dataType: 'json',
      paramName: "file",
      done: function done(e, data) {
        self.uploadDone(e, data);
        self.loadPreview();
      },
      progressall: function progressall(e, data) {
        self.progressall(e, data);
      },
      always: function always(e, data) {
        GRID.log(e, data);
      }
    }).bind('fileuploadsubmit', {
      self: self
    }, this.getFormData);
    this.$el.append($upload_form_item);
    this.loadPreview();
    return this;
  },
  loadPreview: function loadPreview() {
    this.$preview.empty();
    var fileid = this.$key_field.val();
    var path = this.model.parentpath + this.model.structure.key;
    if (_typeof(fileid) === ( true ? "undefined" : undefined) || fileid === "") return;
    var self = this;
    var box = this.model.box;
    var params = [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), path, fileid];
    new GridAjax("getFileInfo", params, {
      success_fn: function success_fn(data) {
        self.$preview.append(jQuery("<img>").css('max-width', '200px').attr("src", data.result.src));
      }
    });
  },
  getFormData: function getFormData(e, data) {
    var self = e.data.self;
    var element_key = self.model.parentpath + self.model.structure.key;
    var box = self.model.box;
    data.formData = {
      gridid: GRID.ID,
      container: box.getContainer().get("id"),
      slot: box.getSlot().get("id"),
      box: box.getIndex(),
      key: element_key
    };
    self.$progress_bar_status.removeClass("done");
  },
  progressall: function progressall(e, data) {
    var percent = data.loaded / data.total * 100;
    this.$progress_display.text(Math.round(percent) + "%");
    this.$progress_bar_status.css("width", percent + "%");
  },
  uploadDone: function uploadDone(e, data) {
    var result = data.result;
    this.$key_field.val(result.result);
    this.$progress_display.text("OK!");
    this.$progress_bar_status.addClass("done");
  },
  fetchValue: function fetchValue() {
    return this.$key_field.val();
  },
  getFileReplaceHelp: function getFileReplaceHelp() {
    var text;

    if (typeof this.model.structure.fileReplacementHelp !== 'undefined') {
      text = this.model.structure.fileReplacementHelp;
    } else {
      text = "Choose another picture to override the old one.";
    }

    return text;
  },
  getFileChooseHelp: function getFileChooseHelp() {
    var text;

    if (typeof this.model.structure.fileChooseHelp !== 'undefined') {
      text = this.model.structure.fileChooseHelp;
    } else {
      text = "Please choose a picture...";
    }

    return text;
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/hidden.js":
/*!***********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/hidden.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['hidden'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-hidden",
  initialize: function initialize() {},
  render: function render() {
    return this;
  },
  fetchValue: function fetchValue() {
    return this.model.container[this.model.structure.key];
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/html.js":
/*!*********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/html.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/grid-editor/lib/utils.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


boxEditorControls['html'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-html",
  render: function render() {
    var _this = this;

    var text = this.model.container[this.model.structure.key] || "";
    this.$el.html("<label>" + this.model.structure.label + "</label>" + "<textarea name='" + this.cid + "' class='dynamic-value form-html'>" + text.replace(/\'/g, "&#39;") + "</textarea>");
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["initHTMLEditor"])(this.el.querySelector(".form-html")).then(function (editor) {
      _this.editor = editor;
    });
    return this;
  },
  fetchValue: function fetchValue() {
    return this.editor.getData();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/info.js":
/*!*********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/info.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['info'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-info",
  initialize: function initialize() {},
  render: function render() {
    if (null != this.model.structure.label) {
      jQuery(this.el).html("<label>" + this.model.structure.label + "</label><p class='info'>" + this.model.structure.text + "</p>");
    } else {
      jQuery(this.el).html("<p class='info'>" + this.model.structure.text + "</p>");
    }

    return this;
  },
  fetchValue: function fetchValue() {
    return {};
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/input.js":
/*!**********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/input.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['input'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-input",
  initialize: function initialize() {},
  render: function render() {
    this.$el.empty();
    var val = this.model.container[this.model.structure.key];
    this.$el.append(jQuery("<label />").text(this.model.structure.label));
    this.$el.append(jQuery("<input />").addClass("dynamic-value").attr("type", this.model.structure.inputType).val(_typeof(val) === ( true ? "undefined" : undefined) ? "" : val));
    this.$el.addClass("grid-editor-widget-input__" + this.model.structure.inputType);
    return this;
  },
  fetchValue: function fetchValue() {
    return jQuery(this.$el).find("input").val();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/list.js":
/*!*********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/list.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


boxEditorControls['list'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-list",
  initialize: function initialize() {},
  render: function render() {
    this.$el.empty();
    jQuery("<label></label>").text(this.model.structure.label).appendTo(this.$el);
    this.$list = jQuery("<div></div>").addClass('grid-editor-widget-list-items');
    this.$el.append(this.$list);
    var list = this.model.container[this.model.structure.key];
    var self = this;
    var views = [];
    jQuery("<button><span class='icon-plus'></span>Add item</button>").addClass('grid-editor-widget-list-add').appendTo(this.$el).on('click', function (event) {
      event.preventDefault();
      self.onAdd();
    });

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(list, function (elem) {
      var view = new boxEditorControls['listitem']({
        model: {
          structure: self.model.structure.contentstructure,
          container: elem,
          box: self.model.box,
          parentpath: self.model.parentpath + self.model.structure.key + "."
        }
      });
      views.push(view);
      self.$list.append(view.render().$el);
    });

    this.views = views;
    this.$list.on("click", ".widget-list-sort-button", {
      self: this
    }, this.sortItem);
    this.$list.on("click", ".widget-list-remove-item-button", {
      self: this
    }, this.onRemove);
    return this;
  },
  sortItem: function sortItem(e) {
    var self = e.data.self;
    var $button = jQuery(e.currentTarget);
    var $this = $button.closest(".grid-editor-widget-listitem");
    var index = $this.index();
    var views = self.views;
    var view = views[index];
    var newPos = index;

    switch ($button.attr("data-dir")) {
      case "up":
        newPos = index - 1;
        if (newPos < 0) newPos = 0;
        $this.insertBefore($this.prev());
        break;

      case "down":
        newPos = index + 1;
        $this.insertAfter($this.next());
        break;
    }

    views.splice(index, 1);
    views.splice(newPos, 0, view);
  },
  onRemove: function onRemove(e) {
    var self = e.data.self;
    var index = jQuery(e.currentTarget).closest(".grid-editor-widget-listitem").index();
    var list = self.model.container[self.model.structure.key];
    list.splice(index, 1);
    self.views[index].removed = true;
    self.views[index].remove();
    self.views.splice(index, 1);
    console.log(["remove", e, self]);
  },
  onAdd: function onAdd() {
    var view = new boxEditorControls['listitem']({
      model: {
        structure: this.model.structure.contentstructure,
        container: {},
        box: this.model.box,
        parentpath: this.model.parentpath + this.model.structure.key + "."
      }
    });
    this.views.push(view);
    this.$list.append(view.render().el); // jQuery.each(view.$el.find(".form-html"), function(index, element) {
    //     CKEDITOR.replace(
    //         element,{
    //         customConfig : document.PathToConfig
    //     });
    // });
  },
  fetchValue: function fetchValue() {
    var content = [];

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.views, function (view) {
      if (view.removed) return;
      content.push(view.fetchValue());
    });

    return content;
  }
});
boxEditorControls['listitem'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget-listitem",
  removed: false,
  initialize: function initialize() {},
  render: function render() {
    var views = [];
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.model.structure, function (elem) {
      var type = elem.type;
      var view = new boxEditorControls[type]({
        model: {
          structure: elem,
          container: self.model.container,
          box: self.model.box,
          parentpath: self.model.parentpath
        }
      });
      views.push(view);
      self.$el.append(view.render().el);
    });

    jQuery("<button class='widget-list-remove-item-button'><span class='icon-minus'></span>Remove item</button>").appendTo(this.$el);
    jQuery("<button class='widget-list-move-up-item-button widget-list-sort-button' data-dir='up'><span class='icon-dir-up'></span></button>").appendTo(this.$el);
    jQuery("<button class='widget-list-move-down-item-button widget-list-sort-button' data-dir='down'><span class='icon-dir-down'></span></button>").appendTo(this.$el);
    this.views = views;
    return this;
  },
  fetchValue: function fetchValue() {
    var obj = {};

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.views, function (view) {
      obj[view.model.structure.key] = view.fetchValue();
    });

    return obj;
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/multi-autocomplete.js":
/*!***********************************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/multi-autocomplete.js ***!
  \***********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


boxEditorControls['multi-autocomplete'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-multi-autocomplete",
  events: {
    "keyup .i-autocomplete": "keyup",
    "click .suggestion-list li": "listItemSelected"
  },
  initialize: function initialize() {},
  render: function render() {
    var html = "<label>" + this.model.structure.label + "</label>";
    var classes = "autocomplete-wrapper form-autocomplete dynamic-value";
    var fetch = false;

    if (this.model.container[this.model.structure.key] != '' || this.model.container[this.model.structure.key] === 0) {
      fetch = true;
    }

    html += "<div class='" + classes + "'><input type=text class='form-text autocomplete i-autocomplete' />";
    html += "<div class='loading'></div>";
    html += "<ul class='suggestion-list'></ul>";
    this.$el.html(html);
    this.$el.on("click", ".icon-cancel", function (e) {
      var item = jQuery(this).parent();
      item.empty();
      item.remove();
    });

    if (fetch) {
      var self = this;
      var box = this.model.box;
      var content = this.model.container[this.model.structure.key];

      if (_typeof(content) === ( true ? "undefined" : undefined)) {
        content = [];
      } else if (_typeof(content) !== _typeof([])) {
        // legacy: before multi autoselect support
        content = [content];
      }

      jQuery.each(content, function (index, key) {
        self.$el.find(".loading").addClass("go");
        new GridAjax("typeAheadGetText", [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), self.model.parentpath + self.model.structure.key, key], {
          success_fn: function success_fn(data) {
            self.$el.find(".loading").removeClass("go");
            self.$el.find(".autocomplete-wrapper").append("<div class='autocomplete-multiselect-item' data-key='" + key + "'>" + "<span>" + data.result + "</span>" + "<span class='icon icon-cancel'></span>" + "</div>");
          }
        });
      });
    }

    return this;
  },
  fetchValue: function fetchValue() {
    var result = [];
    this.$el.find(".autocomplete-multiselect-item").each(function (index, element) {
      result.push(jQuery(element).data("key"));
    });
    return result;
  },
  keyup: function keyup(e) {
    if (e.which == 13) {
      this.selectItem(this.$el.find(".suggestion-list li").first());
    } else {
      var self = this;
      var search = this.$el.find("input.i-autocomplete").val();
      /**
       * dont execute same query twice
       */

      if (this.$el.find("input.i-autocomplete").val() == this.old_search_string) return;
      self.old_search_string = search;
      /**
       * animate loading
       */

      this.$el.find(".loading").addClass("go");
      /**
       * start search timeout
       */

      clearTimeout(this.searching);
      this.searching = setTimeout(function () {
        self.doSearch(search);
      }, 1000);
    }
  },
  doSearch: function doSearch(search) {
    var self = this;
    var box = this.model.box;
    new GridAjax("typeAheadSearch", [box.getGrid().getGridID(), box.getContainer().get("id"), box.getSlot().get("id"), box.getIndex(), this.model.parentpath + this.model.structure.key, search], {
      success_fn: function success_fn(data) {
        self.$el.find(".suggestion-list").empty();

        underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(data.result, function (elem) {
          self.$el.find(".suggestion-list").append(jQuery("<li/>").text(elem.value).attr("data-key", elem.key));
        });

        self.$el.find(".loading").removeClass("go");
      }
    });
  },
  selectItem: function selectItem($item) {
    var key = $item.data("key");
    var value = $item.text();

    if (jQuery(".autocomplete-multiselect-item[data-key='" + key + "']").length) {
      this.$el.find(".suggestion-list").empty();
      this.$el.find("input.i-autocomplete").removeAttr('value');
    } else {
      this.$el.find(".autocomplete-wrapper").append(jQuery("<div></div>").addClass("autocomplete-multiselect-item").text(value).attr({
        "data-key": key
      }).append(jQuery("<span></span>").addClass("icon icon-cancel").click(function () {
        var item = jQuery(this).parent();
        item.empty();
        item.remove();
      })));
    }

    this.$el.find(".suggestion-list").empty();
    this.$el.find("input.i-autocomplete").val("");
  },
  listItemSelected: function listItemSelected(e) {
    this.selectItem(jQuery(e.target));
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/number.js":
/*!***********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/number.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['number'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-number",
  initialize: function initialize() {},
  render: function render() {
    var text = this.model.container[this.model.structure.key];
    if (!text) text = "";
    this.$el.html("<label>" + this.model.structure.label + "</label><input type=number class='dynamic-value' value='" + text + "'/>");
    return this;
  },
  fetchValue: function fetchValue() {
    return jQuery(this.$el).find("input").val();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/select.js":
/*!***********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/select.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


boxEditorControls['select'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-select",
  initialize: function initialize() {},
  render: function render() {
    var structure = this.model.structure;
    var container = this.model.container;
    console.debug(structure, container);
    var isMultiple = _typeof(structure.multiple) !== ( true ? "undefined" : undefined) && structure.multiple;
    var values = container[structure.key];

    var hasMultipleValues = _typeof(values) === _typeof([]);

    var selections = structure.selections;
    var multiple = isMultiple ? "multiple='multiple'" : "";
    var size = !isMultiple || selections.size < 8 ? "" : selections.length < 12 ? "size='6'" : "size='8'";
    var html = "<label>" + this.model.structure.label + "</label><select " + multiple + " " + size + ">";

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(selections, function (elem) {
      var selected = "";
      if (!hasMultipleValues && "".concat(values) === "".concat(elem.key) || hasMultipleValues && underscore__WEBPACK_IMPORTED_MODULE_1__["default"].indexOf(values, elem.key) > -1) selected = "selected";
      html += "<option " + selected + " value='" + elem.key + "'>" + elem.text + "</option>";
    });

    html = html + "</select>";
    jQuery(this.el).html(html);
    return this;
  },
  fetchValue: function fetchValue() {
    return jQuery(this.$el).find("select").val();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/text.js":
/*!*********************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/text.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['text'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-text",
  initialize: function initialize() {},
  render: function render() {
    this.$el.empty();
    this.$el.append(jQuery("<label/>").text(this.model.structure.label));
    this.$el.append(jQuery("<input type=text class='dynamic-value'/>").val(this.model.container[this.model.structure.key] || ""));
    return this;
  },
  fetchValue: function fetchValue() {
    return jQuery(this.$el).find("input").val();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/textarea.js":
/*!*************************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/textarea.js ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['textarea'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-textarea",
  initialize: function initialize() {},
  render: function render() {
    var text = this.model.container[this.model.structure.key];
    if (!text) text = "";
    this.$el.html("<label>" + this.model.structure.label + "</label><textarea class='dynamic-value form-textarea'>" + text + "</textarea>");
    return this;
  },
  fetchValue: function fetchValue() {
    return jQuery(this.$el).find("textarea").val();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/EditorWidgets/wp_mediaselect.js":
/*!*******************************************************************!*\
  !*** ./src/grid-editor/lib/views/EditorWidgets/wp_mediaselect.js ***!
  \*******************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/

boxEditorControls['wp-mediaselect'] = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-editor-widget grid-editor-widget-wp-mediaselect",
  events: {
    "click .upload_image_button": "open_wp_media"
  },
  initialize: function initialize() {},
  render: function render() {
    var element = this.model.structure;
    var c_val = this.model.container[element.key];
    this.$el.append("<label>" + element.label + "</label>");
    /**
     * media type filter
     */

    this.media_type = "*";

    if (_typeof(element.media_type) != ( true ? "undefined" : undefined)) {
      this.media_type = element.media_type;
    }
    /**
     * show preview of image
     */


    this.$img_wrapper = jQuery("<div></div>");
    this.$img_wrapper.addClass("wp-mediaselect-image-wrapper");
    this.$el.append(this.$img_wrapper);
    /**
     * upload button
     */

    this.$upload_btn = jQuery("<button class='button upload_image_button'>Media</button>");
    this.$el.append(this.$upload_btn);
    /**
     * hidden input with saved values
     */

    this.$input = jQuery("<input />").attr('value', JSON.stringify(c_val)).attr('type', 'hidden').addClass('dynamic-value form-json').attr("data-path", this.model.parentpath + element.key).attr('data-key', element.key);
    this.$el.append(this.$input);
    /**
     * available sizes select
     */

    this.$select_image_size = jQuery("<select class='image-sizes'></select>");
    this.$el.append(this.$select_image_size);
    this.$select_image_size.on("change", function () {
      var $this = jQuery(this);
      var json = JSON.parse($this.siblings('.dynamic-value').val());
      json.size = $this.val();
      $this.siblings('.dynamic-value').val(JSON.stringify(json));
    });
    this.buildImageSizeSelect();
    this.buildImagePreview();
    return this;
  },
  open_wp_media: function open_wp_media() {
    var self = this;
    var frame = wp.media({
      //title : lang_values['title-wp-media'],
      multiple: false,
      library: {
        type: this.media_type
      },
      button: {
        text: "Insert"
      }
    });
    frame.on('open', function () {
      var selection = frame.state().get('selection');
      var val = JSON.parse(self.$input.val());
      var attachment = wp.media.attachment(val.id);
      selection.add(attachment ? [attachment] : []);
    });
    frame.on('close', function () {
      var selection = frame.state().get('selection');
      jQuery.each(frame.state().get('selection')._byId, function (id, val) {
        var sizes = val.get("sizes");

        if (typeof sizes === "undefined") {
          sizes = {
            full: {
              height: "",
              width: "",
              url: val.get("url"),
              orientation: ""
            }
          };
        }

        var r_json = {
          id: val.id,
          size: "full",
          sizes: sizes
        };
        self.$input.val(JSON.stringify(r_json));
        self.buildImageSizeSelect();
        self.buildImagePreview();
        return false;
      });
    });
    frame.open();
    return false;
  },
  get_json_from_input: function get_json_from_input() {
    var json = null;

    if (this.$input.val() != "object") {
      try {
        json = JSON.parse(this.$input.val());
      } catch (e) {
        json = null;
      }
    } else {
      json = this.$input.val();
    }

    return json;
  },
  buildImagePreview: function buildImagePreview() {
    var json = this.get_json_from_input();

    if (json == null || json == '' || _typeof(json) != _typeof({}) || _typeof(json.sizes) != _typeof({}) || _typeof(json.sizes.thumbnail) != _typeof({}) || _typeof(json.sizes.thumbnail.url) != _typeof("")) {
      return;
    }

    var $img = jQuery("<img/>");
    $img.addClass("wp-mediaselect-image-preview").attr("src", json.sizes.thumbnail.url).attr("width", json.sizes.thumbnail.width).attr("height", json.sizes.thumbnail.height);
    this.$img_wrapper.empty();
    this.$img_wrapper.append($img);
  },
  buildImageSizeSelect: function buildImageSizeSelect() {
    var self = this;

    if (this.$input.val() == "") {
      return;
    }

    var json = this.get_json_from_input();

    if (json == null || json == '' || _typeof(json) != _typeof({}) || _typeof(json.sizes) != _typeof({})) {
      this.$select_image_size.hide();
      return;
    }

    this.$select_image_size.empty();
    jQuery.each(json.sizes, function (index, size) {
      var selected = "";

      if (json.size == index) {
        selected = "selected='selected'";
      }

      jQuery("<option " + selected + " >" + index + "</option>").attr('value', index).appendTo(self.$select_image_size);
    });

    if (this.$select_image_size.children().length > 0) {
      this.$select_image_size.show();
    } else {
      this.$select_image_size.hide();
    }
  },
  fetchValue: function fetchValue() {
    var value = "";

    try {
      value = JSON.parse(this.$input.val());
    } catch (e) {
      GRID.log("empty image box");
    }

    return value;
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridAuthorView.js":
/*!*****************************************************!*\
  !*** ./src/grid-editor/lib/views/GridAuthorView.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_1__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.Author = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: "li",
  className: "grid-author",
  events: {
    "click .author-lock-sender": "onClickSendLock",
    "click .author-lock-requester": "onClickRequestLock"
  },
  initialize: function initialize() {
    this.listenTo(this.model, "change:request_lock", this.onRequestLock);
  },
  render: function render() {
    var json = this.model.toJSON();
    json.have_lock = GRID.authors.haveLock();
    this.$el.empty();
    this.$el.append(icanhaz__WEBPACK_IMPORTED_MODULE_1___default.a.tpl_author(json));
    this.onRequestLock();
    return this;
  },
  onClickSendLock: function onClickSendLock() {
    GRID.async.locking_handover(this.model.get("id"));
  },
  onClickRequestLock: function onClickRequestLock() {
    GRID.async.locking_request_lock();
  },
  onRequestLock: function onRequestLock() {
    if (this.model.get("request_lock")) {
      this.$el.addClass('async-request-lock');
    } else {
      this.$el.removeClass('async-request-lock');
    }
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridAuthorsView.js":
/*!******************************************************!*\
  !*** ./src/grid-editor/lib/views/GridAuthorsView.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_1__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.Authors = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-authors",
  initialize: function initialize() {
    this.listenTo(GRID.authors, "add", this.onAddAuthor);
    this.listenTo(GRID.authors, "remove", this.render);
    this.listenTo(GRID.authors, "reset", this.render);
    this.listenTo(GRID.authors, "change", this.render);
  },
  render: function render() {
    this.$el.empty();
    this.$el.append(icanhaz__WEBPACK_IMPORTED_MODULE_1___default.a.tpl_authors());
    this.$list = this.$el.find(".authors-list");
    var self = this;
    GRID.authors.each(function (author) {
      self.onAddAuthor(author);
    });
    return this;
  },
  onResize: function onResize(height) {
    this.$list.css("height", height + "px");
  },
  onAddAuthor: function onAddAuthor(author) {
    var author = new Author({
      model: author
    });
    this.$list.append(author.render().$el);
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridBoxEditorView.js":
/*!********************************************************!*\
  !*** ./src/grid-editor/lib/views/GridBoxEditorView.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./src/grid-editor/lib/utils.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/




window.BoxEditor = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-box-editor",
  events: {
    'click .grid-editor-controls [role=cancel]': 'onCancel',
    'click .grid-editor-legend': 'onToggle',
    'click .grid-editor-controls [role=save]': 'onSave',
    'click .grid-editor-controls [role=reuse]': 'onMakeReusable',
    'click .grid-editor-url-button': 'onUrlToggle'
  },
  initialize: function initialize() {},
  render: function render() {
    var _this = this;

    var styles = GRID.getBoxStyles().toJSON();
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(styles, function (elem) {
      if (elem.slug === self.model.get("style")) elem.selected = "selected";else elem.selected = "";
    });

    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_boxeditor({
      'lang_values': document.lang_values,
      'box': this.model.toJSON(),
      'b_index': this.model.getIndex(),
      'c_id': this.model.getContainer().get("id"),
      's_id': this.model.getSlot().get("id"),
      'styles': styles
    }));
    var contentstructure = this.model.get("contentstructure");
    var fieldcontainer = this.$el.find(".grid-dynamic-fields .grid-editor-field-wrapper");
    var views = [];

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(contentstructure, function (elem) {
      var type = elem.type;
      var view = new boxEditorControls[type]({
        model: {
          structure: elem,
          container: self.model.get("content"),
          box: self.model,
          parentpath: ""
        }
      });
      views.push(view);
      fieldcontainer.append(view.render().el);
    });

    this.views = views;
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["initHTMLEditor"])(this.el.querySelector(".grid-editor-prolog")).then(function (editor) {
      return _this.prologEditor = editor;
    });
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["initHTMLEditor"])(this.el.querySelector(".grid-editor-epilog")).then(function (editor) {
      return _this.epilogEditor = editor;
    });

    if (GRID.getBoxStyles().length < 1) {
      this.$el.find(".grid-editor-box-styles-wrapper").hide();
    }

    this.$el.find(".grid-collapsable-shown").addClass('grid-active');
    jQuery.each(this.$el.find(".grid-editor-url-input"), function (index, val) {
      var $url = jQuery(val);

      if ($url.val() == "") {
        $url.siblings('button').trigger("click");
      }
    });
    return this;
  },
  onCancel: function onCancel() {
    GRID.hideEditor(function () {
      GRID.$root_editor.html("");
    });
  },
  onToggle: function onToggle(e) {
    jQuery(e.currentTarget).parent().toggleClass('grid-active');
  },
  onUrlToggle: function onUrlToggle(e) {
    var $parent = jQuery(e.target).parent();

    if ($parent.hasClass('grid-editor-url-show')) {
      $parent.find('input').attr("disabled", "disabled").val("");
      $parent.find('button').html("Add link");
    } else {
      $parent.find('button').html("Delete Link");
      $parent.find('input').removeAttr('disabled');
    }

    jQuery(e.target).parent().toggleClass('grid-editor-url-show');
  },
  onMakeReusable: function onMakeReusable(e) {
    if (!confirm(document.lang_values["confirm-box-reuse"])) return;
    this.model.save(null, {
      action: "reuse"
    });
    GRID.hideEditor(function () {
      GRID.$root_editor.html("");
    });
  },
  onSave: function onSave(e) {
    var obj = {};

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(this.views, function (view) {
      obj[view.model.structure.key] = view.fetchValue();
    });

    this.model.set('content', obj);
    this.model.set('title', this.$el.find(".grid-editor-title").val());
    this.model.set('titleurl', this.$el.find(".grid-editor-titleurl").val());
    this.model.set('prolog', this.prologEditor.getData());
    this.model.set('epilog', this.epilogEditor.getData());
    this.model.set('readmore', this.$el.find('.grid-editor-readmore').val());
    this.model.set('readmoreurl', this.$el.find('.grid-editor-readmoreurl').val());
    this.model.set('style', this.$el.find(".grid-editor-styles-wrapper select").val());
    this.model.save();
    GRID.hideEditor(function () {
      GRID.$root_editor.html("");
    });
  }
});
boxEditorControls = {};

/***/ }),

/***/ "./src/grid-editor/lib/views/GridContainerEditorView.js":
/*!**************************************************************!*\
  !*** ./src/grid-editor/lib/views/GridContainerEditorView.js ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./src/grid-editor/lib/utils.js");
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/




window.GridContainerEditor = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-container-editor",
  events: {
    'click .grid-editor-controls [role=cancel]': 'onCancel',
    'click .grid-editor-controls [role=save]': 'onSave',
    'click .grid-editor-legend': 'onToggle',
    'click .grid-editor-url-button': 'onUrlToggle'
  },
  initialize: function initialize() {},
  render: function render() {
    var _this = this;

    GRID.log(this.model.toJSON());
    var styles = GRID.getContainerStyles().toJSON();
    var self = this;

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(styles, function (elem) {
      if (elem.slug == self.model.get("style")) elem.selected = "selected";else elem.selected = "";
    });

    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_containereditor({
      'lang_values': document.lang_values,
      'model': this.model.toJSON(),
      'styles': styles
    }));
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["initHTMLEditor"])(this.el.querySelector(".grid-editor-prolog")).then(function (editor) {
      return _this.prologEditor = editor;
    });
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["initHTMLEditor"])(this.el.querySelector(".grid-editor-epilog")).then(function (editor) {
      return _this.epilogEditor = editor;
    });
    this.$el.find(".grid-collapsable-shown").addClass("grid-active");
    jQuery.each(this.$el.find(".grid-editor-url-input"), function (index, val) {
      var $url = jQuery(val);

      if ($url.val() == "") {
        $url.siblings('button').trigger("click");
      }
    });
    return this;
  },
  onToggle: function onToggle(e) {
    jQuery(e.currentTarget).parent().toggleClass('grid-active');
  },
  onUrlToggle: function onUrlToggle(e) {
    var $parent = jQuery(e.target).parent();

    if ($parent.hasClass('grid-editor-url-show')) {
      $parent.find('input').attr("disabled", "disabled").val("");
      $parent.find('button').html("Add link");
    } else {
      $parent.find('button').html("Delete Link");
      $parent.find('input').removeAttr('disabled');
    }

    jQuery(e.target).parent().toggleClass('grid-editor-url-show');
  },
  onCancel: function onCancel() {
    GRID.hideEditor(function () {
      jQuery(GRID.$root_editor).html("");
    });
  },
  onSave: function onSave(e) {
    var class_prefix = ".grid-editor-";
    this.model.set('title', this.$el.find(class_prefix + "title").val());
    this.model.set('titleurl', this.$el.find(class_prefix + "titleurl").val());
    this.model.set('prolog', this.prologEditor.getData());
    this.model.set('epilog', this.epilogEditor.getData());
    this.model.set('readmore', this.$el.find(class_prefix + "readmore").val());
    this.model.set('readmoreurl', this.$el.find(class_prefix + "readmoreurl").val());
    this.model.set('style', this.$el.find(class_prefix + "style").val());
    this.model.set('style_label', jQuery(this.$el).find(class_prefix + "style option:selected").text());
    this.model.save();
    GRID.hideEditor(function () {
      GRID.$root_editor.html("");
    });
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridRevisionsView.js":
/*!********************************************************!*\
  !*** ./src/grid-editor/lib/views/GridRevisionsView.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_2__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/



window.GridRevisionsView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  tagName: 'div',
  className: 'grid-revisions',
  events: {
    'click [role=preview]': 'onPreview',
    'click [role=delete]': 'onDelete',
    'click [role=revert]': 'onRevert'
  },
  initialize: function initialize() {
    this.listenTo(this.collection, 'add', this.render);
    this.$list = jQuery("<div class='grid-revisions-list'></ul>");
    this.$el.append(this.$list);
    this.interval = setInterval(this.onRevisionsScroll.bind(this), 1000);
  },
  render: function render() {
    var revisions = this.collection.toJSON();

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(revisions, function (elem) {
      elem.isDraft = false;
      elem.isPublished = false;
      elem.isDeprecated = false;

      if (elem.state == "published") {
        elem.isPublished = true;
      } else if (elem.state == "draft") {
        elem.isDraft = true;
      } else if (elem.state == "deprecated") {
        elem.isDeprecated = true;
      }

      elem["readable_date"] = "--.--.----";

      if (typeof elem["date"] != "undefined" && elem["date"] != "" && elem["date"] != null) {
        var date = new Date(parseInt(elem["date"]) * 1000);
        elem["readable_date"] = date.getDate() + "." + (date.getMonth() + 1) + "." + date.getFullYear() + " &bull; " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
      }

      if (typeof elem["editor"] === "undefined" || elem["editor"] == "" || elem["editor"] === null) {
        elem["editor"] = "unknown";
      }
    });

    this.$list.html(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_revisions({
      revisions: revisions,
      lang_values: document.lang_values
    }));
    var child_count = this.$list.children().length;
    var list_width = child_count * this.$list.children().last().outerWidth(true);
    this.$list.css("width", list_width);
    return this;
  },
  onRevisionsScroll: function onRevisionsScroll() {
    if (this.collection.nextpage == -1) return;
    if (!this.$el.is(":visible")) return;
    var diff = this.$list.outerWidth(true) - Math.abs(this.$list.position().left);
    diff = diff - this.$el.outerWidth(true);

    if (diff < 300) {
      this.collection.fetch({
        page: this.collection.nextpage
      });
    }
  },
  onPreview: function onPreview(e) {
    var $revision = jQuery(e.target).parents(".grid-revision");
    var location = GRID.PREVIEW_PATTERN.replace("{REV}", $revision.data("revision"));
    window.open(location, "_blank");
    this.$el.parents(".rev-wrapper").toggle();
  },
  onDelete: function onDelete(e) {
    if (!GRID.getRights().get("revert") || GRID.locked()) {
      alert("You have no rights for that...");
      return false;
    }

    GRID.revert();
  },
  onRevert: function onRevert(e) {
    if (!GRID.getRights().get("revert") || GRID.locked()) {
      alert("You have no rights for that...");
      return false;
    }

    var revision = jQuery(e.target).parents(".grid-revision").data("revision");
    GRID.setToRevision(revision);
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridSlotStyleChangerView.js":
/*!***************************************************************!*\
  !*** ./src/grid-editor/lib/views/GridSlotStyleChangerView.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_1__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.GridSlotStyleChangerView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-slot-style-changer style-changer",
  tagName: "div",
  events: {
    "click li": "changeStyle"
  },
  initialize: function initialize() {
    this.listenTo(GRID.getSlotStyles(), "add", this.render);
  },
  render: function render() {
    var styles = [];
    var activestyle = "Default Style";
    var self = this;
    GRID.getSlotStyles().each(function (style) {
      if (style.get("slug") == self.model.get("style")) activestyle = style.get("title");
      styles.push(style.toJSON());
    });
    var container = this.model.getContainer();
    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_1___default.a.tpl_slotstylechanger({
      styles: styles,
      activestyle: activestyle,
      reused: container.get("reused")
    }));
    return this;
  },
  changeStyle: function changeStyle(event) {
    this.model.set("style", jQuery(event.target).attr("data-style"));
    this.model.save();
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridToolBoxBlueprintsView.js":
/*!****************************************************************!*\
  !*** ./src/grid-editor/lib/views/GridToolBoxBlueprintsView.js ***!
  \****************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_1__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.GridToolBoxBlueprintsView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-box-blueprints",
  timer: null,
  blueprints: null,
  events: {
    "keyup .grid-box-blueprints-search input": "searchString"
  },
  render: function render() {
    this.blueprints = this.model.getBlueprints();
    this.box_type = this.model.get("type");
    this.listenTo(this.blueprints, "add", this.addBlueprintBox);
    this.model.searchBoxes();
    this.delegateEvents();

    if (this.model.get("criteria").length > 0) {
      var $_search = jQuery('<div class="grid-box-blueprints-search"><input placeholder="Which do you need?" type="text" value="" /></div>');
      this.$el.append($_search);
      this.searchString({
        target: $_search.find("input")
      });
    }

    this.$blueprintslist = jQuery("<div class='grid-box-blueprints-list'></div>");
    this.$el.append(this.$blueprintslist);
    return this;
  },
  addBlueprintBox: function addBlueprintBox(blueprint, collection, event) {
    var json = blueprint.toJSON();
    json.cid = blueprint.cid;
    json.reusable = this.box_type == "reference";
    this.$blueprintslist.append(icanhaz__WEBPACK_IMPORTED_MODULE_1___default.a.tpl_toolBoxesBlueprint(json));
    this.initializesDraggable();
    return this;
  },
  searchString: function searchString(event) {
    var input = jQuery(event.target).val();
    var self = this;
    if (this.timer) clearTimeout(this.timer);
    this.timer = setTimeout(function () {
      self.stopListening(self.blueprints);
      self.blueprints = self.model.search(input, self.model.criteria);
      self.$blueprintslist.empty();
      self.listenTo(self.blueprints, "add", self.addBlueprintBox);
    }, 300);
  },
  initializesDraggable: function initializesDraggable() {
    var self = this;
    jQuery(this.el).find(".grid-box-dragger").draggable({
      helper: function helper(event, element) {
        return jQuery("<div class='dragger-helper'></div>");
      },
      cursorAt: {
        left: 30,
        top: 30
      },
      zIndex: 199,
      appendTo: GRID.getView().$el,
      addClass: true,
      //connectToSortable: GRID_SORTABLE,
      start: function start(event, ui) {
        var $ = jQuery;
        var $slots = jQuery(GRID.getView().el).find(".grid-container-type-c[data-reused=false] .grid-slot .grid-boxes-wrapper" + ", .grid-container-type-sc .grid-slot .grid-boxes-wrapper");
        GRID.log($slots); // drop place template
        // TODO: if boxes toggled hidden
        // var $toggle_btn = $toolbar.find("[role=hide_boxes]");

        $slots.children(".grid-box").before(jQuery(document.createElement('div')).addClass("grid-box-drop-area-wrapper"));
        $slots.append(jQuery(document.createElement('div')).addClass("grid-box-drop-area-wrapper"));
        $slots.find(".grid-box-drop-area-wrapper").append(jQuery(document.createElement('div')).addClass("grid-box-drop-area"));
        $slots.find(".grid-box-drop-area").droppable({
          accept: ".grid-box-dragger",
          hoverClass: "hover",
          drop: function drop(event, ui) {
            var $this_box = jQuery(ui.draggable);
            var $this_drop = jQuery(this);
            var $this_slot = $this_drop.parents(".grid-slot");
            var $this_container = $this_slot.parents(".grid-container");
            var slot = GRID.getModel().getContainers().get($this_container.data("id")).getSlots().get($this_slot.data("id"));
            var blueprint = self.blueprints.get($this_box.data("cid"));
            var $new_box = $this_drop.parent().addClass('grid-new-box-place').removeClass('grid-box-drop-area-wrapper');
            GRID.getView().$el.find(".grid-box-drop-area-wrapper").remove();
            var box = slot.createBox(blueprint, $new_box.index());
          }
        });
      },
      stop: function stop(event, ui) {
        GRID.getView().$el.find(".grid-box-drop-area-wrapper").remove();
      }
    });
    return this;
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridToolBoxTypesView.js":
/*!***********************************************************!*\
  !*** ./src/grid-editor/lib/views/GridToolBoxTypesView.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_1__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.GridToolBoxTypesView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-tool grid-element-box",
  events: {
    "click .grid-box-type": "toggleBoxType"
  },
  render: function render() {
    var self = this;
    this.$el.empty();
    var json = {
      boxtypes: []
    };
    this.collection.each(function (boxtype, index) {
      var boxtype_json = boxtype.toJSON();
      boxtype_json.index = index;
      json.boxtypes.push(boxtype_json);
    });
    this.$el.append(icanhaz__WEBPACK_IMPORTED_MODULE_1___default.a.tpl_toolBoxes(json));
    this.delegateEvents();
    return this;
  },
  toggleBoxType: function toggleBoxType(event) {
    var $this = jQuery(event.currentTarget);
    $this.toggleClass('active');

    if ($this.hasClass('active')) {
      var blueprints_view = new GridToolBoxBlueprintsView({
        model: this.collection.at($this.data("index"))
      });
      $this.next("dd").append(blueprints_view.render().el);
    } else {
      $this.next("dd").empty();
    }
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridToolContainersView.js":
/*!*************************************************************!*\
  !*** ./src/grid-editor/lib/views/GridToolContainersView.js ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_2__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/



window.GridToolContainersView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  className: "grid-tool grid-element-container",
  events: {
    "click .grid-container-type": "renderContainerType"
  },
  render: function render() {
    this.$el.empty();
    this.$el.append(icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_toolContainers({}));
    this.delegateEvents(); // if you want to show containers on default uncomment next line
    //this.$el.find(".grid-container-type").first().trigger("click");

    return this;
  },
  renderContainerType: function renderContainerType(event) {
    var $type = jQuery(event.currentTarget);
    $type.toggleClass('active');
    var role = $type.attr("role");
    var list = "";

    if (role === "reusable") {
      // reusables
      var reusables = this.getReusable();
      list = this.getRenderedContainerList(reusables);
    } else {
      // containers
      var containers = this.getContainers(role);
      list = this.getRenderedContainerList(containers);
    } // DOM manipulation


    if ($type.hasClass('active')) {
      // add elements
      $type.next("dd").append(list);
    } else {
      // remove elements
      $type.next("dd").empty();
    }

    this.initializesDraggable();
    return this;
  },
  getRenderedContainerList: function getRenderedContainerList(json) {
    return icanhaz__WEBPACK_IMPORTED_MODULE_2___default.a.tpl_toolContainersContainer(json);
  },
  getContainers: function getContainers(type) {
    var scope_type = "c-";
    var collection = this.collection;
    var containers = {
      containers: this.collection.toJSON()
    };

    underscore__WEBPACK_IMPORTED_MODULE_1__["default"].each(containers.containers, function (value, key, list) {
      if (value.type.indexOf(scope_type) !== 0) {
        delete containers.containers[key];
      } else {
        value.slots = [];
        var slots_dimension = collection.at(key).getDimension().split("-");

        for (var i = 0; i < value.numslots; i++) {
          value.slots.push({
            dimension: slots_dimension[i]
          });
        }
      }
    });

    return containers;
  },
  getReusable: function getReusable() {
    return {
      containers: GRID.getReusableContainers().toJSON()
    };
  },
  initializesDraggable: function initializesDraggable() {
    jQuery(this.el).find(".grid-new-element").draggable({
      helper: function helper(event, element) {
        return jQuery("<div class='dragger-helper'></div>");
      },
      cursorAt: {
        left: 30,
        top: 30
      },
      zIndex: 99,
      appendTo: GRID.getView().$el,
      scroll: true,
      start: function start(event, ui) {
        GRID.log("Start dragging");
        var $ = jQuery;
        var $grid = GRID.getView().$el;
        var $containers = $grid.find('.grid-container');
        var $dropArea = jQuery(document.createElement("div")).addClass("container-drop-area-wrapper").attr("data-type", "container-drop-area-wrapper");
        $grid.find(".containers-wrapper").prepend($dropArea.clone());
        $containers.after($dropArea.clone());
        $grid.find(".container-drop-area-wrapper").append(jQuery(document.createElement("div")).addClass("container-drop-area"));
        $grid.find(".container-drop-area").droppable({
          accept: ".grid-new-element",
          hoverClass: "hover",
          drop: function drop(event, ui) {
            var $draggable = jQuery(ui.draggable);
            var containerReusable = $draggable.data("reusable");
            var containerType = $draggable.data("type");
            var $dropwrapper = jQuery(this).parent();
            $dropwrapper.removeClass('container-drop-area-wrapper').addClass('new-container-target');
            GRID.getView().$el.find('.container-drop-area-wrapper').remove();
            var new_index = $dropwrapper.index();

            if (containerReusable == true || containerReusable == "true") {
              var container = GRID.getReusableContainers().at($draggable.index());
              GRID.getModel().addReuseContainer(container, new_index);
              GRID.log(["REUSED", container]);
              return;
            }

            GRID.getModel().createContainer(containerType, new_index);
          }
        });
      },
      stop: function stop(event, ui) {
        GRID.getView().$el.find('.container-drop-area-wrapper').remove();
      }
    });
    return this;
  }
});

/***/ }),

/***/ "./src/grid-editor/lib/views/GridToolbarView.js":
/*!******************************************************!*\
  !*** ./src/grid-editor/lib/views/GridToolbarView.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icanhaz */ "./node_modules/icanhaz/ICanHaz.js");
/* harmony import */ var icanhaz__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(icanhaz__WEBPACK_IMPORTED_MODULE_1__);
/**
* @author Palasthotel <rezeption@palasthotel.de>
* @copyright Copyright (c) 2014, Palasthotel
* @license http://www.gnu.org/licenses/gpl-2.0.html GPLv2
* @package Palasthotel\Grid
*/


window.GridToolbarView = backbone__WEBPACK_IMPORTED_MODULE_0___default.a.View.extend({
  id: "grid-toolbar",
  _toolContainersView: null,
  _toolBoxesView: null,
  _revisionsView: null,
  events: {
    "click .grid-toolbar [role=publish]": "publish",
    "click .grid-toolbar [role=preview]": "preview",
    "click .grid-toolbar [role=revert]": "revert",
    "click .grid-toolbar [role=revisions]": "revisions",
    "click .grid-toolbar [role=authors]": "onClickAuthors",
    "click .grid-element-type[data-type=box]:not(.active)": "showBoxTools",
    "click .grid-element-type[data-type=container]:not(.active)": "showContainerTools"
  },
  initialize: function initialize() {
    this.listenTo(this.model, "change:isDraft", this.setState);
    this.listenTo(GRID.authors, "add", this.onUpdateAuthors);
    this.listenTo(GRID.authors, "remove", this.onUpdateAuthors);
    this.listenTo(GRID.authors, "reset", this.onUpdateAuthors);
    this.setState();
  },
  render: function render() {
    this.$el.html(icanhaz__WEBPACK_IMPORTED_MODULE_1___default.a.tpl_toolbar(this.model.toJSON()));
    this.$toolbar = this.$el.find(".grid-toolbar");
    this.$tool_elements = this.$el.find(".grid-tool-elements");
    this.$tool_element_content = this.$el.find(".grid-element-type-content");
    this.$tab_container = this.$el.find(".grid-element-type[data-type=container]");
    this.$tab_box = this.$el.find(".grid-element-type[data-type=box]");
    this.$element_trash = this.$el.find(".grid-element-trash");
    this.$authors_count = this.$el.find(".indicator-authors-count");

    if (GRID.mode == "grid") {
      this._revisionsView = new GridRevisionsView({
        collection: GRID.revisions
      });
      this.$el.append(this._revisionsView.$el.hide());
    }

    var type = "container";

    if (GRID.mode == "container" || !GRID.getRights().get("create-container")) {
      this.$tab_container.remove();
      type = "box";
    }

    if (!GRID.getRights().get("create-box")) {
      this.$tab_box.remove();
      type = false;
    }

    if (type == "container") {
      this.showContainerTools();
    } else if (type == "box") {
      this.showBoxTools();
    }

    this.onUpdateAuthors();
    return this;
  },
  publish: function publish() {
    if (!GRID.getRights().get("publish") || GRID.locked()) {
      alert("You have no rights for that...");
      return false;
    }

    this.model.save();
  },
  setState: function setState() {
    var isDraft = this.model.get("isDraft");
    this.$el.find(".grid-toolbar").attr("data-draft", isDraft);
    var $button = this.$el.find(".grid-tool-state span");

    if (isDraft) {
      $button.html("Draft");
    } else {
      $button.html("Published");
    }
  },
  preview: function preview() {
    window.open(this.model.get("PREVIEW_URL"), "grid_preview");
  },
  revert: function revert() {
    if (!GRID.getRights().get("revert") || GRID.locked()) {
      alert("You have no rights for that...");
      return false;
    }

    GRID.revert();
  },
  revisions: function revisions() {
    this._revisionsView.$el.slideToggle();

    jQuery("html, body").animate({
      scrollTop: 0
    }, 300);
  },
  toggleBoxes: function toggleBoxes() {
    GRID.log("BTN toggleBoxes");
  },
  // container tools
  getToolContainersView: function getToolContainersView() {
    if (!(this._toolContainersView instanceof GridToolContainersView)) {
      this._toolContainersView = new GridToolContainersView({
        collection: GRID.getContainerTypes()
      });
    }

    return this._toolContainersView;
  },
  containerToolsVisible: function containerToolsVisible() {
    return this.$el.find(this.getToolContainersView().el).length == 1;
  },
  toggleContainerTools: function toggleContainerTools() {
    this.hideBoxTools();

    if (!this.containerToolsVisible()) {
      this.showContainerTools();
    } else {
      this.hideContainerTools();
    }
  },
  showContainerTools: function showContainerTools() {
    this.hideBoxTools();

    if (!this.containerToolsVisible()) {
      this.$el.find(this.getToolContainersView().el).remove();
      this.$el.find('.grid-element-type-content').append(this.getToolContainersView().render().el);
      this.$tab_container.addClass('active');
    }
  },
  hideContainerTools: function hideContainerTools() {
    if (this.containerToolsVisible()) {
      this.$el.find(this.getToolContainersView().el).remove();
      this.$tab_container.removeClass('active');
    }
  },
  // boxes tools
  getToolBoxesView: function getToolBoxesView() {
    if (!(this._toolBoxesView instanceof GridToolBoxTypesView)) {
      this._toolBoxesView = new GridToolBoxTypesView({
        collection: GRID.getBoxTypes()
      });
    }

    return this._toolBoxesView;
  },
  boxToolsVisible: function boxToolsVisible() {
    return this.$el.find(this.getToolBoxesView().el).length == 1;
  },
  toggleBoxTools: function toggleBoxTools() {
    this.hideContainerTools();

    if (!this.boxToolsVisible()) {
      this.showBoxTools();
    } else {
      this.hideBoxTools();
    }
  },
  showBoxTools: function showBoxTools() {
    this.hideContainerTools();

    if (!this.boxToolsVisible()) {
      this.$el.find('.grid-element-type-content').append(this.getToolBoxesView().render().el);
      this.$tab_box.addClass('active');
    }
  },
  hideBoxTools: function hideBoxTools() {
    if (this.boxToolsVisible()) {
      this.$tab_box.removeClass('active');
      this.$el.find(this.getToolBoxesView().el).remove();
    }
  },
  // resize Container and Box toolbar
  onResize: function onResize() {
    var window_height = jQuery(window).height();
    var elements_top_offset = this.$el.offset().top;
    var tab_height = this.$tab_container.outerHeight();
    var height = window_height - elements_top_offset - tab_height;
    this.$tool_element_content.css("height", height);
    this.trigger('toolbar_resize', height);
  },

  /**
   * authors button
   */
  onUpdateAuthors: function onUpdateAuthors() {
    if (GRID.authors.getCount() < 2) {
      this.$authors_count.parents("li").hide();
    } else {
      this.$authors_count.parents("li").show();
      this.$authors_count.text(GRID.authors.getCount());
    }

    this.$toolbar.removeClass("async-request-lock");
    var self = this;
    GRID.authors.each(function (author) {
      if (author.get("request_lock")) {
        self.$toolbar.addClass("async-request-lock");
      }
    });
  },
  onClickAuthors: function onClickAuthors(e) {
    GRID.toggleAuthors();
    this.$toolbar.removeClass("async-request-lock");
  },

  /**
   * when user requests lock event
   */
  async_request_lock: function async_request_lock() {
    this.$toolbar.addClass("async-request-lock");
  }
});

/***/ }),

/***/ 0:
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "jquery-ui":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvZ2xvYmFsVGhpcy5icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWNhbmhhei9JQ2FuSGF6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3VpL3dpZGdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3BhcnNldXJpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2NiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2NoYWluUmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2NvbGxlY3ROb25FbnVtUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fY3JlYXRlRXNjYXBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19jcmVhdGVJbmRleEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19jcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19jcmVhdGVSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fZGVlcEdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19lc2NhcGVNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fZXhlY3V0ZUJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fZ2V0Qnl0ZUxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19nZXRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX2lzQnVmZmVyTGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19rZXlJbk9iai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL19vcHRpbWl6ZUNiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX3NldHVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvX3NoYWxsb3dQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL190YWdUZXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9fdW5lc2NhcGVNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9hZnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2FsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9iZWZvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvYmluZEFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2NoYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvY2h1bmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2NvbXBhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9jb21wb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2NvdW50QnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvZGVmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9kZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9leHRlbmRPd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9maW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvZmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvZmluZEtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2ZpbmRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9maW5kV2hlcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9maXJzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9ncm91cEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pbmRleC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pbmRleC1kZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pbmRleEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2luaXRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc0FycmF5QnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNCb29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzRGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzRmluaXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNNYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzTmFOLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNOdWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzUmVnRXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2lzU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvaXNVbmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pc1dlYWtTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9pdGVyYXRlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9sYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvbGFzdEluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9tYXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9tYXRjaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvbWF4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL21pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL21peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvbmVnYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvbm9vcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL25vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL29taXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9vbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9wYXJ0aWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcGFydGl0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcGljay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3BsdWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9wcm9wZXJ0eU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcmFuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9yZWR1Y2VSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3JlamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3Jlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9yZXN0QXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvcmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvc2FtcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvc2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy9zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvc29ydEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvc29ydGVkSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy90YXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3RlbXBsYXRlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3RpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvdG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3VuZGVyc2NvcmUtYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3VuZGVyc2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy91bmVzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3VuaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvdW5pcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3VuaXF1ZUlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvdW56aXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy93aGVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS9tb2R1bGVzL3dpdGhvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvbW9kdWxlcy93cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL21vZHVsZXMvemlwLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9mcmFtZXdvcmtzL2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9mcmFtZXdvcmtzL2pxdWVyeS51aS50b3VjaC1wdW5jaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvZnJhbWV3b3Jrcy9tdXRhdGUuZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9mcmFtZXdvcmtzL211dGF0ZS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2dyaWQtZWRpdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9sYW5ndWFnZS9ncmlkLWVuLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL0dyaWRBc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL0dyaWRDb2xsZWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL0dyaWRNb2RlbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi9HcmlkU3luYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL0dyaWRWaWV3cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL2NvbGxlY3Rpb25zL0dyaWRBdXRob3JzLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvY29sbGVjdGlvbnMvR3JpZEJveEJsdWVwcmludHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi9tb2RlbHMvR3JpZEF1dGhvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL21vZGVscy9HcmlkQm94Qmx1ZXByaW50LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvbW9kZWxzL0dyaWRSaWdodHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvYXV0b2NvbXBsZXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy9hdXRvY29tcGxldGVfd2l0aF9saW5rcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvY2hlY2tib3guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL2ZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL2hpZGRlbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL211bHRpLWF1dG9jb21wbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvbnVtYmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL3RleHRhcmVhLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy93cF9tZWRpYXNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0dyaWRBdXRob3JWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvR3JpZEF1dGhvcnNWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvR3JpZEJveEVkaXRvclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyaWQtZWRpdG9yL2xpYi92aWV3cy9HcmlkQ29udGFpbmVyRWRpdG9yVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0dyaWRSZXZpc2lvbnNWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvR3JpZFNsb3RTdHlsZUNoYW5nZXJWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvR3JpZFRvb2xCb3hCbHVlcHJpbnRzVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0dyaWRUb29sQm94VHlwZXNWaWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9ncmlkLWVkaXRvci9saWIvdmlld3MvR3JpZFRvb2xDb250YWluZXJzVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC1lZGl0b3IvbGliL3ZpZXdzL0dyaWRUb29sYmFyVmlldy5qcyIsIndlYnBhY2s6Ly8vd3MgKGlnbm9yZWQpIiwid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJkZWZpbmUiLCIkIiwiY291bnRlciIsImFqYXhUcmFuc3BvcnQiLCJvcHRpb25zIiwiYXN5bmMiLCJmb3JtIiwiaWZyYW1lIiwiYWRkUGFyYW1DaGFyIiwic2VuZCIsIl8iLCJjb21wbGV0ZUNhbGxiYWNrIiwiYXR0ciIsImZvcm1BY2NlcHRDaGFyc2V0IiwidGVzdCIsInVybCIsInR5cGUiLCJiaW5kIiwiZmlsZUlucHV0Q2xvbmVzIiwicGFyYW1OYW1lcyIsImlzQXJyYXkiLCJwYXJhbU5hbWUiLCJ1bmJpbmQiLCJyZXNwb25zZSIsImNvbnRlbnRzIiwibGVuZ3RoIiwiZmlyc3RDaGlsZCIsIkVycm9yIiwiZSIsInVuZGVmaW5lZCIsImFwcGVuZFRvIiwid2luZG93Iiwic2V0VGltZW91dCIsInJlbW92ZSIsInByb3AiLCJmb3JtRGF0YSIsImVhY2giLCJpbmRleCIsImZpZWxkIiwibmFtZSIsInZhbCIsInZhbHVlIiwiZmlsZUlucHV0IiwiY2xvbmUiLCJhZnRlciIsImFwcGVuZCIsInN1Ym1pdCIsImlucHV0IiwicmVwbGFjZVdpdGgiLCJkb2N1bWVudCIsImJvZHkiLCJhYm9ydCIsImNvbmNhdCIsImFqYXhTZXR1cCIsImNvbnZlcnRlcnMiLCJ0ZXh0IiwicGFyc2VKU09OIiwiaHRtbCIsInhtbERvYyIsImlzWE1MRG9jIiwicGFyc2VYTUwiLCJYTUxEb2N1bWVudCIsInhtbCIsImdsb2JhbEV2YWwiLCJzdXBwb3J0IiwidG91Y2giLCJtb3VzZVByb3RvIiwidWkiLCJtb3VzZSIsInByb3RvdHlwZSIsIl9tb3VzZUluaXQiLCJfbW91c2VEZXN0cm95IiwidG91Y2hIYW5kbGVkIiwic2ltdWxhdGVNb3VzZUV2ZW50IiwiZXZlbnQiLCJzaW11bGF0ZWRUeXBlIiwib3JpZ2luYWxFdmVudCIsInRvdWNoZXMiLCJwcmV2ZW50RGVmYXVsdCIsImNoYW5nZWRUb3VjaGVzIiwic2ltdWxhdGVkRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInRhcmdldCIsImRpc3BhdGNoRXZlbnQiLCJfdG91Y2hTdGFydCIsInNlbGYiLCJfbW91c2VDYXB0dXJlIiwiX3RvdWNoTW92ZWQiLCJfdG91Y2hNb3ZlIiwiX3RvdWNoRW5kIiwiZWxlbWVudCIsInRvdWNoc3RhcnQiLCJwcm94eSIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwiY2FsbCIsImpRdWVyeSIsIm11dGF0ZV9ldmVudF9zdGFjayIsImhhbmRsZXIiLCJlbGVtIiwibiIsImVsIiwiZGF0YSIsIndpZHRoIiwiaGVpZ2h0IiwiY3NzIiwiaXMiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJtdXRhdGUiLCJzcGVlZCIsImV2ZW50X3N0YWNrIiwic3RhY2siLCJldmVudHMiLCJhZGRfZXZlbnQiLCJldnQiLCJhZGQiLCJldmVudF9uYW1lIiwic2VsZWN0b3IiLCJjYWxsYmFjayIsImZhbHNlX2NhbGxiYWNrIiwicmVzZXQiLCJwYXJlbnQiLCJqIiwiayIsImkiLCJhIiwiYiIsImZuIiwiZXh0ZW5kIiwiYXJndW1lbnRzIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwic3BsaXQiLCJsYW5nX3ZhbHVlcyIsIm1ldGhvZCIsIm5vb3AiLCJtZXRob2RzIiwiY29uc29sZSIsIkdSSUQiLCIkYm9keSIsImRvbV9yb290IiwiJHJvb3QiLCJkb21fcm9vdF9lZGl0b3IiLCIkcm9vdF9lZGl0b3IiLCJkb21fcm9vdF9hdXRob3JzIiwiJHJvb3RfYXV0aG9ycyIsIklEIiwiREVCVUdHSU5HIiwiU0VSVkVSIiwiUFJFVklFV19VUkwiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiUFJFVklFV19QQVRURVJOIiwiZ3JpZCIsImdyaWRWaWV3IiwidHlwZXNfYm94IiwidHlwZXNfY29udGFpbmVyIiwicmV1c2FibGVfY29udGFpbmVycyIsInN0eWxlc19jb250YWluZXIiLCJzdHlsZXNfc2xvdCIsInN0eWxlc19ib3giLCJyZXZpc2lvbnMiLCJhdXRob3JzIiwiaW5pdCIsIl9pbml0Q29uc3RhbnRzIiwiJGxvYWRpbmciLCJpY2giLCJ0cGxfbG9hZGluZyIsImFkZENsYXNzIiwiZ2V0Qm94VHlwZXMiLCJmZXRjaCIsImdldENvbnRhaW5lclR5cGVzIiwiZ2V0UmV1c2FibGVDb250YWluZXJzIiwiZ2V0Q29udGFpbmVyU3R5bGVzIiwiZ2V0U2xvdFN0eWxlcyIsImdldEJveFN0eWxlcyIsIkdyaWRBc3luYyIsIkdyaWRBdXRob3JzIiwiYWRkT2JzZXJ2ZXIiLCJnZXRSaWdodHMiLCJzdWNjZXNzIiwiR3JpZCIsImlkIiwiZm5fc3VjY2VzcyIsIm5ld19ncmlkX3N1Y2Nlc3MiLCJvbiIsImFsdE1vZGlmaWNhdGlvbkNsYXNzIiwiYWx0S2V5IiwiaXNQcmVzc2VkIiwicmVtb3ZlQ2xhc3MiLCJyZWxvYWQiLCJkZXN0cm95IiwiZW1wdHkiLCJuZXdHcmlkIiwiZ3JpZHZpZXciLCJHcmlkVmlldyIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJsaXN0ZW5UbyIsIm9uUmlnaHRzIiwiZ2V0VmlldyIsInJlbmRlciIsIl9pbml0aWFsaXplQ29udGFpbmVyU29ydGFibGUiLCJfaW5pdGlhbGl6ZUJveFNvcnRhYmxlIiwiUmV2aXNpb25zIiwidG9vbGJhciIsIkdyaWRUb29sYmFyVmlldyIsInByZXBlbmQiLCJyZXNpemUiLCJvblJlc2l6ZSIsInRyaWdnZXIiLCJDb250YWluZXJUeXBlcyIsIlJldXNhYmxlQ29udGFpbmVycyIsIkJveFR5cGVzIiwiU3R5bGVzIiwicmlnaHRzIiwiR3JpZFJpZ2h0cyIsInNldFRvUmV2aXNpb24iLCJyZXZpc2lvbiIsImxvY2tlZCIsIkdyaWRSZXF1ZXN0IiwidXBkYXRlIiwiYWN0aW9uIiwibG9nIiwibW9kZSIsImdyaWRtb2RlIiwiZ3JpZF9kZWJ1Z19tb2RlIiwiZ3JpZGFqYXgiLCJyZXBsYWNlIiwicHJldmlld3VybCIsInByZXZpZXdwYXR0ZXJuIiwicHVibGlzaCIsImdldCIsImFsZXJ0IiwiR3JpZEFqYXgiLCJyZXZlcnQiLCJzdHJpbmciLCJzaG93RWRpdG9yIiwiYW5pbWF0ZSIsImhpZGUiLCJzaG93Iiwic2Nyb2xsVG8iLCJoaWRlRWRpdG9yIiwidG9nZ2xlQXV0aG9ycyIsIkF1dGhvcnMiLCIkZWwiLCJ0b2dnbGVDbGFzcyIsInNob3dBdXRob3JzIiwiaGlkZUF1dGhvcnMiLCJoYXZlTG9jayIsImFzeW5jX2xvY2tpbmdfaXNfbG9ja2VkIiwiaGFzQ2xhc3MiLCJhc3luY19kaXNjb25uZWN0IiwiY29udGFpbmVyX2RlbGV0ZWQiLCJjb250YWluZXIiLCJzb3J0YWJsZSIsImhhbmRsZSIsIml0ZW1zIiwicGxhY2Vob2xkZXIiLCJwdWxsUGxhY2Vob2xkZXIiLCJyZWZyZXNoUG9zaXRpb25zIiwiaGVscGVyIiwiY3Vyc29yQXQiLCJsZWZ0IiwiYm90dG9tIiwic3RhcnQiLCJvbGRfY29udGFpbmVyX2lkIiwiaXRlbSIsImRyb3BwYWJsZSIsImFjY2VwdCIsImhvdmVyQ2xhc3MiLCJkcm9wIiwiZ2V0Q29udGFpbmVycyIsInN0b3AiLCJjb250YWluZXJ2aWV3IiwibmV3SW5kZXgiLCJjb250YWluZXJtb2RlbCIsIm9sZEluZGV4IiwiaW5kZXhPZiIsIm1vdmUiLCJvbGRfYm94X2luZGV4Iiwib2xkX3Nsb3RfaWQiLCJuZXdfYm94X2luZGV4IiwibmV3X3Nsb3RfaWQiLCJuZXdfY29udGFpbmVyX2lkIiwiYm94X2RlbGV0ZWQiLCJib3hfZHVwbGljYXRlZCIsImZpbmQiLCJjb25uZWN0V2l0aCIsImZvcmNlUGxhY2Vob2xkZXJTaXplIiwiZGlzdGFuY2UiLCJ0b3AiLCJwYXJlbnRzIiwib3ZlciIsIm91dCIsImJveCIsImdldFNsb3RzIiwiZ2V0Qm94IiwiZHVwbGljYXRlQm94IiwiYmVmb3JlU3RvcCIsIm5ld19zbG90IiwibW92ZUJveCIsImZsYXNoIiwiZmFkZUluIiwiZmFkZU91dCIsInN0YXJ0TG9hZGluZyIsImNsZWFyVGltZW91dCIsImxvYWRpbmdfaGlkZV90aW1lb3V0IiwiZmluaXNoTG9hZGluZyIsImRvbWFpbiIsInBhdGgiLCJhdXRob3IiLCJ0aW1lb3V0Iiwib2JzZXJ2ZXJzIiwiYnJvd3Nlcl9pZGVudGlmaWVyIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInNldEl0ZW0iLCJsYXN0X3RpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIl9vbklkbGVJbnRlcnZhbCIsInRpbWUiLCJkaWZmIiwiaWRsZV9pbnRlcnZhbCIsInNldEludGVydmFsIiwiX29uQWN0aXZpdHkiLCJzZXJ2aWNlIiwic29ja2V0IiwiaW8iLCJpbml0RXZlbnRzIiwib2JzZXJ2ZXIiLCJwdXNoIiwicmVtb3ZlT2JzZXJ2ZXIiLCJ3aXRob3V0Iiwibm90aWZ5QWxsIiwiX2V2ZW50IiwiX29ic2VydmVyIiwibGlzdCIsImYiLCJjb25uZWN0IiwiYXV0aG9yc19qb2luIiwiZGlzY29ubmVjdCIsImVtaXQiLCJpZGVudGl0eSIsImxvY2tpbmdfcmVxdWVzdF9sb2NrIiwibG9ja2luZ19oYW5kb3ZlciIsImlkZW50aWZpZXIiLCJzZXQiLCJsb2NraW5nX2RlbnlfaGFuZG92ZXIiLCJhdXRob3JzX2xpc3QiLCJhdXRob3JzX2pvaW5lZCIsImF1dGhvcnNfbGVmdCIsImF1dGhvcnNfbXVsdGloaXQiLCJjb3VudCIsImxvY2tpbmdfaXNfbG9ja2VkIiwicmVzZXRMb2NrIiwiaXNMb2NrZWQiLCJzZXRMb2NrIiwibG9ja2luZ19sb2NrX3JlcXVlc3RlZCIsIkdyaWRBdXRob3IiLCJfcGluZ190aW1lb3V0IiwicGluZ19zZW5kIiwiR3JpZEJhY2tib25lIiwiQ29sbGVjdGlvbiIsIlJldmlzaW9uIiwiaW5pdGlhbGl6ZSIsInNwZWMiLCJnZXRHcmlkSUQiLCJzeW5jIiwiY29sbGVjdGlvbiIsIkNvbnRhaW5lclR5cGUiLCJjb250YWluZXJ0eXBlcyIsInJldXNhYmxlY29udGFpbmVycyIsIkJveFR5cGUiLCJib3h0eXBlcyIsIlN0eWxlVHlwZSIsInN0eWxlcyIsIkNvbnRhaW5lcnMiLCJDb250YWluZXIiLCJ0b19pbmRleCIsImF0IiwiU2xvdHMiLCJTbG90IiwiQm94ZXMiLCJCb3giLCJNb2RlbCIsImdldERpbWVuc2lvbiIsImRpbWVuc2lvbiIsImtleSIsImdldFR5cGUiLCJkZWZhdWx0cyIsImNyaXRlcmlhIiwiYmx1ZXByaW50cyIsImdldEJsdWVwcmludHMiLCJHcmlkQm94Qmx1ZXByaW50cyIsInNlYXJjaEJveGVzIiwic2VhcmNoU3RyaW5nIiwic2VhcmNoIiwicXVlcnkiLCJpc0RyYWZ0IiwiY3JlYXRlQ29udGFpbmVyIiwicmV1c2VkIiwic2F2ZSIsImFkZENvbnRhaW5lciIsImVycm9yIiwiYXJncyIsImFkZFJldXNlQ29udGFpbmVyIiwiY29udGFpbmVydHlwZSIsInJlc3VsdCIsImdldENvbnRhaW5lciIsImdldFNsb3QiLCJnZXRCb3hlcyIsImFkZEJveCIsInRvSW5kZXgiLCJjcmVhdGUiLCJzZXREdXBsaWNhdGVkIiwiY2hlY2tJc0RyYWZ0IiwicmVhZCIsImdldEdyaWQiLCJzZXRTbG90cyIsInNsb3RzIiwiZ2V0U3BhY2UiLCJzaWRlIiwic3BhY2UiLCJzcGFjZV9hcnIiLCJnZXRJbmRleCIsInNsb3RzX2FycmF5Iiwic2xvdHNfZGltZW5zaW9uIiwic2xvdCIsImFkZFNsb3QiLCJib3hlcyIsImNyZWF0ZUJveCIsImJsdWVwcmludCIsImpzb24iLCJ0b0pTT04iLCJ1bnNldER1cGxpY2F0ZWQiLCJ1bnNldCIsImlzRHVwbGljYXRlZCIsImR1cGxpY2F0ZSIsInBhcmFtc19hcnJheSIsInNldHRpbmdzIiwiZGF0YVR5cGUiLCJjb250ZW50VHlwZSIsImpxWEhSIiwidGV4dFN0YXR1cyIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsImVycm9yX2ZuIiwiYmVmb3JlU2VuZCIsInN1Y2Nlc3NfZm4iLCJKU09OIiwic3RyaW5naWZ5Iiwid2FpdCIsImFqYXgiLCJhdHRyaWJ1dGVzIiwicmV2ZXJ0ZWQiLCJwYXJhbXMiLCJwYWdlIiwibmV4dHBhZ2UiLCJib3h0eXBlIiwiYm94Ymx1ZXByaW50cyIsIkdyaWRCb3hCbHVlcHJpbnQiLCJzdHlsZSIsInNwYWNlX3RvX3JpZ2h0Iiwic3BhY2VfdG9fbGVmdCIsInJldXNldGl0bGUiLCJjb2xsZWN0aW9uX3Nsb3RzIiwiY2xhc3NlcyIsIm9wdGlvbiIsImNvbnRlbnRzdHJ1Y3R1cmUiLCJWaWV3IiwidGFnTmFtZSIsImNsYXNzTmFtZSIsIl9jb250YWluZXJzVmlldyIsIkNvbnRhaW5lcnNWaWV3IiwidHBsX2dyaWQiLCJyZW5kZXJDb250YWluZXJzIiwiQ29udGFpbmVyVmlldyIsImxpc3Rlbl90byIsIl9zbG90c1ZpZXciLCJTbG90c1ZpZXciLCJjaWQiLCJjdXQiLCJ0aXRsZSIsInRpdGxlX3Nob3J0IiwicHJvbG9nIiwicHJvbG9nX3Nob3J0IiwiZXBpbG9nIiwiZXBpbG9nX3Nob3J0IiwicmlnaHRfZWRpdCIsInJpZ2h0X2RlbGV0ZSIsInJpZ2h0X29wdGlvbnMiLCJyaWdodF9tb3ZlIiwiaXNTaWRlYmFyIiwic3RhcnRzV2l0aCIsInRwbF9jb250YWluZXIiLCIkc2xvdHNfd3JhcHBlciIsIm9uRWRpdCIsImVkaXRvciIsIkdyaWRDb250YWluZXJFZGl0b3IiLCJzYXZlRWRpdG9yIiwiZGVidWciLCIkdGhpcyIsInNjb3BlIiwib25SZXVzZSIsInByb21wdCIsIm9uVG9nZ2xlU2xvdFN0eWxlcyIsInNlbGZkZXN0cnVjdCIsInNsb3R2aWV3IiwiU2xvdFZpZXciLCJfcGFyZW50VmlldyIsIl9ib3hlc1ZpZXciLCJCb3hlc1ZpZXciLCJfc2xvdFN0eWxlQ2hhbmdlclZpZXciLCJHcmlkU2xvdFN0eWxlQ2hhbmdlclZpZXciLCJ0cGxfc2xvdCIsImRlbGVnYXRlRXZlbnRzIiwiYm94dmlldyIsIkJveFZpZXciLCJyZWZlcmVuY2UiLCJyaWdodF9jcmVhdGUiLCJyaWdodF9ub25lIiwiU0NSSVBUX1JFR0VYIiwidHBsX2JveCIsImVkaXQiLCJCb3hFZGl0b3IiLCJkZWxldGVCb3giLCJzbHVnIiwic2VsZWN0ZWQiLCJ0cGxfYm94ZWRpdG9yIiwiZmllbGRjb250YWluZXIiLCJ2aWV3cyIsInZpZXciLCJib3hFZGl0b3JDb250cm9scyIsInN0cnVjdHVyZSIsInBhcmVudHBhdGgiLCJDS0VESVRPUiIsImN1c3RvbUNvbmZpZyIsIlBhdGhUb0NvbmZpZyIsIm9uQ2FuY2VsIiwiaGlkZUJveEVkaXRvciIsIm9uVG9nZ2xlIiwic2libGluZ3MiLCJzbGlkZVRvZ2dsZSIsIm9uTWFrZVJldXNhYmxlIiwiY29uZmlybSIsIm9uU2F2ZSIsIm9iaiIsImZldGNoVmFsdWUiLCJpbnN0YW5jZXMiLCJnZXREYXRhIiwiYXN5bmNfYXV0aG9yc19saXN0IiwiZmluZFdoZXJlIiwiaGFzX2xvY2siLCJnZXRDb3VudCIsImFzeW5jX2F1dGhvcnNfam9pbmVkIiwiYXN5bmNfYXV0aG9yc19sZWZ0IiwicmVxdWVzdF9sb2NrIiwiY29udGVudCIsInNldE5vUmlnaHRzIiwibG9nUmlnaHRzIiwiaGFzSFRNTEVkaXRvciIsImdldEhUTUxFZGl0b3IiLCJpbml0SFRNTEVkaXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibGFiZWwiLCJyZWFkb25seSIsImtleV92YWx1ZSIsImtleXVwIiwid2hpY2giLCJzZWxlY3RJdGVtIiwiZmlyc3QiLCJzZWFyY2hpbmciLCJkb1NlYXJjaCIsIiRpdGVtIiwibGlzdEl0ZW1TZWxlY3RlZCIsImNhbmNlbFNlbGVjdGlvbiIsInJlbW92ZUF0dHIiLCJvbGRfc2VhcmNoX3N0cmluZyIsImVtcHR5dXJsIiwiZW1wdHlsaW5rdGV4dCIsImxpbmt0ZXh0IiwiJGxpbmtVcmwiLCIkaW5wdXQiLCJjaGVja2VkIiwiJHVwbG9hZF9mb3JtX2l0ZW0iLCIkcHJldmlldyIsIiRmaWxlX2lucHV0IiwiZmlkIiwiJGtleV9maWVsZCIsIiRwcm9ncmVzc19kaXNwbGF5IiwiJHByb2dyZXNzX2Jhcl93cmFwcGVyIiwiJHByb2dyZXNzX2Jhcl9zdGF0dXMiLCJjaGlsZHJlbiIsImdldEZpbGVDaG9vc2VIZWxwIiwiZ2V0RmlsZVJlcGxhY2VIZWxwIiwiZmlsZXVwbG9hZCIsInVwbG9hZHBhdGgiLCJkb25lIiwidXBsb2FkRG9uZSIsImxvYWRQcmV2aWV3IiwicHJvZ3Jlc3NhbGwiLCJhbHdheXMiLCJnZXRGb3JtRGF0YSIsImZpbGVpZCIsInNyYyIsImVsZW1lbnRfa2V5IiwiZ3JpZGlkIiwicGVyY2VudCIsImxvYWRlZCIsInRvdGFsIiwicm91bmQiLCJmaWxlUmVwbGFjZW1lbnRIZWxwIiwiZmlsZUNob29zZUhlbHAiLCJxdWVyeVNlbGVjdG9yIiwidGhlbiIsImlucHV0VHlwZSIsIiRsaXN0Iiwib25BZGQiLCJzb3J0SXRlbSIsIm9uUmVtb3ZlIiwiJGJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJjbG9zZXN0IiwibmV3UG9zIiwiaW5zZXJ0QmVmb3JlIiwicHJldiIsImluc2VydEFmdGVyIiwibmV4dCIsInNwbGljZSIsInJlbW92ZWQiLCJjbGljayIsImlzTXVsdGlwbGUiLCJtdWx0aXBsZSIsInZhbHVlcyIsImhhc011bHRpcGxlVmFsdWVzIiwic2VsZWN0aW9ucyIsInNpemUiLCJjX3ZhbCIsIm1lZGlhX3R5cGUiLCIkaW1nX3dyYXBwZXIiLCIkdXBsb2FkX2J0biIsIiRzZWxlY3RfaW1hZ2Vfc2l6ZSIsInBhcnNlIiwiYnVpbGRJbWFnZVNpemVTZWxlY3QiLCJidWlsZEltYWdlUHJldmlldyIsIm9wZW5fd3BfbWVkaWEiLCJmcmFtZSIsIndwIiwibWVkaWEiLCJsaWJyYXJ5IiwiYnV0dG9uIiwic2VsZWN0aW9uIiwic3RhdGUiLCJhdHRhY2htZW50IiwiX2J5SWQiLCJzaXplcyIsImZ1bGwiLCJvcmllbnRhdGlvbiIsInJfanNvbiIsIm9wZW4iLCJnZXRfanNvbl9mcm9tX2lucHV0IiwidGh1bWJuYWlsIiwiJGltZyIsIkF1dGhvciIsIm9uUmVxdWVzdExvY2siLCJoYXZlX2xvY2siLCJ0cGxfYXV0aG9yIiwib25DbGlja1NlbmRMb2NrIiwib25DbGlja1JlcXVlc3RMb2NrIiwib25BZGRBdXRob3IiLCJ0cGxfYXV0aG9ycyIsInByb2xvZ0VkaXRvciIsImVwaWxvZ0VkaXRvciIsIiR1cmwiLCJvblVybFRvZ2dsZSIsIiRwYXJlbnQiLCJ0cGxfY29udGFpbmVyZWRpdG9yIiwiY2xhc3NfcHJlZml4IiwiR3JpZFJldmlzaW9uc1ZpZXciLCJpbnRlcnZhbCIsIm9uUmV2aXNpb25zU2Nyb2xsIiwiaXNQdWJsaXNoZWQiLCJpc0RlcHJlY2F0ZWQiLCJkYXRlIiwicGFyc2VJbnQiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJ0cGxfcmV2aXNpb25zIiwiY2hpbGRfY291bnQiLCJsaXN0X3dpZHRoIiwibGFzdCIsIm91dGVyV2lkdGgiLCJhYnMiLCJwb3NpdGlvbiIsIm9uUHJldmlldyIsIiRyZXZpc2lvbiIsInRvZ2dsZSIsIm9uRGVsZXRlIiwib25SZXZlcnQiLCJhY3RpdmVzdHlsZSIsInRwbF9zbG90c3R5bGVjaGFuZ2VyIiwiY2hhbmdlU3R5bGUiLCJHcmlkVG9vbEJveEJsdWVwcmludHNWaWV3IiwidGltZXIiLCJib3hfdHlwZSIsImFkZEJsdWVwcmludEJveCIsIiRfc2VhcmNoIiwiJGJsdWVwcmludHNsaXN0IiwicmV1c2FibGUiLCJ0cGxfdG9vbEJveGVzQmx1ZXByaW50IiwiaW5pdGlhbGl6ZXNEcmFnZ2FibGUiLCJzdG9wTGlzdGVuaW5nIiwiZHJhZ2dhYmxlIiwiekluZGV4IiwiJHNsb3RzIiwiYmVmb3JlIiwiY3JlYXRlRWxlbWVudCIsIiR0aGlzX2JveCIsIiR0aGlzX2Ryb3AiLCIkdGhpc19zbG90IiwiJHRoaXNfY29udGFpbmVyIiwiJG5ld19ib3giLCJHcmlkVG9vbEJveFR5cGVzVmlldyIsImJveHR5cGVfanNvbiIsInRwbF90b29sQm94ZXMiLCJ0b2dnbGVCb3hUeXBlIiwiYmx1ZXByaW50c192aWV3IiwiR3JpZFRvb2xDb250YWluZXJzVmlldyIsInRwbF90b29sQ29udGFpbmVycyIsInJlbmRlckNvbnRhaW5lclR5cGUiLCIkdHlwZSIsInJvbGUiLCJyZXVzYWJsZXMiLCJnZXRSZXVzYWJsZSIsImdldFJlbmRlcmVkQ29udGFpbmVyTGlzdCIsImNvbnRhaW5lcnMiLCJ0cGxfdG9vbENvbnRhaW5lcnNDb250YWluZXIiLCJzY29wZV90eXBlIiwibnVtc2xvdHMiLCJzY3JvbGwiLCIkZ3JpZCIsIiRjb250YWluZXJzIiwiJGRyb3BBcmVhIiwiJGRyYWdnYWJsZSIsImNvbnRhaW5lclJldXNhYmxlIiwiY29udGFpbmVyVHlwZSIsIiRkcm9wd3JhcHBlciIsIm5ld19pbmRleCIsIl90b29sQ29udGFpbmVyc1ZpZXciLCJfdG9vbEJveGVzVmlldyIsIl9yZXZpc2lvbnNWaWV3Iiwic2V0U3RhdGUiLCJvblVwZGF0ZUF1dGhvcnMiLCJ0cGxfdG9vbGJhciIsIiR0b29sYmFyIiwiJHRvb2xfZWxlbWVudHMiLCIkdG9vbF9lbGVtZW50X2NvbnRlbnQiLCIkdGFiX2NvbnRhaW5lciIsIiR0YWJfYm94IiwiJGVsZW1lbnRfdHJhc2giLCIkYXV0aG9yc19jb3VudCIsInNob3dDb250YWluZXJUb29scyIsInNob3dCb3hUb29scyIsInByZXZpZXciLCJ0b2dnbGVCb3hlcyIsImdldFRvb2xDb250YWluZXJzVmlldyIsImNvbnRhaW5lclRvb2xzVmlzaWJsZSIsInRvZ2dsZUNvbnRhaW5lclRvb2xzIiwiaGlkZUJveFRvb2xzIiwiaGlkZUNvbnRhaW5lclRvb2xzIiwiZ2V0VG9vbEJveGVzVmlldyIsImJveFRvb2xzVmlzaWJsZSIsInRvZ2dsZUJveFRvb2xzIiwid2luZG93X2hlaWdodCIsImVsZW1lbnRzX3RvcF9vZmZzZXQiLCJvZmZzZXQiLCJ0YWJfaGVpZ2h0Iiwib3V0ZXJIZWlnaHQiLCJvbkNsaWNrQXV0aG9ycyIsImFzeW5jX3JlcXVlc3RfbG9jayJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixzQ0FBc0M7O0FBRWhFLGtCQUFrQixnQkFBZ0I7QUFDbEMsZ0JBQWdCLGNBQWM7QUFDOUIsb0JBQW9CLGFBQWE7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxpQ0FBTyxDQUFDLHVGQUFZLEVBQUUsOENBQVEsRUFBRSxPQUFTLENBQUMsbUNBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUFBLG9HQUFDOztBQUVOO0FBQ0EsR0FBRyxNQUFNLGFBUU47O0FBRUgsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUIsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsZ0ZBQWdGO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQSxpREFBaUQsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixZQUFZOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUseUVBQXlFO0FBQ3pFLDZFQUE2RTtBQUM3RSxpRkFBaUY7QUFDakYsNkVBQTZFO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkI7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUMsY0FBYztBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLHNDQUFzQztBQUMvRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDOWlFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDMURXOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3JrREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsb0VBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyT0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFvQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsNEVBQVc7QUFDakMsY0FBYyxtQkFBTyxDQUFDLGtHQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsb0VBQW1CO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxnRkFBTztBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQ7QUFDM0Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStIO0FBQy9IO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnR0FBZ0c7QUFDaEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDamFBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN0QyxjQUFjLG1CQUFPLENBQUMsOEVBQVM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHdFQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMsb0VBQW1CO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0ZBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDbkQsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN0QyxhQUFhLG1CQUFPLENBQUMsd0VBQWtCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsb0VBQW1CO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0ZBQU87O0FBRTNCOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsV0FBSTtBQUNoQyxHQUFHLFlBQVk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxU0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFjOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUE2QjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixtQkFBTyxDQUFDLGdGQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqTkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxnREFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLEVBQUU7O0FBRUY7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGtDQUFrQztBQUMzQztBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7Ozs7OztBQzV0QkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RCxLQUFLO0FBQ0wsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUF3Qix3REFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFBQTtBQUFBO0FBQ2U7QUFDZjtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUNsQjs7Ozs7Ozs7Ozs7OztBQ2pCM0I7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDTjs7QUFFbkM7QUFDQSxRQUFRLHVEQUFLLENBQUMsc0NBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ2UsZ0VBQUMsRUFBQzs7Ozs7Ozs7Ozs7OztBQzFCakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0M7QUFDd0I7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDb0Q7QUFDSjtBQUNVO0FBQ0o7QUFDQTtBQUNGO0FBQ0E7QUFDSjtBQUNJO0FBQ0Y7QUFDRTtBQUNOO0FBQ1E7QUFDUjtBQUNRO0FBQ1E7QUFDTjtBQUNOO0FBQ007QUFDRTtBQUNOO0FBQ047QUFDYztBQUNWO0FBQ0E7QUFDQTs7QUFFbEQ7QUFDNEM7QUFDTTtBQUNGO0FBQ0Y7QUFDRTtBQUVNO0FBQ047QUFFTTtBQUNGO0FBQ0o7QUFDRjtBQUNKO0FBQ0E7QUFDWTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRDtBQUNBO0FBQ1I7QUFDUTtBQUNJO0FBRU47QUFDSjtBQUNFO0FBQ047QUFDTTtBQUNJO0FBQ2dCO0FBQ2hCO0FBQ0o7QUFDSTtBQUNOO0FBQ007O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ2tEO0FBQ047QUFDTTtBQUNBO0FBQ0o7QUFDQTtBQUNNO0FBQ0E7QUFDUjtBQUNJO0FBQ0U7QUFDSjtBQUNFO0FBQ0o7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ2tEO0FBQ0k7QUFDUTtBQUNKO0FBQ1I7QUFDUTtBQUVaO0FBQ1E7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RUFBK0I7QUFDM0IsV0FBS3FOLGNBQUwsQ0FBb0JoZSxPQUFwQixDQUE0QixJQUE1QixFQUFrQ3JELElBQWxDO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsV0FBS3FoQixjQUFMLENBQW9CaGUsT0FBcEIsQ0FBNEIsSUFBNUIsRUFBa0NwRCxJQUFsQztBQUNBLFdBQUtvaEIsY0FBTCxDQUFvQnJ0QixJQUFwQixDQUF5QjJGLElBQUksQ0FBQ3dCLE9BQUwsQ0FBYTZZLFFBQWIsRUFBekI7QUFDSDs7QUFDRCxTQUFLK00sUUFBTCxDQUFjamtCLFdBQWQsQ0FBMEIsb0JBQTFCO0FBQ0EsUUFBSTNHLElBQUksR0FBRyxJQUFYO0FBQ0F3RCxRQUFJLENBQUN3QixPQUFMLENBQWF0SSxJQUFiLENBQWtCLFVBQVMyUixNQUFULEVBQWdCO0FBQzlCLFVBQUdBLE1BQU0sQ0FBQy9FLEdBQVAsQ0FBVyxjQUFYLENBQUgsRUFBOEI7QUFDMUJ0SixZQUFJLENBQUM0cUIsUUFBTCxDQUFjdGxCLFFBQWQsQ0FBdUIsb0JBQXZCO0FBQ0g7QUFDSixLQUpEO0FBS0gsR0FyTDZDO0FBc0w5QzhtQixnQkFBYyxFQUFFLHdCQUFTbHdCLENBQVQsRUFBVztBQUN2QnNILFFBQUksQ0FBQ3lHLGFBQUw7QUFDQSxTQUFLMmdCLFFBQUwsQ0FBY2prQixXQUFkLENBQTBCLG9CQUExQjtBQUNILEdBekw2Qzs7QUEwTDlDO0FBQ0o7QUFDQTtBQUNJMGxCLG9CQUFrQixFQUFFLDhCQUFVO0FBQzFCLFNBQUt6QixRQUFMLENBQWN0bEIsUUFBZCxDQUF1QixvQkFBdkI7QUFDSDtBQS9MNkMsQ0FBekIsQ0FBekIsQzs7Ozs7Ozs7Ozs7QUNWQSxlOzs7Ozs7Ozs7OztBQ0FBLHdCIiwiZmlsZSI6ImdyaWQtZWRpdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvZ3JpZC1lZGl0b3IvZ3JpZC1lZGl0b3IuanNcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCIvLyAgICAgQmFja2JvbmUuanMgMS40LjBcblxuLy8gICAgIChjKSAyMDEwLTIwMTkgSmVyZW15IEFzaGtlbmFzIGFuZCBEb2N1bWVudENsb3VkXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICAvLyBXZSB1c2UgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHxcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbDtcblxuICAvLyBTZXQgdXAgQmFja2JvbmUgYXBwcm9wcmlhdGVseSBmb3IgdGhlIGVudmlyb25tZW50LiBTdGFydCB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xuICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICB9KTtcblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksICQ7XG4gICAgdHJ5IHsgJCA9IHJlcXVpcmUoJ2pxdWVyeScpOyB9IGNhdGNoIChlKSB7fVxuICAgIGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG5cbiAgLy8gRmluYWxseSwgYXMgYSBicm93c2VyIGdsb2JhbC5cbiAgfSBlbHNlIHtcbiAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5fLCByb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKTtcbiAgfVxuXG59KShmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYSBjb21tb24gYXJyYXkgbWV0aG9kIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LiBLZWVwIGluIHN5bmMgd2l0aCBgcGFja2FnZS5qc29uYC5cbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjQuMCc7XG5cbiAgLy8gRm9yIEJhY2tib25lJ3MgcHVycG9zZXMsIGpRdWVyeSwgWmVwdG8sIEVuZGVyLCBvciBNeSBMaWJyYXJ5IChraWRkaW5nKSBvd25zXG4gIC8vIHRoZSBgJGAgdmFyaWFibGUuXG4gIEJhY2tib25lLiQgPSAkO1xuXG4gIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxuICAvLyB0byBpdHMgcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBCYWNrYm9uZSBvYmplY3QuXG4gIEJhY2tib25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSFRUUGAgdG8gc3VwcG9ydCBsZWdhY3kgSFRUUCBzZXJ2ZXJzLiBTZXR0aW5nIHRoaXMgb3B0aW9uXG4gIC8vIHdpbGwgZmFrZSBgXCJQQVRDSFwiYCwgYFwiUFVUXCJgIGFuZCBgXCJERUxFVEVcImAgcmVxdWVzdHMgdmlhIHRoZSBgX21ldGhvZGAgcGFyYW1ldGVyIGFuZFxuICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICBCYWNrYm9uZS5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxuICAvLyBgYXBwbGljYXRpb24vanNvbmAgcmVxdWVzdHMgLi4uIHRoaXMgd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBhIGN1c3RvbSBldmVudCBjaGFubmVsLiBZb3UgbWF5IGJpbmQgYSBjYWxsYmFjayB0byBhbiBldmVudCB3aXRoIGBvbmAgb3JcbiAgLy8gcmVtb3ZlIHdpdGggYG9mZmA7IGB0cmlnZ2VyYC1pbmcgYW4gZXZlbnQgZmlyZXMgYWxsIGNhbGxiYWNrcyBpblxuICAvLyBzdWNjZXNzaW9uLlxuICAvL1xuICAvLyAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAvLyAgICAgXy5leHRlbmQob2JqZWN0LCBCYWNrYm9uZS5FdmVudHMpO1xuICAvLyAgICAgb2JqZWN0Lm9uKCdleHBhbmQnLCBmdW5jdGlvbigpeyBhbGVydCgnZXhwYW5kZWQnKTsgfSk7XG4gIC8vICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7XG4gIC8vXG4gIHZhciBFdmVudHMgPSBCYWNrYm9uZS5FdmVudHMgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBBIHByaXZhdGUgZ2xvYmFsIHZhcmlhYmxlIHRvIHNoYXJlIGJldHdlZW4gbGlzdGVuZXJzIGFuZCBsaXN0ZW5lZXMuXG4gIHZhciBfbGlzdGVuaW5nO1xuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGBcImNoYW5nZSBibHVyXCIsIGNhbGxiYWNrYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50XG4gIC8vIG1hcHMgYHtldmVudDogY2FsbGJhY2t9YCkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG4gICAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdm9pZCAwICYmICdjb250ZXh0JyBpbiBvcHRzICYmIG9wdHMuY29udGV4dCA9PT0gdm9pZCAwKSBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgIGZvciAobmFtZXMgPSBfLmtleXMobmFtZSk7IGkgPCBuYW1lcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzQXBpKGl0ZXJhdGVlLCBldmVudHMsIG5hbWVzW2ldLCBuYW1lW25hbWVzW2ldXSwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICYmIGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgLy8gSGFuZGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lcyBieSBkZWxlZ2F0aW5nIHRoZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgZm9yIChuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWVzW2ldLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmFsbHksIHN0YW5kYXJkIGV2ZW50cy5cbiAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgLy8gdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzQXBpKG9uQXBpLCB0aGlzLl9ldmVudHMgfHwge30sIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgY3R4OiB0aGlzLFxuICAgICAgbGlzdGVuaW5nOiBfbGlzdGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAoX2xpc3RlbmluZykge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0ge30pO1xuICAgICAgbGlzdGVuZXJzW19saXN0ZW5pbmcuaWRdID0gX2xpc3RlbmluZztcbiAgICAgIC8vIEFsbG93IHRoZSBsaXN0ZW5pbmcgdG8gdXNlIGEgY291bnRlciwgaW5zdGVhZCBvZiB0cmFja2luZ1xuICAgICAgLy8gY2FsbGJhY2tzIGZvciBsaWJyYXJ5IGludGVyb3BcbiAgICAgIF9saXN0ZW5pbmcuaW50ZXJvcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmAuIFRlbGwgKnRoaXMqIG9iamVjdCB0byBsaXN0ZW4gdG9cbiAgLy8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3MgbGlzdGVuaW5nIHRvXG4gIC8vIGZvciBlYXNpZXIgdW5iaW5kaW5nIGxhdGVyLlxuICBFdmVudHMubGlzdGVuVG8gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICB2YXIgbGlzdGVuaW5nID0gX2xpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIG5vdCBsaXN0ZW5pbmcgdG8gYW55IG90aGVyIGV2ZW50cyBvbiBgb2JqYCB5ZXQuXG4gICAgLy8gU2V0dXAgdGhlIG5lY2Vzc2FyeSByZWZlcmVuY2VzIHRvIHRyYWNrIHRoZSBsaXN0ZW5pbmcgY2FsbGJhY2tzLlxuICAgIGlmICghbGlzdGVuaW5nKSB7XG4gICAgICB0aGlzLl9saXN0ZW5JZCB8fCAodGhpcy5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nID0gX2xpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXSA9IG5ldyBMaXN0ZW5pbmcodGhpcywgb2JqKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIGNhbGxiYWNrcyBvbiBvYmouXG4gICAgdmFyIGVycm9yID0gdHJ5Q2F0Y2hPbihvYmosIG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICBfbGlzdGVuaW5nID0gdm9pZCAwO1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAvLyBJZiB0aGUgdGFyZ2V0IG9iaiBpcyBub3QgQmFja2JvbmUuRXZlbnRzLCB0cmFjayBldmVudHMgbWFudWFsbHkuXG4gICAgaWYgKGxpc3RlbmluZy5pbnRlcm9wKSBsaXN0ZW5pbmcub24obmFtZSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IGFkZHMgYSBjYWxsYmFjayB0byB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb25BcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV0gfHwgKGV2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBjdHggPSBvcHRpb25zLmN0eCwgbGlzdGVuaW5nID0gb3B0aW9ucy5saXN0ZW5pbmc7XG4gICAgICBpZiAobGlzdGVuaW5nKSBsaXN0ZW5pbmcuY291bnQrKztcblxuICAgICAgaGFuZGxlcnMucHVzaCh7Y2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBjdHg6IGNvbnRleHQgfHwgY3R4LCBsaXN0ZW5pbmc6IGxpc3RlbmluZ30pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEFuIHRyeS1jYXRjaCBndWFyZGVkICNvbiBmdW5jdGlvbiwgdG8gcHJldmVudCBwb2lzb25pbmcgdGhlIGdsb2JhbFxuICAvLyBgX2xpc3RlbmluZ2AgdmFyaWFibGUuXG4gIHZhciB0cnlDYXRjaE9uID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICBvYmoub24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZW1vdmUgb25lIG9yIG1hbnkgY2FsbGJhY2tzLiBJZiBgY29udGV4dGAgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgLy8gY2FsbGJhY2tzIHdpdGggdGhhdCBmdW5jdGlvbi4gSWYgYGNhbGxiYWNrYCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gIC8vIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cy5cbiAgRXZlbnRzLm9mZiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBsaXN0ZW5lcnM6IHRoaXMuX2xpc3RlbmVyc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGVsbCB0aGlzIG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBlaXRoZXIgc3BlY2lmaWMgZXZlbnRzIC4uLiBvclxuICAvLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxuICBFdmVudHMuc3RvcExpc3RlbmluZyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICBpZiAoIWxpc3RlbmluZ1RvKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBpZHMgPSBvYmogPyBbb2JqLl9saXN0ZW5JZF0gOiBfLmtleXMobGlzdGVuaW5nVG8pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRzW2ldXTtcblxuICAgICAgLy8gSWYgbGlzdGVuaW5nIGRvZXNuJ3QgZXhpc3QsIHRoaXMgb2JqZWN0IGlzIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIGxpc3RlbmluZyB0byBvYmouIEJyZWFrIG91dCBlYXJseS5cbiAgICAgIGlmICghbGlzdGVuaW5nKSBicmVhaztcblxuICAgICAgbGlzdGVuaW5nLm9iai5vZmYobmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgaWYgKGxpc3RlbmluZy5pbnRlcm9wKSBsaXN0ZW5pbmcub2ZmKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKF8uaXNFbXB0eShsaXN0ZW5pbmdUbykpIHRoaXMuX2xpc3RlbmluZ1RvID0gdm9pZCAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IHJlbW92ZXMgYSBjYWxsYmFjayBmcm9tIHRoZSBgZXZlbnRzYCBvYmplY3QuXG4gIHZhciBvZmZBcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFldmVudHMpIHJldHVybjtcblxuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBsaXN0ZW5lcnMgPSBvcHRpb25zLmxpc3RlbmVycztcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuXG4gICAgLy8gRGVsZXRlIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIFwiZHJvcFwiIGV2ZW50cy5cbiAgICBpZiAoIW5hbWUgJiYgIWNvbnRleHQgJiYgIWNhbGxiYWNrKSB7XG4gICAgICBmb3IgKG5hbWVzID0gXy5rZXlzKGxpc3RlbmVycyk7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbbmFtZXNbaV1dLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoZXZlbnRzKTtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZXJlIGFyZSBubyBldmVudHMgc3RvcmVkLlxuICAgICAgaWYgKCFoYW5kbGVycykgYnJlYWs7XG5cbiAgICAgIC8vIEZpbmQgYW55IHJlbWFpbmluZyBldmVudHMuXG4gICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbal07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjayAmJlxuICAgICAgICAgICAgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2suX2NhbGxiYWNrIHx8XG4gICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dCAhPT0gaGFuZGxlci5jb250ZXh0XG4gICAgICAgICkge1xuICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsaXN0ZW5pbmcgPSBoYW5kbGVyLmxpc3RlbmluZztcbiAgICAgICAgICBpZiAobGlzdGVuaW5nKSBsaXN0ZW5pbmcub2ZmKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXBsYWNlIGV2ZW50cyBpZiB0aGVyZSBhcmUgYW55IHJlbWFpbmluZy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICBldmVudHNbbmFtZV0gPSByZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAvLyB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCwgaXRzIGxpc3RlbmVyIHdpbGwgYmUgcmVtb3ZlZC4gSWYgbXVsdGlwbGUgZXZlbnRzXG4gIC8vIGFyZSBwYXNzZWQgaW4gdXNpbmcgdGhlIHNwYWNlLXNlcGFyYXRlZCBzeW50YXgsIHRoZSBoYW5kbGVyIHdpbGwgZmlyZVxuICAvLyBvbmNlIGZvciBlYWNoIGV2ZW50LCBub3Qgb25jZSBmb3IgYSBjb21iaW5hdGlvbiBvZiBhbGwgZXZlbnRzLlxuICBFdmVudHMub25jZSA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgdGhpcy5vZmYuYmluZCh0aGlzKSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBjb250ZXh0ID09IG51bGwpIGNhbGxiYWNrID0gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50cywgY2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmNlYC5cbiAgRXZlbnRzLmxpc3RlblRvT25jZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCB0aGlzLnN0b3BMaXN0ZW5pbmcuYmluZCh0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG4gIH07XG5cbiAgLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbiAgLy8gYG9mZmVyYCB1bmJpbmRzIHRoZSBgb25jZVdyYXBwZXJgIGFmdGVyIGl0IGhhcyBiZWVuIGNhbGxlZC5cbiAgdmFyIG9uY2VNYXAgPSBmdW5jdGlvbihtYXAsIG5hbWUsIGNhbGxiYWNrLCBvZmZlcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIG9uY2UgPSBtYXBbbmFtZV0gPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9mZmVyKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4gIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICBFdmVudHMudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoMCwgYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgIGV2ZW50c0FwaSh0cmlnZ2VyQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIHZvaWQgMCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gSGFuZGxlcyB0cmlnZ2VyaW5nIHRoZSBhcHByb3ByaWF0ZSBldmVudCBjYWxsYmFja3MuXG4gIHZhciB0cmlnZ2VyQXBpID0gZnVuY3Rpb24ob2JqRXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgYXJncykge1xuICAgIGlmIChvYmpFdmVudHMpIHtcbiAgICAgIHZhciBldmVudHMgPSBvYmpFdmVudHNbbmFtZV07XG4gICAgICB2YXIgYWxsRXZlbnRzID0gb2JqRXZlbnRzLmFsbDtcbiAgICAgIGlmIChldmVudHMgJiYgYWxsRXZlbnRzKSBhbGxFdmVudHMgPSBhbGxFdmVudHMuc2xpY2UoKTtcbiAgICAgIGlmIChldmVudHMpIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcbiAgICAgIGlmIChhbGxFdmVudHMpIHRyaWdnZXJFdmVudHMoYWxsRXZlbnRzLCBbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iakV2ZW50cztcbiAgfTtcblxuICAvLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4gIC8vIEJhY2tib25lIGV2ZW50cyBoYXZlIDMgYXJndW1lbnRzKS5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihldmVudHMsIGFyZ3MpIHtcbiAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7IHJldHVybjtcbiAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xuICAgICAgY2FzZSAyOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKTsgcmV0dXJuO1xuICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7IHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgLy8gQSBsaXN0ZW5pbmcgY2xhc3MgdGhhdCB0cmFja3MgYW5kIGNsZWFucyB1cCBtZW1vcnkgYmluZGluZ3NcbiAgLy8gd2hlbiBhbGwgY2FsbGJhY2tzIGhhdmUgYmVlbiBvZmZlZC5cbiAgdmFyIExpc3RlbmluZyA9IGZ1bmN0aW9uKGxpc3RlbmVyLCBvYmopIHtcbiAgICB0aGlzLmlkID0gbGlzdGVuZXIuX2xpc3RlbklkO1xuICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB0aGlzLmludGVyb3AgPSB0cnVlO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuX2V2ZW50cyA9IHZvaWQgMDtcbiAgfTtcblxuICBMaXN0ZW5pbmcucHJvdG90eXBlLm9uID0gRXZlbnRzLm9uO1xuXG4gIC8vIE9mZnMgYSBjYWxsYmFjayAob3Igc2V2ZXJhbCkuXG4gIC8vIFVzZXMgYW4gb3B0aW1pemVkIGNvdW50ZXIgaWYgdGhlIGxpc3RlbmVlIHVzZXMgQmFja2JvbmUuRXZlbnRzLlxuICAvLyBPdGhlcndpc2UsIGZhbGxzIGJhY2sgdG8gbWFudWFsIHRyYWNraW5nIHRvIHN1cHBvcnQgZXZlbnRzXG4gIC8vIGxpYnJhcnkgaW50ZXJvcC5cbiAgTGlzdGVuaW5nLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBjbGVhbnVwO1xuICAgIGlmICh0aGlzLmludGVyb3ApIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogdm9pZCAwLFxuICAgICAgICBsaXN0ZW5lcnM6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwID0gIXRoaXMuX2V2ZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgY2xlYW51cCA9IHRoaXMuY291bnQgPT09IDA7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwKSB0aGlzLmNsZWFudXAoKTtcbiAgfTtcblxuICAvLyBDbGVhbnMgdXAgbWVtb3J5IGJpbmRpbmdzIGJldHdlZW4gdGhlIGxpc3RlbmVyIGFuZCB0aGUgbGlzdGVuZWUuXG4gIExpc3RlbmluZy5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyLl9saXN0ZW5pbmdUb1t0aGlzLm9iai5fbGlzdGVuSWRdO1xuICAgIGlmICghdGhpcy5pbnRlcm9wKSBkZWxldGUgdGhpcy5vYmouX2xpc3RlbmVyc1t0aGlzLmlkXTtcbiAgfTtcblxuICAvLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgRXZlbnRzLmJpbmQgICA9IEV2ZW50cy5vbjtcbiAgRXZlbnRzLnVuYmluZCA9IEV2ZW50cy5vZmY7XG5cbiAgLy8gQWxsb3cgdGhlIGBCYWNrYm9uZWAgb2JqZWN0IHRvIHNlcnZlIGFzIGEgZ2xvYmFsIGV2ZW50IGJ1cywgZm9yIGZvbGtzIHdob1xuICAvLyB3YW50IGdsb2JhbCBcInB1YnN1YlwiIGluIGEgY29udmVuaWVudCBwbGFjZS5cbiAgXy5leHRlbmQoQmFja2JvbmUsIEV2ZW50cyk7XG5cbiAgLy8gQmFja2JvbmUuTW9kZWxcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSAqKk1vZGVscyoqIGFyZSB0aGUgYmFzaWMgZGF0YSBvYmplY3QgaW4gdGhlIGZyYW1ld29yayAtLVxuICAvLyBmcmVxdWVudGx5IHJlcHJlc2VudGluZyBhIHJvdyBpbiBhIHRhYmxlIGluIGEgZGF0YWJhc2Ugb24geW91ciBzZXJ2ZXIuXG4gIC8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3JcbiAgLy8gcGVyZm9ybWluZyBjb21wdXRhdGlvbnMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGF0IGRhdGEuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLiBBIGNsaWVudCBpZCAoYGNpZGApXG4gIC8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuICB2YXIgTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdGhpcy5wcmVpbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKHRoaXMuY2lkUHJlZml4KTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uKSB0aGlzLmNvbGxlY3Rpb24gPSBvcHRpb25zLmNvbGxlY3Rpb247XG4gICAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gdGhpcy5wYXJzZShhdHRycywgb3B0aW9ucykgfHwge307XG4gICAgdmFyIGRlZmF1bHRzID0gXy5yZXN1bHQodGhpcywgJ2RlZmF1bHRzJyk7XG4gICAgYXR0cnMgPSBfLmRlZmF1bHRzKF8uZXh0ZW5kKHt9LCBkZWZhdWx0cywgYXR0cnMpLCBkZWZhdWx0cyk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gVGhlIHByZWZpeCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY2xpZW50IGlkIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgbW9kZWxzIGxvY2FsbHkuXG4gICAgLy8gWW91IG1heSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3JlIGV4cGVyaWVuY2luZyBuYW1lIGNsYXNoZXMgd2l0aCBtb2RlbCBpZHMuXG4gICAgY2lkUHJlZml4OiAnYycsXG5cbiAgICAvLyBwcmVpbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIFlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCBhIGZ1bmN0aW9uXG4gICAgLy8gb3Igb2JqZWN0LiAgcHJlaW5pdGlhbGl6ZSB3aWxsIHJ1biBiZWZvcmUgYW55IGluc3RhbnRpYXRpb24gbG9naWMgaXMgcnVuIGluIHRoZSBNb2RlbC5cbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNwZWNpYWwtY2FzZWQgcHJveHkgdG8gdW5kZXJzY29yZSdzIGBfLm1hdGNoZXNgIG1ldGhvZC5cbiAgICBtYXRjaGVzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuICEhXy5pdGVyYXRlZShhdHRycywgdGhpcykodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QsIGZpcmluZyBgXCJjaGFuZ2VcImAuIFRoaXMgaXNcbiAgICAvLyB0aGUgY29yZSBwcmltaXRpdmUgb3BlcmF0aW9uIG9mIGEgbW9kZWwsIHVwZGF0aW5nIHRoZSBkYXRhIGFuZCBub3RpZnlpbmdcbiAgICAvLyBhbnlvbmUgd2hvIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBpbiBzdGF0ZS4gVGhlIGhlYXJ0IG9mIHRoZSBiZWFzdC5cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdmFyIHVuc2V0ICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgdmFyIHNpbGVudCAgICAgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgIHZhciBjaGFuZ2VzICAgID0gW107XG4gICAgICB2YXIgY2hhbmdpbmcgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICB2YXIgcHJldiAgICA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gRm9yIGVhY2ggYHNldGAgYXR0cmlidXRlLCB1cGRhdGUgb3IgZGVsZXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgY2hhbmdlZFthdHRyXTtcbiAgICAgICAgfVxuICAgICAgICB1bnNldCA/IGRlbGV0ZSBjdXJyZW50W2F0dHJdIDogY3VycmVudFthdHRyXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBgaWRgLlxuICAgICAgaWYgKHRoaXMuaWRBdHRyaWJ1dGUgaW4gYXR0cnMpIHRoaXMuaWQgPSB0aGlzLmdldCh0aGlzLmlkQXR0cmlidXRlKTtcblxuICAgICAgLy8gVHJpZ2dlciBhbGwgcmVsZXZhbnQgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpIHRoaXMuX3BlbmRpbmcgPSBvcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAvLyBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgIC8vIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuICAgICAgdmFyIGhhc0NoYW5nZWQ7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRpZmZbYXR0cl07XG4gICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCB2YWwpKSBjb250aW51ZTtcbiAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IGNoYW5nZWQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlciwgbWVyZ2luZyB0aGUgcmVzcG9uc2Ugd2l0aCB0aGUgbW9kZWwnc1xuICAgIC8vIGxvY2FsIGF0dHJpYnV0ZXMuIEFueSBjaGFuZ2VkIGF0dHJpYnV0ZXMgd2lsbCB0cmlnZ2VyIGEgXCJjaGFuZ2VcIiBldmVudC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBvcHRpb25zLnBhcnNlID8gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucykgOiByZXNwO1xuICAgICAgICBpZiAoIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHN5bmMgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gSWYgdGhlIHNlcnZlciByZXR1cm5zIGFuIGF0dHJpYnV0ZXMgaGFzaCB0aGF0IGRpZmZlcnMsIHRoZSBtb2RlbCdzXG4gICAgLy8gc3RhdGUgd2lsbCBiZSBgc2V0YCBhZ2Fpbi5cbiAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3ZhbGlkYXRlOiB0cnVlLCBwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIGFuZCBhdHRyaWJ1dGVzIGV4aXN0LCBzYXZlIGFjdHMgYXNcbiAgICAgIC8vIGBzZXQoYXR0cikuc2F2ZShudWxsLCBvcHRzKWAgd2l0aCB2YWxpZGF0aW9uLiBPdGhlcndpc2UsIGNoZWNrIGlmXG4gICAgICAvLyB0aGUgbW9kZWwgd2lsbCBiZSB2YWxpZCB3aGVuIHRoZSBhdHRyaWJ1dGVzLCBpZiBhbnksIGFyZSBzZXQuXG4gICAgICBpZiAoYXR0cnMgJiYgIXdhaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldChhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKHdhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoe30sIGF0dHJzLCBzZXJ2ZXJBdHRycyk7XG4gICAgICAgIGlmIChzZXJ2ZXJBdHRycyAmJiAhbW9kZWwuc2V0KHNlcnZlckF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gU2V0IHRlbXBvcmFyeSBhdHRyaWJ1dGVzIGlmIGB7d2FpdDogdHJ1ZX1gIHRvIHByb3Blcmx5IGZpbmQgbmV3IGlkcy5cbiAgICAgIGlmIChhdHRycyAmJiB3YWl0KSB0aGlzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgYXR0cnMpO1xuXG4gICAgICB2YXIgbWV0aG9kID0gdGhpcy5pc05ldygpID8gJ2NyZWF0ZScgOiBvcHRpb25zLnBhdGNoID8gJ3BhdGNoJyA6ICd1cGRhdGUnO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJyAmJiAhb3B0aW9ucy5hdHRycykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgdmFyIHhociA9IHRoaXMuc3luYyhtZXRob2QsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBSZXN0b3JlIGF0dHJpYnV0ZXMuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgcmVtb3ZlcyB0aGUgbW9kZWwgZnJvbSBpdHMgY29sbGVjdGlvbiwgaWYgaXQgaGFzIG9uZS5cbiAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHdhaXQpIGRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHhociA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBfLmRlZmVyKG9wdGlvbnMuc3VjY2Vzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIXdhaXQpIGRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxuICAgIC8vIHVzaW5nIEJhY2tib25lJ3MgcmVzdGZ1bCBtZXRob2RzLCBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgY2FsbGVkLlxuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmFzZSA9XG4gICAgICAgIF8ucmVzdWx0KHRoaXMsICd1cmxSb290JykgfHxcbiAgICAgICAgXy5yZXN1bHQodGhpcy5jb2xsZWN0aW9uLCAndXJsJykgfHxcbiAgICAgICAgdXJsRXJyb3IoKTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHJldHVybiBiYXNlO1xuICAgICAgdmFyIGlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3ZhbGlkYXRlOiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgIC8vIHJldHVybmluZyBgdHJ1ZWAgaWYgYWxsIGlzIHdlbGwuIE90aGVyd2lzZSwgZmlyZSBhbiBgXCJpbnZhbGlkXCJgIGV2ZW50LlxuICAgIF92YWxpZGF0ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgIGlmICghZXJyb3IpIHJldHVybiB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIF8uZXh0ZW5kKG9wdGlvbnMsIHt2YWxpZGF0aW9uRXJyb3I6IGVycm9yfSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5Db2xsZWN0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJZiBtb2RlbHMgdGVuZCB0byByZXByZXNlbnQgYSBzaW5nbGUgcm93IG9mIGRhdGEsIGEgQmFja2JvbmUgQ29sbGVjdGlvbiBpc1xuICAvLyBtb3JlIGFuYWxvZ291cyB0byBhIHRhYmxlIGZ1bGwgb2YgZGF0YSAuLi4gb3IgYSBzbWFsbCBzbGljZSBvciBwYWdlIG9mIHRoYXRcbiAgLy8gdGFibGUsIG9yIGEgY29sbGVjdGlvbiBvZiByb3dzIHRoYXQgYmVsb25nIHRvZ2V0aGVyIGZvciBhIHBhcnRpY3VsYXIgcmVhc29uXG4gIC8vIC0tIGFsbCBvZiB0aGUgbWVzc2FnZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIGZvbGRlciwgYWxsIG9mIHRoZSBkb2N1bWVudHNcbiAgLy8gYmVsb25naW5nIHRvIHRoaXMgcGFydGljdWxhciBhdXRob3IsIGFuZCBzbyBvbi4gQ29sbGVjdGlvbnMgbWFpbnRhaW5cbiAgLy8gaW5kZXhlcyBvZiB0aGVpciBtb2RlbHMsIGJvdGggaW4gb3JkZXIsIGFuZCBmb3IgbG9va3VwIGJ5IGBpZGAuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXG4gIC8vIElmIGEgYGNvbXBhcmF0b3JgIGlzIHNwZWNpZmllZCwgdGhlIENvbGxlY3Rpb24gd2lsbCBtYWludGFpblxuICAvLyBpdHMgbW9kZWxzIGluIHNvcnQgb3JkZXIsIGFzIHRoZXkncmUgYWRkZWQgYW5kIHJlbW92ZWQuXG4gIHZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdGhpcy5wcmVpbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG9wdGlvbnMubW9kZWwpIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmF0b3IgIT09IHZvaWQgMCkgdGhpcy5jb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG1vZGVscykgdGhpcy5yZXNldChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgLy8gRGVmYXVsdCBvcHRpb25zIGZvciBgQ29sbGVjdGlvbiNzZXRgLlxuICB2YXIgc2V0T3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogdHJ1ZSwgbWVyZ2U6IHRydWV9O1xuICB2YXIgYWRkT3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogZmFsc2V9O1xuXG4gIC8vIFNwbGljZXMgYGluc2VydGAgaW50byBgYXJyYXlgIGF0IGluZGV4IGBhdGAuXG4gIHZhciBzcGxpY2UgPSBmdW5jdGlvbihhcnJheSwgaW5zZXJ0LCBhdCkge1xuICAgIGF0ID0gTWF0aC5taW4oTWF0aC5tYXgoYXQsIDApLCBhcnJheS5sZW5ndGgpO1xuICAgIHZhciB0YWlsID0gQXJyYXkoYXJyYXkubGVuZ3RoIC0gYXQpO1xuICAgIHZhciBsZW5ndGggPSBpbnNlcnQubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB0YWlsW2ldID0gYXJyYXlbaSArIGF0XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFycmF5W2kgKyBhdF0gPSBpbnNlcnRbaV07XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIGFycmF5W2kgKyBsZW5ndGggKyBhdF0gPSB0YWlsW2ldO1xuICB9O1xuXG4gIC8vIERlZmluZSB0aGUgQ29sbGVjdGlvbidzIGluaGVyaXRhYmxlIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgbW9kZWw6IE1vZGVsLFxuXG5cbiAgICAvLyBwcmVpbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIFlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCBhIGZ1bmN0aW9uXG4gICAgLy8gb3Igb2JqZWN0LiAgcHJlaW5pdGlhbGl6ZSB3aWxsIHJ1biBiZWZvcmUgYW55IGluc3RhbnRpYXRpb24gbG9naWMgaXMgcnVuIGluIHRoZSBDb2xsZWN0aW9uLlxuICAgIHByZWluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLnRvSlNPTihvcHRpb25zKTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0LlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuIGBtb2RlbHNgIG1heSBiZSBCYWNrYm9uZVxuICAgIC8vIE1vZGVscyBvciByYXcgSmF2YVNjcmlwdCBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZCB0byBNb2RlbHMsIG9yIGFueVxuICAgIC8vIGNvbWJpbmF0aW9uIG9mIHRoZSB0d28uXG4gICAgYWRkOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChtb2RlbHMsIF8uZXh0ZW5kKHttZXJnZTogZmFsc2V9LCBvcHRpb25zLCBhZGRPcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBtb2RlbHMuc2xpY2UoKTtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlTW9kZWxzKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50ICYmIHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgIG9wdGlvbnMuY2hhbmdlcyA9IHthZGRlZDogW10sIG1lcmdlZDogW10sIHJlbW92ZWQ6IHJlbW92ZWR9O1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gcmVtb3ZlZFswXSA6IHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgIC8vIGFscmVhZHkgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIGFzIG5lY2Vzc2FyeS4gU2ltaWxhciB0byAqKk1vZGVsI3NldCoqLFxuICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICAgIHNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBpZiAobW9kZWxzID09IG51bGwpIHJldHVybjtcblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBzZXRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlICYmICF0aGlzLl9pc01vZGVsKG1vZGVscykpIHtcbiAgICAgICAgbW9kZWxzID0gdGhpcy5wYXJzZShtb2RlbHMsIG9wdGlvbnMpIHx8IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogbW9kZWxzLnNsaWNlKCk7XG5cbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQ7XG4gICAgICBpZiAoYXQgIT0gbnVsbCkgYXQgPSArYXQ7XG4gICAgICBpZiAoYXQgPiB0aGlzLmxlbmd0aCkgYXQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIGlmIChhdCA8IDApIGF0ICs9IHRoaXMubGVuZ3RoICsgMTtcblxuICAgICAgdmFyIHNldCA9IFtdO1xuICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICB2YXIgdG9NZXJnZSA9IFtdO1xuICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICB2YXIgbW9kZWxNYXAgPSB7fTtcblxuICAgICAgdmFyIGFkZCA9IG9wdGlvbnMuYWRkO1xuICAgICAgdmFyIG1lcmdlID0gb3B0aW9ucy5tZXJnZTtcbiAgICAgIHZhciByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcblxuICAgICAgdmFyIHNvcnQgPSBmYWxzZTtcbiAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiBhdCA9PSBudWxsICYmIG9wdGlvbnMuc29ydCAhPT0gZmFsc2U7XG4gICAgICB2YXIgc29ydEF0dHIgPSBfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgPyB0aGlzLmNvbXBhcmF0b3IgOiBudWxsO1xuXG4gICAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgICAvLyBmcm9tIGJlaW5nIGFkZGVkLlxuICAgICAgdmFyIG1vZGVsLCBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXTtcblxuICAgICAgICAvLyBJZiBhIGR1cGxpY2F0ZSBpcyBmb3VuZCwgcHJldmVudCBpdCBmcm9tIGJlaW5nIGFkZGVkIGFuZFxuICAgICAgICAvLyBvcHRpb25hbGx5IG1lcmdlIGl0IGludG8gdGhlIGV4aXN0aW5nIG1vZGVsLlxuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChtb2RlbCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgIGlmIChtZXJnZSAmJiBtb2RlbCAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHRoaXMuX2lzTW9kZWwobW9kZWwpID8gbW9kZWwuYXR0cmlidXRlcyA6IG1vZGVsO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gZXhpc3RpbmcucGFyc2UoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZXhpc3Rpbmcuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRvTWVyZ2UucHVzaChleGlzdGluZyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQpIHNvcnQgPSBleGlzdGluZy5oYXNDaGFuZ2VkKHNvcnRBdHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtb2RlbE1hcFtleGlzdGluZy5jaWRdKSB7XG4gICAgICAgICAgICBtb2RlbE1hcFtleGlzdGluZy5jaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldC5wdXNoKGV4aXN0aW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZWxzW2ldID0gZXhpc3Rpbmc7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldywgdmFsaWQgbW9kZWwsIHB1c2ggaXQgdG8gdGhlIGB0b0FkZGAgbGlzdC5cbiAgICAgICAgfSBlbHNlIGlmIChhZGQpIHtcbiAgICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBtb2RlbE1hcFttb2RlbC5jaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHN0YWxlIG1vZGVscy5cbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWxzW2ldO1xuICAgICAgICAgIGlmICghbW9kZWxNYXBbbW9kZWwuY2lkXSkgdG9SZW1vdmUucHVzaChtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlLmxlbmd0aCkgdGhpcy5fcmVtb3ZlTW9kZWxzKHRvUmVtb3ZlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VlIGlmIHNvcnRpbmcgaXMgbmVlZGVkLCB1cGRhdGUgYGxlbmd0aGAgYW5kIHNwbGljZSBpbiBuZXcgbW9kZWxzLlxuICAgICAgdmFyIG9yZGVyQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIHJlcGxhY2UgPSAhc29ydGFibGUgJiYgYWRkICYmIHJlbW92ZTtcbiAgICAgIGlmIChzZXQubGVuZ3RoICYmIHJlcGxhY2UpIHtcbiAgICAgICAgb3JkZXJDaGFuZ2VkID0gdGhpcy5sZW5ndGggIT09IHNldC5sZW5ndGggfHwgXy5zb21lKHRoaXMubW9kZWxzLCBmdW5jdGlvbihtLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBtICE9PSBzZXRbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCBzZXQsIDApO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XG4gICAgICAgIHNwbGljZSh0aGlzLm1vZGVscywgdG9BZGQsIGF0ID09IG51bGwgPyB0aGlzLmxlbmd0aCA6IGF0KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbGVudGx5IHNvcnQgdGhlIGNvbGxlY3Rpb24gaWYgYXBwcm9wcmlhdGUuXG4gICAgICBpZiAoc29ydCkgdGhpcy5zb3J0KHtzaWxlbnQ6IHRydWV9KTtcblxuICAgICAgLy8gVW5sZXNzIHNpbGVuY2VkLCBpdCdzIHRpbWUgdG8gZmlyZSBhbGwgYXBwcm9wcmlhdGUgYWRkL3NvcnQvdXBkYXRlIGV2ZW50cy5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGF0ICE9IG51bGwpIG9wdGlvbnMuaW5kZXggPSBhdCArIGk7XG4gICAgICAgICAgbW9kZWwgPSB0b0FkZFtpXTtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdhZGQnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnQgfHwgb3JkZXJDaGFuZ2VkKSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRvQWRkLmxlbmd0aCB8fCB0b1JlbW92ZS5sZW5ndGggfHwgdG9NZXJnZS5sZW5ndGgpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYW5nZXMgPSB7XG4gICAgICAgICAgICBhZGRlZDogdG9BZGQsXG4gICAgICAgICAgICByZW1vdmVkOiB0b1JlbW92ZSxcbiAgICAgICAgICAgIG1lcmdlZDogdG9NZXJnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICB1bnNoaWZ0OiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IDB9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBzaGlmdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCgwKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcy5tb2RlbHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhIG1vZGVsIGZyb20gdGhlIHNldCBieSBpZCwgY2lkLCBtb2RlbCBvYmplY3Qgd2l0aCBpZCBvciBjaWRcbiAgICAvLyBwcm9wZXJ0aWVzLCBvciBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0aGF0IGlzIHRyYW5zZm9ybWVkIHRocm91Z2ggbW9kZWxJZC5cbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2J5SWRbb2JqXSB8fFxuICAgICAgICB0aGlzLl9ieUlkW3RoaXMubW9kZWxJZCh0aGlzLl9pc01vZGVsKG9iaikgPyBvYmouYXR0cmlidXRlcyA6IG9iaildIHx8XG4gICAgICAgIG9iai5jaWQgJiYgdGhpcy5fYnlJZFtvYmouY2lkXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1vZGVsIGlzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIGhhczogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQob2JqKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIG1vZGVsIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICBhdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIG1vZGVscyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzIG9mXG4gICAgLy8gYGZpbHRlcmAuXG4gICAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xuICAgICAgcmV0dXJuIHRoaXNbZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10oYXR0cnMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcbiAgICAvLyBvZiBgZmluZGAuXG4gICAgZmluZFdoZXJlOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoYXR0cnMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgLy8gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGFzIHRoZSBzZXQgd2lsbCBtYWludGFpbiBzb3J0IG9yZGVyIGFzIGVhY2ggaXRlbVxuICAgIC8vIGlzIGFkZGVkLlxuICAgIHNvcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5jb21wYXJhdG9yO1xuICAgICAgaWYgKCFjb21wYXJhdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0IGEgc2V0IHdpdGhvdXQgYSBjb21wYXJhdG9yJyk7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29tcGFyYXRvci5sZW5ndGg7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbXBhcmF0b3IpKSBjb21wYXJhdG9yID0gY29tcGFyYXRvci5iaW5kKHRoaXMpO1xuXG4gICAgICAvLyBSdW4gc29ydCBiYXNlZCBvbiB0eXBlIG9mIGBjb21wYXJhdG9yYC5cbiAgICAgIGlmIChsZW5ndGggPT09IDEgfHwgXy5pc1N0cmluZyhjb21wYXJhdG9yKSkge1xuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KGNvbXBhcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2RlbHMuc29ydChjb21wYXJhdG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFBsdWNrIGFuIGF0dHJpYnV0ZSBmcm9tIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChhdHRyICsgJycpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgZGVmYXVsdCBzZXQgb2YgbW9kZWxzIGZvciB0aGlzIGNvbGxlY3Rpb24sIHJlc2V0dGluZyB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIHdoZW4gdGhleSBhcnJpdmUuIElmIGByZXNldDogdHJ1ZWAgaXMgcGFzc2VkLCB0aGUgcmVzcG9uc2VcbiAgICAvLyBkYXRhIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGByZXNldGAgbWV0aG9kIGluc3RlYWQgb2YgYHNldGAuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7cGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5yZXNldCA/ICdyZXNldCcgOiAnc2V0JztcbiAgICAgICAgY29sbGVjdGlvblttZXRob2RdKHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kZWwgaW4gdGhpcyBjb2xsZWN0aW9uLiBBZGQgdGhlIG1vZGVsIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gaW1tZWRpYXRlbHksIHVubGVzcyBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgLy8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBhZ3JlZS5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIHZhciB3YWl0ID0gb3B0aW9ucy53YWl0O1xuICAgICAgbW9kZWwgPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCF3YWl0KSB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG0sIHJlc3AsIGNhbGxiYWNrT3B0cykge1xuICAgICAgICBpZiAod2FpdCkgY29sbGVjdGlvbi5hZGQobSwgY2FsbGJhY2tPcHRzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChjYWxsYmFja09wdHMuY29udGV4dCwgbSwgcmVzcCwgY2FsbGJhY2tPcHRzKTtcbiAgICAgIH07XG4gICAgICBtb2RlbC5zYXZlKG51bGwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIGEgbGlzdCBvZiBtb2RlbHMgdG8gYmUgYWRkZWQgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIGl0IHRocm91Z2guXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY29sbGVjdGlvbiB3aXRoIGFuIGlkZW50aWNhbCBsaXN0IG9mIG1vZGVscyBhcyB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5tb2RlbHMsIHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGNvbXBhcmF0b3I6IHRoaXMuY29tcGFyYXRvclxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERlZmluZSBob3cgdG8gdW5pcXVlbHkgaWRlbnRpZnkgbW9kZWxzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIG1vZGVsSWQ6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnNbdGhpcy5tb2RlbC5wcm90b3R5cGUuaWRBdHRyaWJ1dGUgfHwgJ2lkJ107XG4gICAgfSxcblxuICAgIC8vIEdldCBhbiBpdGVyYXRvciBvZiBhbGwgbW9kZWxzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlcmF0b3IodGhpcywgSVRFUkFUT1JfVkFMVUVTKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG9mIGFsbCBtb2RlbCBJRHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlcmF0b3IodGhpcywgSVRFUkFUT1JfS0VZUyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbiBpdGVyYXRvciBvZiBhbGwgW0lELCBtb2RlbF0gdHVwbGVzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkl0ZXJhdG9yKHRoaXMsIElURVJBVE9SX0tFWVNWQUxVRVMpO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZCB0byByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGUuIENhbGxlZCB3aGVuIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gaXMgZmlyc3QgaW5pdGlhbGl6ZWQgb3IgcmVzZXQuXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgICB0aGlzLl9ieUlkICA9IHt9O1xuICAgIH0sXG5cbiAgICAvLyBQcmVwYXJlIGEgaGFzaCBvZiBhdHRyaWJ1dGVzIChvciBvdGhlciBtb2RlbCkgdG8gYmUgYWRkZWQgdG8gdGhpc1xuICAgIC8vIGNvbGxlY3Rpb24uXG4gICAgX3ByZXBhcmVNb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9pc01vZGVsKGF0dHJzKSkge1xuICAgICAgICBpZiAoIWF0dHJzLmNvbGxlY3Rpb24pIGF0dHJzLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIG9wdGlvbnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgbW9kZWwgPSBuZXcgdGhpcy5tb2RlbChhdHRycywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsLnZhbGlkYXRpb25FcnJvcikgcmV0dXJuIG1vZGVsO1xuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgbW9kZWwudmFsaWRhdGlvbkVycm9yLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBieSBib3RoIHJlbW92ZSBhbmQgc2V0LlxuICAgIF9yZW1vdmVNb2RlbHM6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXMgYmVmb3JlIHRyaWdnZXJpbmcgJ3JlbW92ZScgZXZlbnQgdG8gcHJldmVudCBhblxuICAgICAgICAvLyBpbmZpbml0ZSBsb29wLiAjMzY5M1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5jaWRdO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtpZF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVkLnB1c2gobW9kZWwpO1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8vIE1ldGhvZCBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3Qgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBtb2RlbCBmb3JcbiAgICAvLyB0aGUgcHVycG9zZXMgb2YgYWRkaW5nIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgIF9pc01vZGVsOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsIGluc3RhbmNlb2YgTW9kZWw7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9ieUlkW21vZGVsLmNpZF0gPSBtb2RlbDtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX3JlbW92ZVJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbaWRdO1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgaWYgKChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdyZW1vdmUnKSAmJiBjb2xsZWN0aW9uICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZScpIHtcbiAgICAgICAgICB2YXIgcHJldklkID0gdGhpcy5tb2RlbElkKG1vZGVsLnByZXZpb3VzQXR0cmlidXRlcygpKTtcbiAgICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKHByZXZJZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIGlmIChwcmV2SWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbcHJldklkXTtcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIERlZmluaW5nIGFuIEBAaXRlcmF0b3IgbWV0aG9kIGltcGxlbWVudHMgSmF2YVNjcmlwdCdzIEl0ZXJhYmxlIHByb3RvY29sLlxuICAvLyBJbiBtb2Rlcm4gRVMyMDE1IGJyb3dzZXJzLCB0aGlzIHZhbHVlIGlzIGZvdW5kIGF0IFN5bWJvbC5pdGVyYXRvci5cbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgJCRpdGVyYXRvciA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICBpZiAoJCRpdGVyYXRvcikge1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlWyQkaXRlcmF0b3JdID0gQ29sbGVjdGlvbi5wcm90b3R5cGUudmFsdWVzO1xuICB9XG5cbiAgLy8gQ29sbGVjdGlvbkl0ZXJhdG9yXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgQ29sbGVjdGlvbkl0ZXJhdG9yIGltcGxlbWVudHMgSmF2YVNjcmlwdCdzIEl0ZXJhdG9yIHByb3RvY29sLCBhbGxvd2luZyB0aGVcbiAgLy8gdXNlIG9mIGBmb3Igb2ZgIGxvb3BzIGluIG1vZGVybiBicm93c2VycyBhbmQgaW50ZXJvcGVyYXRpb24gYmV0d2VlblxuICAvLyBCYWNrYm9uZS5Db2xsZWN0aW9uIGFuZCBvdGhlciBKYXZhU2NyaXB0IGZ1bmN0aW9ucyBhbmQgdGhpcmQtcGFydHkgbGlicmFyaWVzXG4gIC8vIHdoaWNoIGNhbiBvcGVyYXRlIG9uIEl0ZXJhYmxlcy5cbiAgdmFyIENvbGxlY3Rpb25JdGVyYXRvciA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGtpbmQpIHtcbiAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICB0aGlzLl9raW5kID0ga2luZDtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG4gIH07XG5cbiAgLy8gVGhpcyBcImVudW1cIiBkZWZpbmVzIHRoZSB0aHJlZSBwb3NzaWJsZSBraW5kcyBvZiB2YWx1ZXMgd2hpY2ggY2FuIGJlIGVtaXR0ZWRcbiAgLy8gYnkgYSBDb2xsZWN0aW9uSXRlcmF0b3IgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMoKSwga2V5cygpIGFuZCBlbnRyaWVzKClcbiAgLy8gbWV0aG9kcyBvbiBDb2xsZWN0aW9uLCByZXNwZWN0aXZlbHkuXG4gIHZhciBJVEVSQVRPUl9WQUxVRVMgPSAxO1xuICB2YXIgSVRFUkFUT1JfS0VZUyA9IDI7XG4gIHZhciBJVEVSQVRPUl9LRVlTVkFMVUVTID0gMztcblxuICAvLyBBbGwgSXRlcmF0b3JzIHNob3VsZCB0aGVtc2VsdmVzIGJlIEl0ZXJhYmxlLlxuICBpZiAoJCRpdGVyYXRvcikge1xuICAgIENvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGVbJCRpdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY29sbGVjdGlvbikge1xuXG4gICAgICAvLyBPbmx5IGNvbnRpbnVlIGl0ZXJhdGluZyBpZiB0aGUgaXRlcmF0ZWQgY29sbGVjdGlvbiBpcyBsb25nIGVub3VnaC5cbiAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMuX2NvbGxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuX2NvbGxlY3Rpb24uYXQodGhpcy5faW5kZXgpO1xuICAgICAgICB0aGlzLl9pbmRleCsrO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhIHZhbHVlIGRlcGVuZGluZyBvbiB3aGF0IGtpbmQgb2YgdmFsdWVzIHNob3VsZCBiZSBpdGVyYXRlZC5cbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fa2luZCA9PT0gSVRFUkFUT1JfVkFMVUVTKSB7XG4gICAgICAgICAgdmFsdWUgPSBtb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaWQgPSB0aGlzLl9jb2xsZWN0aW9uLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKHRoaXMuX2tpbmQgPT09IElURVJBVE9SX0tFWVMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gSVRFUkFUT1JfS0VZU1ZBTFVFU1xuICAgICAgICAgICAgdmFsdWUgPSBbaWQsIG1vZGVsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlfTtcbiAgICAgIH1cblxuICAgICAgLy8gT25jZSBleGhhdXN0ZWQsIHJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjb2xsZWN0aW9uIHNvIGZ1dHVyZVxuICAgICAgLy8gY2FsbHMgdG8gdGhlIG5leHQgbWV0aG9kIGFsd2F5cyByZXR1cm4gZG9uZS5cbiAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt2YWx1ZTogdm9pZCAwLCBkb25lOiB0cnVlfTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgdGhpcy5wcmVpbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIHNldCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIHByZWluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gWW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIGEgZnVuY3Rpb25cbiAgICAvLyBvciBvYmplY3QuICBwcmVpbml0aWFsaXplIHdpbGwgcnVuIGJlZm9yZSBhbnkgaW5zdGFudGlhdGlvbiBsb2dpYyBpcyBydW4gaW4gdGhlIFZpZXdcbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KCk7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhpcyB2aWV3J3MgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCBhbmQgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIGF0dGFjaGVkIHRvIGl0LiBFeHBvc2VkIGZvciBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTVxuICAgIC8vIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX3JlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSkgYW5kIHJlLWRlbGVnYXRlIHRoZVxuICAgIC8vIHZpZXcncyBldmVudHMgb24gdGhlIG5ldyBlbGVtZW50LlxuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgdGhpcy5fc2V0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGVzIHRoZSBgdGhpcy5lbGAgYW5kIGB0aGlzLiRlbGAgcmVmZXJlbmNlcyBmb3IgdGhpcyB2aWV3IHVzaW5nIHRoZVxuICAgIC8vIGdpdmVuIGBlbGAuIGBlbGAgY2FuIGJlIGEgQ1NTIHNlbGVjdG9yIG9yIGFuIEhUTUwgc3RyaW5nLCBhIGpRdWVyeVxuICAgIC8vIGNvbnRleHQgb3IgYW4gZWxlbWVudC4gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byB1dGlsaXplIGFuXG4gICAgLy8gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkgYW5kIGFyZSBvbmx5IHJlcXVpcmVkIHRvIHNldCB0aGVcbiAgICAvLyBgdGhpcy5lbGAgcHJvcGVydHkuXG4gICAgX3NldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB0aGlzLiRlbCA9IGVsIGluc3RhbmNlb2YgQmFja2JvbmUuJCA/IGVsIDogQmFja2JvbmUuJChlbCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgfSxcblxuICAgIC8vIFNldCBjYWxsYmFja3MsIHdoZXJlIGB0aGlzLmV2ZW50c2AgaXMgYSBoYXNoIG9mXG4gICAgLy9cbiAgICAvLyAqe1wiZXZlbnQgc2VsZWN0b3JcIjogXCJjYWxsYmFja1wifSpcbiAgICAvL1xuICAgIC8vICAgICB7XG4gICAgLy8gICAgICAgJ21vdXNlZG93biAudGl0bGUnOiAgJ2VkaXQnLFxuICAgIC8vICAgICAgICdjbGljayAuYnV0dG9uJzogICAgICdzYXZlJyxcbiAgICAvLyAgICAgICAnY2xpY2sgLm9wZW4nOiAgICAgICBmdW5jdGlvbihlKSB7IC4uLiB9XG4gICAgLy8gICAgIH1cbiAgICAvL1xuICAgIC8vIHBhaXJzLiBDYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGUgdmlldywgd2l0aCBgdGhpc2Agc2V0IHByb3Blcmx5LlxuICAgIC8vIFVzZXMgZXZlbnQgZGVsZWdhdGlvbiBmb3IgZWZmaWNpZW5jeS5cbiAgICAvLyBPbWl0dGluZyB0aGUgc2VsZWN0b3IgYmluZHMgdGhlIGV2ZW50IHRvIGB0aGlzLmVsYC5cbiAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICBldmVudHMgfHwgKGV2ZW50cyA9IF8ucmVzdWx0KHRoaXMsICdldmVudHMnKSk7XG4gICAgICBpZiAoIWV2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihtZXRob2QpKSBtZXRob2QgPSB0aGlzW21ldGhvZF07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGRlbGVnYXRlRXZlbnRTcGxpdHRlcik7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUobWF0Y2hbMV0sIG1hdGNoWzJdLCBtZXRob2QuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB2aWV3J3MgZWxlbWVudCAob3IgYSBjaGlsZCBlbGVtZW50XG4gICAgLy8gdXNpbmcgYHNlbGVjdG9yYCkuIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLFxuICAgIC8vIGBibHVyYCwgYW5kIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhcnMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IGJvdW5kIHRvIHRoZSB2aWV3IGJ5IGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgLy8gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgLy8gQmFja2JvbmUgdmlld3MgYXR0YWNoZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQuXG4gICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy4kZWwpIHRoaXMuJGVsLm9mZignLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBIGZpbmVyLWdyYWluZWQgYHVuZGVsZWdhdGVFdmVudHNgIGZvciByZW1vdmluZyBhIHNpbmdsZSBkZWxlZ2F0ZWQgZXZlbnQuXG4gICAgLy8gYHNlbGVjdG9yYCBhbmQgYGxpc3RlbmVyYCBhcmUgYm90aCBvcHRpb25hbC5cbiAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgdGhpcy4kZWwub2ZmKGV2ZW50TmFtZSArICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQsIHNlbGVjdG9yLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJvZHVjZXMgYSBET00gZWxlbWVudCB0byBiZSBhc3NpZ25lZCB0byB5b3VyIHZpZXcuIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24odGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuX2NyZWF0ZUVsZW1lbnQoXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSkpO1xuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCBhdHRyaWJ1dGVzIGZyb20gYSBoYXNoIG9uIHRoaXMgdmlldydzIGVsZW1lbnQuICBFeHBvc2VkIGZvclxuICAgIC8vIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX3NldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuJGVsLmF0dHIoYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFByb3h5IEJhY2tib25lIGNsYXNzIG1ldGhvZHMgdG8gVW5kZXJzY29yZSBmdW5jdGlvbnMsIHdyYXBwaW5nIHRoZSBtb2RlbCdzXG4gIC8vIGBhdHRyaWJ1dGVzYCBvYmplY3Qgb3IgY29sbGVjdGlvbidzIGBtb2RlbHNgIGFycmF5IGJlaGluZCB0aGUgc2NlbmVzLlxuICAvL1xuICAvLyBjb2xsZWN0aW9uLmZpbHRlcihmdW5jdGlvbihtb2RlbCkgeyByZXR1cm4gbW9kZWwuZ2V0KCdhZ2UnKSA+IDEwIH0pO1xuICAvLyBjb2xsZWN0aW9uLmVhY2godGhpcy5hZGRWaWV3KTtcbiAgLy9cbiAgLy8gYEZ1bmN0aW9uI2FwcGx5YCBjYW4gYmUgc2xvdyBzbyB3ZSB1c2UgdGhlIG1ldGhvZCdzIGFyZyBjb3VudCwgaWYgd2Uga25vdyBpdC5cbiAgdmFyIGFkZE1ldGhvZCA9IGZ1bmN0aW9uKGJhc2UsIGxlbmd0aCwgbWV0aG9kLCBhdHRyaWJ1dGUpIHtcbiAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZVttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCBjYihpdGVyYXRlZSwgdGhpcyksIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGl0ZXJhdGVlLCBkZWZhdWx0VmFsLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCBjYihpdGVyYXRlZSwgdGhpcyksIGRlZmF1bHRWYWwsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzW2F0dHJpYnV0ZV0pO1xuICAgICAgICByZXR1cm4gYmFzZVttZXRob2RdLmFwcGx5KGJhc2UsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFkZFVuZGVyc2NvcmVNZXRob2RzID0gZnVuY3Rpb24oQ2xhc3MsIGJhc2UsIG1ldGhvZHMsIGF0dHJpYnV0ZSkge1xuICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCkge1xuICAgICAgaWYgKGJhc2VbbWV0aG9kXSkgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBhZGRNZXRob2QoYmFzZSwgbGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gU3VwcG9ydCBgY29sbGVjdGlvbi5zb3J0QnkoJ2F0dHInKWAgYW5kIGBjb2xsZWN0aW9uLmZpbmRXaGVyZSh7aWQ6IDF9KWAuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCBpbnN0YW5jZSkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSByZXR1cm4gaXRlcmF0ZWU7XG4gICAgaWYgKF8uaXNPYmplY3QoaXRlcmF0ZWUpICYmICFpbnN0YW5jZS5faXNNb2RlbChpdGVyYXRlZSkpIHJldHVybiBtb2RlbE1hdGNoZXIoaXRlcmF0ZWUpO1xuICAgIGlmIChfLmlzU3RyaW5nKGl0ZXJhdGVlKSkgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC5nZXQoaXRlcmF0ZWUpOyB9O1xuICAgIHJldHVybiBpdGVyYXRlZTtcbiAgfTtcbiAgdmFyIG1vZGVsTWF0Y2hlciA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBfLm1hdGNoZXMoYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXIobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbiAgLy8gOTAlIG9mIHRoZSBjb3JlIHVzZWZ1bG5lc3Mgb2YgQmFja2JvbmUgQ29sbGVjdGlvbnMgaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWRcbiAgLy8gcmlnaHQgaGVyZTpcbiAgdmFyIGNvbGxlY3Rpb25NZXRob2RzID0ge2ZvckVhY2g6IDMsIGVhY2g6IDMsIG1hcDogMywgY29sbGVjdDogMywgcmVkdWNlOiAwLFxuICAgIGZvbGRsOiAwLCBpbmplY3Q6IDAsIHJlZHVjZVJpZ2h0OiAwLCBmb2xkcjogMCwgZmluZDogMywgZGV0ZWN0OiAzLCBmaWx0ZXI6IDMsXG4gICAgc2VsZWN0OiAzLCByZWplY3Q6IDMsIGV2ZXJ5OiAzLCBhbGw6IDMsIHNvbWU6IDMsIGFueTogMywgaW5jbHVkZTogMywgaW5jbHVkZXM6IDMsXG4gICAgY29udGFpbnM6IDMsIGludm9rZTogMCwgbWF4OiAzLCBtaW46IDMsIHRvQXJyYXk6IDEsIHNpemU6IDEsIGZpcnN0OiAzLFxuICAgIGhlYWQ6IDMsIHRha2U6IDMsIGluaXRpYWw6IDMsIHJlc3Q6IDMsIHRhaWw6IDMsIGRyb3A6IDMsIGxhc3Q6IDMsXG4gICAgd2l0aG91dDogMCwgZGlmZmVyZW5jZTogMCwgaW5kZXhPZjogMywgc2h1ZmZsZTogMSwgbGFzdEluZGV4T2Y6IDMsXG4gICAgaXNFbXB0eTogMSwgY2hhaW46IDEsIHNhbXBsZTogMywgcGFydGl0aW9uOiAzLCBncm91cEJ5OiAzLCBjb3VudEJ5OiAzLFxuICAgIHNvcnRCeTogMywgaW5kZXhCeTogMywgZmluZEluZGV4OiAzLCBmaW5kTGFzdEluZGV4OiAzfTtcblxuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbCwgbWFwcGVkIHRvIHRoZVxuICAvLyBudW1iZXIgb2YgYXJndW1lbnRzIHRoZXkgdGFrZS5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IHtrZXlzOiAxLCB2YWx1ZXM6IDEsIHBhaXJzOiAxLCBpbnZlcnQ6IDEsIHBpY2s6IDAsXG4gICAgb21pdDogMCwgY2hhaW46IDEsIGlzRW1wdHk6IDF9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cblxuICBfLmVhY2goW1xuICAgIFtDb2xsZWN0aW9uLCBjb2xsZWN0aW9uTWV0aG9kcywgJ21vZGVscyddLFxuICAgIFtNb2RlbCwgbW9kZWxNZXRob2RzLCAnYXR0cmlidXRlcyddXG4gIF0sIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBCYXNlID0gY29uZmlnWzBdLFxuICAgICAgICBtZXRob2RzID0gY29uZmlnWzFdLFxuICAgICAgICBhdHRyaWJ1dGUgPSBjb25maWdbMl07XG5cbiAgICBCYXNlLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbWFwcGluZ3MgPSBfLnJlZHVjZShfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihtZW1vLCBuYW1lKSB7XG4gICAgICAgIG1lbW9bbmFtZV0gPSAwO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHt9KTtcbiAgICAgIGFkZFVuZGVyc2NvcmVNZXRob2RzKEJhc2UsIG9iaiwgbWFwcGluZ3MsIGF0dHJpYnV0ZSk7XG4gICAgfTtcblxuICAgIGFkZFVuZGVyc2NvcmVNZXRob2RzKEJhc2UsIF8sIG1ldGhvZHMsIGF0dHJpYnV0ZSk7XG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLnN5bmNcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIHRoZSBtYW5uZXIgaW4gd2hpY2ggQmFja2JvbmUgcGVyc2lzdHNcbiAgLy8gbW9kZWxzIHRvIHRoZSBzZXJ2ZXIuIFlvdSB3aWxsIGJlIHBhc3NlZCB0aGUgdHlwZSBvZiByZXF1ZXN0LCBhbmQgdGhlXG4gIC8vIG1vZGVsIGluIHF1ZXN0aW9uLiBCeSBkZWZhdWx0LCBtYWtlcyBhIFJFU1RmdWwgQWpheCByZXF1ZXN0XG4gIC8vIHRvIHRoZSBtb2RlbCdzIGB1cmwoKWAuIFNvbWUgcG9zc2libGUgY3VzdG9taXphdGlvbnMgY291bGQgYmU6XG4gIC8vXG4gIC8vICogVXNlIGBzZXRUaW1lb3V0YCB0byBiYXRjaCByYXBpZC1maXJlIHVwZGF0ZXMgaW50byBhIHNpbmdsZSByZXF1ZXN0LlxuICAvLyAqIFNlbmQgdXAgdGhlIG1vZGVscyBhcyBYTUwgaW5zdGVhZCBvZiBKU09OLlxuICAvLyAqIFBlcnNpc3QgbW9kZWxzIHZpYSBXZWJTb2NrZXRzIGluc3RlYWQgb2YgQWpheC5cbiAgLy9cbiAgLy8gVHVybiBvbiBgQmFja2JvbmUuZW11bGF0ZUhUVFBgIGluIG9yZGVyIHRvIHNlbmQgYFBVVGAgYW5kIGBERUxFVEVgIHJlcXVlc3RzXG4gIC8vIGFzIGBQT1NUYCwgd2l0aCBhIGBfbWV0aG9kYCBwYXJhbWV0ZXIgY29udGFpbmluZyB0aGUgdHJ1ZSBIVFRQIG1ldGhvZCxcbiAgLy8gYXMgd2VsbCBhcyBhbGwgcmVxdWVzdHMgd2l0aCB0aGUgYm9keSBhcyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYFxuICAvLyBpbnN0ZWFkIG9mIGBhcHBsaWNhdGlvbi9qc29uYCB3aXRoIHRoZSBtb2RlbCBpbiBhIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIC8vIFVzZWZ1bCB3aGVuIGludGVyZmFjaW5nIHdpdGggc2VydmVyLXNpZGUgbGFuZ3VhZ2VzIGxpa2UgKipQSFAqKiB0aGF0IG1ha2VcbiAgLy8gaXQgZGlmZmljdWx0IHRvIHJlYWQgdGhlIGJvZHkgb2YgYFBVVGAgcmVxdWVzdHMuXG4gIEJhY2tib25lLnN5bmMgPSBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSBtZXRob2RNYXBbbWV0aG9kXTtcblxuICAgIC8vIERlZmF1bHQgb3B0aW9ucywgdW5sZXNzIHNwZWNpZmllZC5cbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSksIHtcbiAgICAgIGVtdWxhdGVIVFRQOiBCYWNrYm9uZS5lbXVsYXRlSFRUUCxcbiAgICAgIGVtdWxhdGVKU09OOiBCYWNrYm9uZS5lbXVsYXRlSlNPTlxuICAgIH0pO1xuXG4gICAgLy8gRGVmYXVsdCBKU09OLXJlcXVlc3Qgb3B0aW9ucy5cbiAgICB2YXIgcGFyYW1zID0ge3R5cGU6IHR5cGUsIGRhdGFUeXBlOiAnanNvbid9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhIFVSTC5cbiAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICBwYXJhbXMudXJsID0gXy5yZXN1bHQobW9kZWwsICd1cmwnKSB8fCB1cmxFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgdGhlIGFwcHJvcHJpYXRlIHJlcXVlc3QgZGF0YS5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09IG51bGwgJiYgbW9kZWwgJiYgKG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdwYXRjaCcpKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICBwYXJhbXMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXR0cnMgfHwgbW9kZWwudG9KU09OKG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBKU09OIGJ5IGVuY29kaW5nIHRoZSByZXF1ZXN0IGludG8gYW4gSFRNTC1mb3JtLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIHBhcmFtcy5kYXRhID0gcGFyYW1zLmRhdGEgPyB7bW9kZWw6IHBhcmFtcy5kYXRhfSA6IHt9O1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEhUVFAgYnkgbWltaWNraW5nIHRoZSBIVFRQIG1ldGhvZCB3aXRoIGBfbWV0aG9kYFxuICAgIC8vIEFuZCBhbiBgWC1IVFRQLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVIVFRQICYmICh0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnREVMRVRFJyB8fCB0eXBlID09PSAnUEFUQ0gnKSkge1xuICAgICAgcGFyYW1zLnR5cGUgPSAnUE9TVCc7XG4gICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikgcGFyYW1zLmRhdGEuX21ldGhvZCA9IHR5cGU7XG4gICAgICB2YXIgYmVmb3JlU2VuZCA9IG9wdGlvbnMuYmVmb3JlU2VuZDtcbiAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsIHR5cGUpO1xuICAgICAgICBpZiAoYmVmb3JlU2VuZCkgcmV0dXJuIGJlZm9yZVNlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBkYXRhIG9uIGEgbm9uLUdFVCByZXF1ZXN0LlxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5wcm9jZXNzRGF0YSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFBhc3MgYWxvbmcgYHRleHRTdGF0dXNgIGFuZCBgZXJyb3JUaHJvd25gIGZyb20galF1ZXJ5LlxuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgIG9wdGlvbnMudGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICBvcHRpb25zLmVycm9yVGhyb3duID0gZXJyb3JUaHJvd247XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCB4aHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICB9O1xuXG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgYW55IEFqYXggb3B0aW9ucy5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICByZXR1cm4geGhyO1xuICB9O1xuXG4gIC8vIE1hcCBmcm9tIENSVUQgdG8gSFRUUCBmb3Igb3VyIGRlZmF1bHQgYEJhY2tib25lLnN5bmNgIGltcGxlbWVudGF0aW9uLlxuICB2YXIgbWV0aG9kTWFwID0ge1xuICAgIGNyZWF0ZTogJ1BPU1QnLFxuICAgIHVwZGF0ZTogJ1BVVCcsXG4gICAgcGF0Y2g6ICdQQVRDSCcsXG4gICAgZGVsZXRlOiAnREVMRVRFJyxcbiAgICByZWFkOiAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIHByZWluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gWW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIGEgZnVuY3Rpb25cbiAgICAvLyBvciBvYmplY3QuICBwcmVpbml0aWFsaXplIHdpbGwgcnVuIGJlZm9yZSBhbnkgaW5zdGFudGlhdGlvbiBsb2dpYyBpcyBydW4gaW4gdGhlIFJvdXRlci5cbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBNYW51YWxseSBiaW5kIGEgc2luZ2xlIG5hbWVkIHJvdXRlIHRvIGEgY2FsbGJhY2suIEZvciBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgIC8vICAgICAgIC4uLlxuICAgIC8vICAgICB9KTtcbiAgICAvL1xuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghXy5pc1JlZ0V4cChyb3V0ZSkpIHJvdXRlID0gdGhpcy5fcm91dGVUb1JlZ0V4cChyb3V0ZSk7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSB0aGlzW25hbWVdO1xuICAgICAgdmFyIHJvdXRlciA9IHRoaXM7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICB2YXIgYXJncyA9IHJvdXRlci5fZXh0cmFjdFBhcmFtZXRlcnMocm91dGUsIGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzLCBuYW1lKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlci5hcHBseShyb3V0ZXIsIFsncm91dGU6JyArIG5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgcm91dGVyLnRyaWdnZXIoJ3JvdXRlJywgbmFtZSwgYXJncyk7XG4gICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4ZWN1dGUgYSByb3V0ZSBoYW5kbGVyIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuICBUaGlzIGlzIGFuXG4gICAgLy8gZXhjZWxsZW50IHBsYWNlIHRvIGRvIHByZS1yb3V0ZSBzZXR1cCBvciBwb3N0LXJvdXRlIGNsZWFudXAuXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MsIG5hbWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSxcblxuICAgIC8vIFNpbXBsZSBwcm94eSB0byBgQmFja2JvbmUuaGlzdG9yeWAgdG8gc2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFsbCBkZWZpbmVkIHJvdXRlcyB0byBgQmFja2JvbmUuaGlzdG9yeWAuIFdlIGhhdmUgdG8gcmV2ZXJzZSB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgcm91dGVzIGhlcmUgdG8gc3VwcG9ydCBiZWhhdmlvciB3aGVyZSB0aGUgbW9zdCBnZW5lcmFsXG4gICAgLy8gcm91dGVzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvdXRlIG1hcC5cbiAgICBfYmluZFJvdXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucm91dGVzKSByZXR1cm47XG4gICAgICB0aGlzLnJvdXRlcyA9IF8ucmVzdWx0KHRoaXMsICdyb3V0ZXMnKTtcbiAgICAgIHZhciByb3V0ZSwgcm91dGVzID0gXy5rZXlzKHRoaXMucm91dGVzKTtcbiAgICAgIHdoaWxlICgocm91dGUgPSByb3V0ZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXNbcm91dGVdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIHJvdXRlIHN0cmluZyBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLCBzdWl0YWJsZSBmb3IgbWF0Y2hpbmdcbiAgICAvLyBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGhhc2guXG4gICAgX3JvdXRlVG9SZWdFeHA6IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCAnXFxcXCQmJylcbiAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBtYXRjaCA6ICcoW14vP10rKSc7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgdGhpcy5jaGVja1VybCA9IHRoaXMuY2hlY2tVcmwuYmluZCh0aGlzKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxuICB2YXIgcGF0aFN0cmlwcGVyID0gLyMuKiQvO1xuXG4gIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cbiAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLkhpc3RvcnkqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChIaXN0b3J5LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcbiAgICAvLyB0d2VudHkgdGltZXMgYSBzZWNvbmQuXG4gICAgaW50ZXJ2YWw6IDUwLFxuXG4gICAgLy8gQXJlIHdlIGF0IHRoZSBhcHAgcm9vdD9cbiAgICBhdFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJyk7XG4gICAgICByZXR1cm4gcGF0aCA9PT0gdGhpcy5yb290ICYmICF0aGlzLmdldFNlYXJjaCgpO1xuICAgIH0sXG5cbiAgICAvLyBEb2VzIHRoZSBwYXRobmFtZSBtYXRjaCB0aGUgcm9vdD9cbiAgICBtYXRjaFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KHRoaXMubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgdmFyIHJvb3RQYXRoID0gcGF0aC5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoIC0gMSkgKyAnLyc7XG4gICAgICByZXR1cm4gcm9vdFBhdGggPT09IHRoaXMucm9vdDtcbiAgICB9LFxuXG4gICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJzIGluIGBsb2NhdGlvbi5wYXRobmFtZWAgYXJlIHBlcmNlbnQgZW5jb2RlZCBzbyB0aGV5J3JlXG4gICAgLy8gZGVjb2RlZCBmb3IgY29tcGFyaXNvbi4gYCUyNWAgc2hvdWxkIG5vdCBiZSBkZWNvZGVkIHNpbmNlIGl0IG1heSBiZSBwYXJ0XG4gICAgLy8gb2YgYW4gZW5jb2RlZCBwYXJhbWV0ZXIuXG4gICAgZGVjb2RlRnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJKGZyYWdtZW50LnJlcGxhY2UoLyUyNS9nLCAnJTI1MjUnKSk7XG4gICAgfSxcblxuICAgIC8vIEluIElFNiwgdGhlIGhhc2ggZnJhZ21lbnQgYW5kIHNlYXJjaCBwYXJhbXMgYXJlIGluY29ycmVjdCBpZiB0aGVcbiAgICAvLyBmcmFnbWVudCBjb250YWlucyBgP2AuXG4gICAgZ2V0U2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiovLCAnJykubWF0Y2goL1xcPy4rLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgZ2V0SGFzaDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwYXRobmFtZSBhbmQgc2VhcmNoIHBhcmFtcywgd2l0aG91dCB0aGUgcm9vdC5cbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5kZWNvZGVGcmFnbWVudChcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMuZ2V0U2VhcmNoKClcbiAgICAgICkuc2xpY2UodGhpcy5yb290Lmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnNsaWNlKDEpIDogcGF0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50IGZyb20gdGhlIHBhdGggb3IgaGFzaC5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGlmIChmcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yb290ICAgICAgICAgICAgID0gdGhpcy5vcHRpb25zLnJvb3Q7XG4gICAgICB0aGlzLl93YW50c0hhc2hDaGFuZ2UgPSB0aGlzLm9wdGlvbnMuaGFzaENoYW5nZSAhPT0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNIYXNoQ2hhbmdlICAgPSAnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cgJiYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gdm9pZCAwIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDcpO1xuICAgICAgdGhpcy5fdXNlSGFzaENoYW5nZSAgID0gdGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX2hhc0hhc2hDaGFuZ2U7XG4gICAgICB0aGlzLl93YW50c1B1c2hTdGF0ZSAgPSAhIXRoaXMub3B0aW9ucy5wdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oYXNQdXNoU3RhdGUgICAgPSAhISh0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB0aGlzLl91c2VQdXNoU3RhdGUgICAgPSB0aGlzLl93YW50c1B1c2hTdGF0ZSAmJiB0aGlzLl9oYXNQdXNoU3RhdGU7XG4gICAgICB0aGlzLmZyYWdtZW50ICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSByb290IHRvIGFsd2F5cyBpbmNsdWRlIGEgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICB0aGlzLnJvb3QgPSAoJy8nICsgdGhpcy5yb290ICsgJy8nKS5yZXBsYWNlKHJvb3RTdHJpcHBlciwgJy8nKTtcblxuICAgICAgLy8gVHJhbnNpdGlvbiBmcm9tIGhhc2hDaGFuZ2UgdG8gcHVzaFN0YXRlIG9yIHZpY2UgdmVyc2EgaWYgYm90aCBhcmVcbiAgICAgIC8vIHJlcXVlc3RlZC5cbiAgICAgIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5fd2FudHNQdXNoU3RhdGUpIHtcblxuICAgICAgICAvLyBJZiB3ZSd2ZSBzdGFydGVkIG9mZiB3aXRoIGEgcm91dGUgZnJvbSBhIGBwdXNoU3RhdGVgLWVuYWJsZWRcbiAgICAgICAgLy8gYnJvd3NlciwgYnV0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIGJyb3dzZXIgdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuLi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNQdXNoU3RhdGUgJiYgIXRoaXMuYXRSb290KCkpIHtcbiAgICAgICAgICB2YXIgcm9vdFBhdGggPSB0aGlzLnJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2Uocm9vdFBhdGggKyAnIycgKyB0aGlzLmdldFBhdGgoKSk7XG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgJiYgdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5nZXRIYXNoKCksIHtyZXBsYWNlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBQcm94eSBhbiBpZnJhbWUgdG8gaGFuZGxlIGxvY2F0aW9uIGV2ZW50cyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IHRoZSBgaGFzaGNoYW5nZWAgZXZlbnQsIEhUTUw1IGhpc3RvcnksIG9yIHRoZSB1c2VyIHdhbnRzXG4gICAgICAvLyBgaGFzaENoYW5nZWAgYnV0IG5vdCBgcHVzaFN0YXRlYC5cbiAgICAgIGlmICghdGhpcy5faGFzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgIXRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB0aGlzLmlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBVc2luZyBgYXBwZW5kQ2hpbGRgIHdpbGwgdGhyb3cgb24gSUUgPCA5IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgcmVhZHkuXG4gICAgICAgIHZhciBpV2luZG93ID0gYm9keS5pbnNlcnRCZWZvcmUodGhpcy5pZnJhbWUsIGJvZHkuZmlyc3RDaGlsZCkuY29udGVudFdpbmRvdztcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgaVdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGhpcy5mcmFnbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYGFkZEV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gRGlzYWJsZSBCYWNrYm9uZS5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXG4gICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFJlbW92ZSB3aW5kb3cgbGlzdGVuZXJzLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlSGFzaENoYW5nZSAmJiAhdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIGlmcmFtZSBpZiBuZWNlc3NhcnkuXG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmlmcmFtZSk7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgd2lsbCB0aHJvdyB3aGVuIGNsZWFyaW5nIGFuIHVuZGVmaW5lZCBpbnRlcnZhbC5cbiAgICAgIGlmICh0aGlzLl9jaGVja1VybEludGVydmFsKSBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgY2hlY2tVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuXG4gICAgICAvLyBJZiB0aGUgdXNlciBwcmVzc2VkIHRoZSBiYWNrIGJ1dHRvbiwgdGhlIGlmcmFtZSdzIGhhc2ggd2lsbCBoYXZlXG4gICAgICAvLyBjaGFuZ2VkIGFuZCB3ZSBzaG91bGQgdXNlIHRoYXQgZm9yIGNvbXBhcmlzb24uXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCAmJiB0aGlzLmlmcmFtZSkge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAvLyByZXR1cm5zIGBmYWxzZWAuXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSByb290IGRvZXNuJ3QgbWF0Y2gsIG5vIHJvdXRlcyBjYW4gbWF0Y2ggZWl0aGVyLlxuICAgICAgaWYgKCF0aGlzLm1hdGNoUm9vdCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLnNvbWUodGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFuZGxlci5yb3V0ZS50ZXN0KGZyYWdtZW50KSkge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZnJhZ21lbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gU2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhhc2ggaGlzdG9yeSwgb3IgcmVwbGFjZSB0aGUgVVJMIHN0YXRlIGlmIHRoZVxuICAgIC8vICdyZXBsYWNlJyBvcHRpb24gaXMgcGFzc2VkLiBZb3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm9wZXJseSBVUkwtZW5jb2RpbmdcbiAgICAvLyB0aGUgZnJhZ21lbnQgaW4gYWR2YW5jZS5cbiAgICAvL1xuICAgIC8vIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiBgdHJpZ2dlcjogdHJ1ZWAgaWYgeW91IHdpc2ggdG8gaGF2ZSB0aGVcbiAgICAvLyByb3V0ZSBjYWxsYmFjayBiZSBmaXJlZCAobm90IHVzdWFsbHkgZGVzaXJhYmxlKSwgb3IgYHJlcGxhY2U6IHRydWVgLCBpZlxuICAgIC8vIHlvdSB3aXNoIHRvIG1vZGlmeSB0aGUgY3VycmVudCBVUkwgd2l0aG91dCBhZGRpbmcgYW4gZW50cnkgdG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIUhpc3Rvcnkuc3RhcnRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUpIG9wdGlvbnMgPSB7dHJpZ2dlcjogISFvcHRpb25zfTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBmcmFnbWVudC5cbiAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJyk7XG5cbiAgICAgIC8vIERvbid0IGluY2x1ZGUgYSB0cmFpbGluZyBzbGFzaCBvbiB0aGUgcm9vdC5cbiAgICAgIHZhciByb290UGF0aCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdFBhdGggPSByb290UGF0aC5zbGljZSgwLCAtMSkgfHwgJy8nO1xuICAgICAgfVxuICAgICAgdmFyIHVybCA9IHJvb3RQYXRoICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBmcmFnbWVudCBvZiB0aGUgcXVlcnkgYW5kIGhhc2ggZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKHBhdGhTdHJpcHBlciwgJycpO1xuXG4gICAgICAvLyBEZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgdmFyIGRlY29kZWRGcmFnbWVudCA9IHRoaXMuZGVjb2RlRnJhZ21lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZGVjb2RlZEZyYWdtZW50KSByZXR1cm47XG4gICAgICB0aGlzLmZyYWdtZW50ID0gZGVjb2RlZEZyYWdtZW50O1xuXG4gICAgICAvLyBJZiBwdXNoU3RhdGUgaXMgYXZhaWxhYmxlLCB3ZSB1c2UgaXQgdG8gc2V0IHRoZSBmcmFnbWVudCBhcyBhIHJlYWwgVVJMLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuXG4gICAgICAvLyBJZiBoYXNoIGNoYW5nZXMgaGF2ZW4ndCBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIHVwZGF0ZSB0aGUgaGFzaFxuICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIGlmICh0aGlzLmlmcmFtZSAmJiBmcmFnbWVudCAhPT0gdGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpKSB7XG4gICAgICAgICAgdmFyIGlXaW5kb3cgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuICAgICAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2goaVdpbmRvdy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBmb3Igc3ViY2xhc3Nlcy5cbiAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGFuZCBhZGQgdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICAgIGNoaWxkLnByb3RvdHlwZSA9IF8uY3JlYXRlKHBhcmVudC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGNoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIGEgVVJMIGlzIG5lZWRlZCwgYW5kIG5vbmUgaXMgc3VwcGxpZWQuXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gIH07XG5cbiAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIG1vZGVsLnRyaWdnZXIoJ2Vycm9yJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEJhY2tib25lO1xufSk7XG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyoqXHJcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XHJcbiAqL1xyXG5cclxudmFyIEJsb2JCdWlsZGVyID0gdHlwZW9mIEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IEJsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgV2ViS2l0QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gV2ViS2l0QmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBNU0Jsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1TQmxvYkJ1aWxkZXIgOlxyXG4gIHR5cGVvZiBNb3pCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNb3pCbG9iQnVpbGRlciA6IFxyXG4gIGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgc3VwcG9ydGVkXHJcbiAqL1xyXG5cclxudmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcclxuICAgIHJldHVybiBhLnNpemUgPT09IDI7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xyXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxyXG4gKi9cclxuXHJcbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XHJcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcclxuICovXHJcblxyXG52YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXHJcbiAqIFVzZWQgYnkgQmxvYkJ1aWxkZXIgY29uc3RydWN0b3IgYW5kIG9sZCBicm93c2VycyB0aGF0IGRpZG4ndFxyXG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XHJcbiAgcmV0dXJuIGFyeS5tYXAoZnVuY3Rpb24oY2h1bmspIHtcclxuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xyXG5cclxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XHJcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxyXG4gICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgIGJ1ZiA9IGNvcHkuYnVmZmVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYnVmO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaHVuaztcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XHJcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xyXG4gICAgYmIuYXBwZW5kKHBhcnQpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBCbG9iKG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSwgb3B0aW9ucyB8fCB7fSk7XHJcbn07XHJcblxyXG5pZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgQmxvYkJ1aWxkZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBCbG9iLnByb3RvdHlwZTtcclxuICBCbG9iQ29uc3RydWN0b3IucHJvdG90eXBlID0gQmxvYi5wcm90b3R5cGU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xyXG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XHJcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gQmxvYiA6IEJsb2JDb25zdHJ1Y3RvcjtcclxuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XHJcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn0pKCk7XHJcbiIsIi8qXG4gKiBqUXVlcnkgRmlsZSBVcGxvYWQgUGx1Z2luXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWRcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMCwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgcmVxdWlyZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnanF1ZXJ5JywgJ2pxdWVyeS11aS91aS93aWRnZXQnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gTm9kZS9Db21tb25KUzpcbiAgICBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpLCByZXF1aXJlKCcuL3ZlbmRvci9qcXVlcnkudWkud2lkZ2V0JykpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuICB9XG59KShmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRGV0ZWN0IGZpbGUgaW5wdXQgc3VwcG9ydCwgYmFzZWQgb25cbiAgLy8gaHR0cHM6Ly92aWxqYW1pcy5jb20vMjAxMi9maWxlLXVwbG9hZC1zdXBwb3J0LW9uLW1vYmlsZS9cbiAgJC5zdXBwb3J0LmZpbGVJbnB1dCA9ICEoXG4gICAgbmV3IFJlZ0V4cChcbiAgICAgIC8vIEhhbmRsZSBkZXZpY2VzIHdoaWNoIGdpdmUgZmFsc2UgcG9zaXRpdmVzIGZvciB0aGUgZmVhdHVyZSBkZXRlY3Rpb246XG4gICAgICAnKEFuZHJvaWQgKDFcXFxcLlswMTU2XXwyXFxcXC5bMDFdKSknICtcbiAgICAgICAgJ3woV2luZG93cyBQaG9uZSAoT1MgN3w4XFxcXC4wKSl8KFhCTFdQKXwoWnVuZVdQKXwoV1BEZXNrdG9wKScgK1xuICAgICAgICAnfCh3KGViKT9PU0Jyb3dzZXIpfCh3ZWJPUyknICtcbiAgICAgICAgJ3woS2luZGxlLygxXFxcXC4wfDJcXFxcLlswNV18M1xcXFwuMCkpJ1xuICAgICkudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAvLyBGZWF0dXJlIGRldGVjdGlvbiBmb3IgYWxsIG90aGVyIGRldmljZXM6XG4gICAgJCgnPGlucHV0IHR5cGU9XCJmaWxlXCIvPicpLnByb3AoJ2Rpc2FibGVkJylcbiAgKTtcblxuICAvLyBUaGUgRmlsZVJlYWRlciBBUEkgaXMgbm90IGFjdHVhbGx5IHVzZWQsIGJ1dCB3b3JrcyBhcyBmZWF0dXJlIGRldGVjdGlvbixcbiAgLy8gYXMgc29tZSBTYWZhcmkgdmVyc2lvbnMgKDU/KSBzdXBwb3J0IFhIUiBmaWxlIHVwbG9hZHMgdmlhIHRoZSBGb3JtRGF0YSBBUEksXG4gIC8vIGJ1dCBub3Qgbm9uLW11bHRpcGFydCBYSFIgZmlsZSB1cGxvYWRzLlxuICAvLyB3aW5kb3cuWE1MSHR0cFJlcXVlc3RVcGxvYWQgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTEwLCBzbyB3ZSBjaGVjayBmb3JcbiAgLy8gd2luZG93LlByb2dyZXNzRXZlbnQgaW5zdGVhZCB0byBkZXRlY3QgWEhSMiBmaWxlIHVwbG9hZCBjYXBhYmlsaXR5OlxuICAkLnN1cHBvcnQueGhyRmlsZVVwbG9hZCA9ICEhKHdpbmRvdy5Qcm9ncmVzc0V2ZW50ICYmIHdpbmRvdy5GaWxlUmVhZGVyKTtcbiAgJC5zdXBwb3J0LnhockZvcm1EYXRhRmlsZVVwbG9hZCA9ICEhd2luZG93LkZvcm1EYXRhO1xuXG4gIC8vIERldGVjdCBzdXBwb3J0IGZvciBCbG9iIHNsaWNpbmcgKHJlcXVpcmVkIGZvciBjaHVua2VkIHVwbG9hZHMpOlxuICAkLnN1cHBvcnQuYmxvYlNsaWNlID1cbiAgICB3aW5kb3cuQmxvYiAmJlxuICAgIChCbG9iLnByb3RvdHlwZS5zbGljZSB8fFxuICAgICAgQmxvYi5wcm90b3R5cGUud2Via2l0U2xpY2UgfHxcbiAgICAgIEJsb2IucHJvdG90eXBlLm1velNsaWNlKTtcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBkcmFnIGhhbmRsZXJzIGZvciBkcmFnb3Zlci9kcmFnZW50ZXIvZHJhZ2xlYXZlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBEcmFnIGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIGdldERyYWdIYW5kbGVyKHR5cGUpIHtcbiAgICB2YXIgaXNEcmFnT3ZlciA9IHR5cGUgPT09ICdkcmFnb3Zlcic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLmRhdGFUcmFuc2ZlciA9IGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgaWYgKFxuICAgICAgICBkYXRhVHJhbnNmZXIgJiZcbiAgICAgICAgJC5pbkFycmF5KCdGaWxlcycsIGRhdGFUcmFuc2Zlci50eXBlcykgIT09IC0xICYmXG4gICAgICAgIHRoaXMuX3RyaWdnZXIodHlwZSwgJC5FdmVudCh0eXBlLCB7IGRlbGVnYXRlZEV2ZW50OiBlIH0pKSAhPT0gZmFsc2VcbiAgICAgICkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChpc0RyYWdPdmVyKSB7XG4gICAgICAgICAgZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gVGhlIGZpbGV1cGxvYWQgd2lkZ2V0IGxpc3RlbnMgZm9yIGNoYW5nZSBldmVudHMgb24gZmlsZSBpbnB1dCBmaWVsZHMgZGVmaW5lZFxuICAvLyB2aWEgZmlsZUlucHV0IHNldHRpbmcgYW5kIHBhc3RlIG9yIGRyb3AgZXZlbnRzIG9mIHRoZSBnaXZlbiBkcm9wWm9uZS5cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGRlZmF1bHQgalF1ZXJ5IFdpZGdldCBtZXRob2RzLCB0aGUgZmlsZXVwbG9hZCB3aWRnZXRcbiAgLy8gZXhwb3NlcyB0aGUgXCJhZGRcIiBhbmQgXCJzZW5kXCIgbWV0aG9kcywgdG8gYWRkIG9yIGRpcmVjdGx5IHNlbmQgZmlsZXMgdXNpbmdcbiAgLy8gdGhlIGZpbGV1cGxvYWQgQVBJLlxuICAvLyBCeSBkZWZhdWx0LCBmaWxlcyBhZGRlZCB2aWEgZmlsZSBpbnB1dCBzZWxlY3Rpb24sIHBhc3RlLCBkcmFnICYgZHJvcCBvclxuICAvLyBcImFkZFwiIG1ldGhvZCBhcmUgdXBsb2FkZWQgaW1tZWRpYXRlbHksIGJ1dCBpdCBpcyBwb3NzaWJsZSB0byBvdmVycmlkZVxuICAvLyB0aGUgXCJhZGRcIiBjYWxsYmFjayBvcHRpb24gdG8gcXVldWUgZmlsZSB1cGxvYWRzLlxuICAkLndpZGdldCgnYmx1ZWltcC5maWxldXBsb2FkJywge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC8vIFRoZSBkcm9wIHRhcmdldCBlbGVtZW50KHMpLCBieSB0aGUgZGVmYXVsdCB0aGUgY29tcGxldGUgZG9jdW1lbnQuXG4gICAgICAvLyBTZXQgdG8gbnVsbCB0byBkaXNhYmxlIGRyYWcgJiBkcm9wIHN1cHBvcnQ6XG4gICAgICBkcm9wWm9uZTogJChkb2N1bWVudCksXG4gICAgICAvLyBUaGUgcGFzdGUgdGFyZ2V0IGVsZW1lbnQocyksIGJ5IHRoZSBkZWZhdWx0IHVuZGVmaW5lZC5cbiAgICAgIC8vIFNldCB0byBhIERPTSBub2RlIG9yIGpRdWVyeSBvYmplY3QgdG8gZW5hYmxlIGZpbGUgcGFzdGluZzpcbiAgICAgIHBhc3RlWm9uZTogdW5kZWZpbmVkLFxuICAgICAgLy8gVGhlIGZpbGUgaW5wdXQgZmllbGQocyksIHRoYXQgYXJlIGxpc3RlbmVkIHRvIGZvciBjaGFuZ2UgZXZlbnRzLlxuICAgICAgLy8gSWYgdW5kZWZpbmVkLCBpdCBpcyBzZXQgdG8gdGhlIGZpbGUgaW5wdXQgZmllbGRzIGluc2lkZVxuICAgICAgLy8gb2YgdGhlIHdpZGdldCBlbGVtZW50IG9uIHBsdWdpbiBpbml0aWFsaXphdGlvbi5cbiAgICAgIC8vIFNldCB0byBudWxsIHRvIGRpc2FibGUgdGhlIGNoYW5nZSBsaXN0ZW5lci5cbiAgICAgIGZpbGVJbnB1dDogdW5kZWZpbmVkLFxuICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIGZpbGUgaW5wdXQgZmllbGQgaXMgcmVwbGFjZWQgd2l0aCBhIGNsb25lIGFmdGVyXG4gICAgICAvLyBlYWNoIGlucHV0IGZpZWxkIGNoYW5nZSBldmVudC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgaWZyYW1lIHRyYW5zcG9ydFxuICAgICAgLy8gcXVldWVzIGFuZCBhbGxvd3MgY2hhbmdlIGV2ZW50cyB0byBiZSBmaXJlZCBmb3IgdGhlIHNhbWUgZmlsZVxuICAgICAgLy8gc2VsZWN0aW9uLCBidXQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gZmFsc2U6XG4gICAgICByZXBsYWNlRmlsZUlucHV0OiB0cnVlLFxuICAgICAgLy8gVGhlIHBhcmFtZXRlciBuYW1lIGZvciB0aGUgZmlsZSBmb3JtIGRhdGEgKHRoZSByZXF1ZXN0IGFyZ3VtZW50IG5hbWUpLlxuICAgICAgLy8gSWYgdW5kZWZpbmVkIG9yIGVtcHR5LCB0aGUgbmFtZSBwcm9wZXJ0eSBvZiB0aGUgZmlsZSBpbnB1dCBmaWVsZCBpc1xuICAgICAgLy8gdXNlZCwgb3IgXCJmaWxlc1tdXCIgaWYgdGhlIGZpbGUgaW5wdXQgbmFtZSBwcm9wZXJ0eSBpcyBhbHNvIGVtcHR5LFxuICAgICAgLy8gY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3M6XG4gICAgICBwYXJhbU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGVhY2ggZmlsZSBvZiBhIHNlbGVjdGlvbiBpcyB1cGxvYWRlZCB1c2luZyBhbiBpbmRpdmlkdWFsXG4gICAgICAvLyByZXF1ZXN0IGZvciBYSFIgdHlwZSB1cGxvYWRzLiBTZXQgdG8gZmFsc2UgdG8gdXBsb2FkIGZpbGVcbiAgICAgIC8vIHNlbGVjdGlvbnMgaW4gb25lIHJlcXVlc3QgZWFjaDpcbiAgICAgIHNpbmdsZUZpbGVVcGxvYWRzOiB0cnVlLFxuICAgICAgLy8gVG8gbGltaXQgdGhlIG51bWJlciBvZiBmaWxlcyB1cGxvYWRlZCB3aXRoIG9uZSBYSFIgcmVxdWVzdCxcbiAgICAgIC8vIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwOlxuICAgICAgbGltaXRNdWx0aUZpbGVVcGxvYWRzOiB1bmRlZmluZWQsXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbiBsaW1pdHMgdGhlIG51bWJlciBvZiBmaWxlcyB1cGxvYWRlZCB3aXRoIG9uZVxuICAgICAgLy8gWEhSIHJlcXVlc3QgdG8ga2VlcCB0aGUgcmVxdWVzdCBzaXplIHVuZGVyIG9yIGVxdWFsIHRvIHRoZSBkZWZpbmVkXG4gICAgICAvLyBsaW1pdCBpbiBieXRlczpcbiAgICAgIGxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZTogdW5kZWZpbmVkLFxuICAgICAgLy8gTXVsdGlwYXJ0IGZpbGUgdXBsb2FkcyBhZGQgYSBudW1iZXIgb2YgYnl0ZXMgdG8gZWFjaCB1cGxvYWRlZCBmaWxlLFxuICAgICAgLy8gdGhlcmVmb3JlIHRoZSBmb2xsb3dpbmcgb3B0aW9uIGFkZHMgYW4gb3ZlcmhlYWQgZm9yIGVhY2ggZmlsZSB1c2VkXG4gICAgICAvLyBpbiB0aGUgbGltaXRNdWx0aUZpbGVVcGxvYWRTaXplIGNvbmZpZ3VyYXRpb246XG4gICAgICBsaW1pdE11bHRpRmlsZVVwbG9hZFNpemVPdmVyaGVhZDogNTEyLFxuICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRydWUgdG8gaXNzdWUgYWxsIGZpbGUgdXBsb2FkIHJlcXVlc3RzXG4gICAgICAvLyBpbiBhIHNlcXVlbnRpYWwgb3JkZXI6XG4gICAgICBzZXF1ZW50aWFsVXBsb2FkczogZmFsc2UsXG4gICAgICAvLyBUbyBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdXBsb2FkcyxcbiAgICAgIC8vIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwOlxuICAgICAgbGltaXRDb25jdXJyZW50VXBsb2FkczogdW5kZWZpbmVkLFxuICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRydWUgdG8gZm9yY2UgaWZyYW1lIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgZm9yY2VJZnJhbWVUcmFuc3BvcnQ6IGZhbHNlLFxuICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRoZSBsb2NhdGlvbiBvZiBhIHJlZGlyZWN0IHVybCBvbiB0aGVcbiAgICAgIC8vIG9yaWdpbiBzZXJ2ZXIsIGZvciBjcm9zcy1kb21haW4gaWZyYW1lIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgcmVkaXJlY3Q6IHVuZGVmaW5lZCxcbiAgICAgIC8vIFRoZSBwYXJhbWV0ZXIgbmFtZSBmb3IgdGhlIHJlZGlyZWN0IHVybCwgc2VudCBhcyBwYXJ0IG9mIHRoZSBmb3JtXG4gICAgICAvLyBkYXRhIGFuZCBzZXQgdG8gJ3JlZGlyZWN0JyBpZiB0aGlzIG9wdGlvbiBpcyBlbXB0eTpcbiAgICAgIHJlZGlyZWN0UGFyYW1OYW1lOiB1bmRlZmluZWQsXG4gICAgICAvLyBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gdGhlIGxvY2F0aW9uIG9mIGEgcG9zdE1lc3NhZ2Ugd2luZG93LFxuICAgICAgLy8gdG8gZW5hYmxlIHBvc3RNZXNzYWdlIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgcG9zdE1lc3NhZ2U6IHVuZGVmaW5lZCxcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIFhIUiBmaWxlIHVwbG9hZHMgYXJlIHNlbnQgYXMgbXVsdGlwYXJ0L2Zvcm0tZGF0YS5cbiAgICAgIC8vIFRoZSBpZnJhbWUgdHJhbnNwb3J0IGlzIGFsd2F5cyB1c2luZyBtdWx0aXBhcnQvZm9ybS1kYXRhLlxuICAgICAgLy8gU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBub24tbXVsdGlwYXJ0IFhIUiB1cGxvYWRzOlxuICAgICAgbXVsdGlwYXJ0OiB0cnVlLFxuICAgICAgLy8gVG8gdXBsb2FkIGxhcmdlIGZpbGVzIGluIHNtYWxsZXIgY2h1bmtzLCBzZXQgdGhlIGZvbGxvd2luZyBvcHRpb25cbiAgICAgIC8vIHRvIGEgcHJlZmVycmVkIG1heGltdW0gY2h1bmsgc2l6ZS4gSWYgc2V0IHRvIDAsIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgICAgLy8gb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgcmVxdWlyZWQgQmxvYiBBUEksIGZpbGVzIHdpbGxcbiAgICAgIC8vIGJlIHVwbG9hZGVkIGFzIGEgd2hvbGUuXG4gICAgICBtYXhDaHVua1NpemU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIFdoZW4gYSBub24tbXVsdGlwYXJ0IHVwbG9hZCBvciBhIGNodW5rZWQgbXVsdGlwYXJ0IHVwbG9hZCBoYXMgYmVlblxuICAgICAgLy8gYWJvcnRlZCwgdGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVzdW1lIHRoZSB1cGxvYWQgYnkgc2V0dGluZ1xuICAgICAgLy8gaXQgdG8gdGhlIHNpemUgb2YgdGhlIGFscmVhZHkgdXBsb2FkZWQgYnl0ZXMuIFRoaXMgb3B0aW9uIGlzIG1vc3RcbiAgICAgIC8vIHVzZWZ1bCB3aGVuIG1vZGlmeWluZyB0aGUgb3B0aW9ucyBvYmplY3QgaW5zaWRlIG9mIHRoZSBcImFkZFwiIG9yXG4gICAgICAvLyBcInNlbmRcIiBjYWxsYmFja3MsIGFzIHRoZSBvcHRpb25zIGFyZSBjbG9uZWQgZm9yIGVhY2ggZmlsZSB1cGxvYWQuXG4gICAgICB1cGxvYWRlZEJ5dGVzOiB1bmRlZmluZWQsXG4gICAgICAvLyBCeSBkZWZhdWx0LCBmYWlsZWQgKGFib3J0IG9yIGVycm9yKSBmaWxlIHVwbG9hZHMgYXJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgIC8vIGdsb2JhbCBwcm9ncmVzcyBjYWxjdWxhdGlvbi4gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIGZhbHNlIHRvXG4gICAgICAvLyBwcmV2ZW50IHJlY2FsY3VsYXRpbmcgdGhlIGdsb2JhbCBwcm9ncmVzcyBkYXRhOlxuICAgICAgcmVjYWxjdWxhdGVQcm9ncmVzczogdHJ1ZSxcbiAgICAgIC8vIEludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byBjYWxjdWxhdGUgYW5kIHRyaWdnZXIgcHJvZ3Jlc3MgZXZlbnRzOlxuICAgICAgcHJvZ3Jlc3NJbnRlcnZhbDogMTAwLFxuICAgICAgLy8gSW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIGNhbGN1bGF0ZSBwcm9ncmVzcyBiaXRyYXRlOlxuICAgICAgYml0cmF0ZUludGVydmFsOiA1MDAsXG4gICAgICAvLyBCeSBkZWZhdWx0LCB1cGxvYWRzIGFyZSBzdGFydGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhZGRpbmcgZmlsZXM6XG4gICAgICBhdXRvVXBsb2FkOiB0cnVlLFxuICAgICAgLy8gQnkgZGVmYXVsdCwgZHVwbGljYXRlIGZpbGUgbmFtZXMgYXJlIGV4cGVjdGVkIHRvIGJlIGhhbmRsZWQgb25cbiAgICAgIC8vIHRoZSBzZXJ2ZXItc2lkZS4gSWYgdGhpcyBpcyBub3QgcG9zc2libGUgKGUuZy4gd2hlbiB1cGxvYWRpbmdcbiAgICAgIC8vIGZpbGVzIGRpcmVjdGx5IHRvIEFtYXpvbiBTMyksIHRoZSBmb2xsb3dpbmcgb3B0aW9uIGNhbiBiZSBzZXQgdG9cbiAgICAgIC8vIGFuIGVtcHR5IG9iamVjdCBvciBhbiBvYmplY3QgbWFwcGluZyBleGlzdGluZyBmaWxlbmFtZXMsIGUuZy46XG4gICAgICAvLyB7IFwiaW1hZ2UuanBnXCI6IHRydWUsIFwiaW1hZ2UgKDEpLmpwZ1wiOiB0cnVlIH1cbiAgICAgIC8vIElmIGl0IGlzIHNldCwgYWxsIGZpbGVzIHdpbGwgYmUgdXBsb2FkZWQgd2l0aCB1bmlxdWUgZmlsZW5hbWVzLFxuICAgICAgLy8gYWRkaW5nIGluY3JlYXNpbmcgbnVtYmVyIHN1ZmZpeGVzIGlmIG5lY2Vzc2FyeSwgZS5nLjpcbiAgICAgIC8vIFwiaW1hZ2UgKDIpLmpwZ1wiXG4gICAgICB1bmlxdWVGaWxlbmFtZXM6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gRXJyb3IgYW5kIGluZm8gbWVzc2FnZXM6XG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICB1cGxvYWRlZEJ5dGVzOiAnVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZSdcbiAgICAgIH0sXG5cbiAgICAgIC8vIFRyYW5zbGF0aW9uIGZ1bmN0aW9uLCBnZXRzIHRoZSBtZXNzYWdlIGtleSB0byBiZSB0cmFuc2xhdGVkXG4gICAgICAvLyBhbmQgYW4gb2JqZWN0IHdpdGggY29udGV4dCBzcGVjaWZpYyBkYXRhIGFzIGFyZ3VtZW50czpcbiAgICAgIGkxOG46IGZ1bmN0aW9uIChtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1ttZXNzYWdlXSB8fCBtZXNzYWdlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgJC5lYWNoKGNvbnRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3snICsga2V5ICsgJ30nLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9LFxuXG4gICAgICAvLyBBZGRpdGlvbmFsIGZvcm0gZGF0YSB0byBiZSBzZW50IGFsb25nIHdpdGggdGhlIGZpbGUgdXBsb2FkcyBjYW4gYmUgc2V0XG4gICAgICAvLyB1c2luZyB0aGlzIG9wdGlvbiwgd2hpY2ggYWNjZXB0cyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbmFtZSBhbmRcbiAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXMsIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHN1Y2ggYW4gYXJyYXksIGEgRm9ybURhdGFcbiAgICAgIC8vIG9iamVjdCAoZm9yIFhIUiBmaWxlIHVwbG9hZHMpLCBvciBhIHNpbXBsZSBvYmplY3QuXG4gICAgICAvLyBUaGUgZm9ybSBvZiB0aGUgZmlyc3QgZmlsZUlucHV0IGlzIGdpdmVuIGFzIHBhcmFtZXRlciB0byB0aGUgZnVuY3Rpb246XG4gICAgICBmb3JtRGF0YTogZnVuY3Rpb24gKGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGZvcm0uc2VyaWFsaXplQXJyYXkoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFRoZSBhZGQgY2FsbGJhY2sgaXMgaW52b2tlZCBhcyBzb29uIGFzIGZpbGVzIGFyZSBhZGRlZCB0byB0aGUgZmlsZXVwbG9hZFxuICAgICAgLy8gd2lkZ2V0ICh2aWEgZmlsZSBpbnB1dCBzZWxlY3Rpb24sIGRyYWcgJiBkcm9wLCBwYXN0ZSBvciBhZGQgQVBJIGNhbGwpLlxuICAgICAgLy8gSWYgdGhlIHNpbmdsZUZpbGVVcGxvYWRzIG9wdGlvbiBpcyBlbmFibGVkLCB0aGlzIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgIC8vIGNhbGxlZCBvbmNlIGZvciBlYWNoIGZpbGUgaW4gdGhlIHNlbGVjdGlvbiBmb3IgWEhSIGZpbGUgdXBsb2FkcywgZWxzZVxuICAgICAgLy8gb25jZSBmb3IgZWFjaCBmaWxlIHNlbGVjdGlvbi5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdXBsb2FkIHN0YXJ0cyB3aGVuIHRoZSBzdWJtaXQgbWV0aG9kIGlzIGludm9rZWQgb24gdGhlIGRhdGEgcGFyYW1ldGVyLlxuICAgICAgLy8gVGhlIGRhdGEgb2JqZWN0IGNvbnRhaW5zIGEgZmlsZXMgcHJvcGVydHkgaG9sZGluZyB0aGUgYWRkZWQgZmlsZXNcbiAgICAgIC8vIGFuZCBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHBsdWdpbiBvcHRpb25zIGFzIHdlbGwgYXMgZGVmaW5lIGFqYXggc2V0dGluZ3MuXG4gICAgICAvL1xuICAgICAgLy8gTGlzdGVuZXJzIGZvciB0aGlzIGNhbGxiYWNrIGNhbiBhbHNvIGJlIGJvdW5kIHRoZSBmb2xsb3dpbmcgd2F5OlxuICAgICAgLy8gLm9uKCdmaWxldXBsb2FkYWRkJywgZnVuYyk7XG4gICAgICAvL1xuICAgICAgLy8gZGF0YS5zdWJtaXQoKSByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgYW5kIGFsbG93cyB0byBhdHRhY2ggYWRkaXRpb25hbFxuICAgICAgLy8gaGFuZGxlcnMgdXNpbmcgalF1ZXJ5J3MgRGVmZXJyZWQgY2FsbGJhY2tzOlxuICAgICAgLy8gZGF0YS5zdWJtaXQoKS5kb25lKGZ1bmMpLmZhaWwoZnVuYykuYWx3YXlzKGZ1bmMpO1xuICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YS5hdXRvVXBsb2FkIHx8XG4gICAgICAgICAgKGRhdGEuYXV0b1VwbG9hZCAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICQodGhpcykuZmlsZXVwbG9hZCgnb3B0aW9uJywgJ2F1dG9VcGxvYWQnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGF0YS5wcm9jZXNzKCkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkYXRhLnN1Ym1pdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBPdGhlciBjYWxsYmFja3M6XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciB0aGUgc3VibWl0IGV2ZW50IG9mIGVhY2ggZmlsZSB1cGxvYWQ6XG4gICAgICAvLyBzdWJtaXQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLm9uKCdmaWxldXBsb2Fkc3VibWl0JywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciB0aGUgc3RhcnQgb2YgZWFjaCBmaWxlIHVwbG9hZCByZXF1ZXN0OlxuICAgICAgLy8gc2VuZDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAub24oJ2ZpbGV1cGxvYWRzZW5kJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBzdWNjZXNzZnVsIHVwbG9hZHM6XG4gICAgICAvLyBkb25lOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZGRvbmUnLCBmdW5jKTtcblxuICAgICAgLy8gQ2FsbGJhY2sgZm9yIGZhaWxlZCAoYWJvcnQgb3IgZXJyb3IpIHVwbG9hZHM6XG4gICAgICAvLyBmYWlsOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZGZhaWwnLCBmdW5jKTtcblxuICAgICAgLy8gQ2FsbGJhY2sgZm9yIGNvbXBsZXRlZCAoc3VjY2VzcywgYWJvcnQgb3IgZXJyb3IpIHJlcXVlc3RzOlxuICAgICAgLy8gYWx3YXlzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZGFsd2F5cycsIGZ1bmMpO1xuXG4gICAgICAvLyBDYWxsYmFjayBmb3IgdXBsb2FkIHByb2dyZXNzIGV2ZW50czpcbiAgICAgIC8vIHByb2dyZXNzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZHByb2dyZXNzJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBnbG9iYWwgdXBsb2FkIHByb2dyZXNzIGV2ZW50czpcbiAgICAgIC8vIHByb2dyZXNzYWxsOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZHByb2dyZXNzYWxsJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciB1cGxvYWRzIHN0YXJ0LCBlcXVpdmFsZW50IHRvIHRoZSBnbG9iYWwgYWpheFN0YXJ0IGV2ZW50OlxuICAgICAgLy8gc3RhcnQ6IGZ1bmN0aW9uIChlKSB7fSwgLy8gLm9uKCdmaWxldXBsb2Fkc3RhcnQnLCBmdW5jKTtcblxuICAgICAgLy8gQ2FsbGJhY2sgZm9yIHVwbG9hZHMgc3RvcCwgZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdG9wIGV2ZW50OlxuICAgICAgLy8gc3RvcDogZnVuY3Rpb24gKGUpIHt9LCAvLyAub24oJ2ZpbGV1cGxvYWRzdG9wJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBjaGFuZ2UgZXZlbnRzIG9mIHRoZSBmaWxlSW5wdXQocyk6XG4gICAgICAvLyBjaGFuZ2U6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLm9uKCdmaWxldXBsb2FkY2hhbmdlJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBwYXN0ZSBldmVudHMgdG8gdGhlIHBhc3RlWm9uZShzKTpcbiAgICAgIC8vIHBhc3RlOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZHBhc3RlJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBkcm9wIGV2ZW50cyBvZiB0aGUgZHJvcFpvbmUocyk6XG4gICAgICAvLyBkcm9wOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZGRyb3AnLCBmdW5jKTtcblxuICAgICAgLy8gQ2FsbGJhY2sgZm9yIGRyYWdvdmVyIGV2ZW50cyBvZiB0aGUgZHJvcFpvbmUocyk6XG4gICAgICAvLyBkcmFnb3ZlcjogZnVuY3Rpb24gKGUpIHt9LCAvLyAub24oJ2ZpbGV1cGxvYWRkcmFnb3ZlcicsIGZ1bmMpO1xuXG4gICAgICAvLyBDYWxsYmFjayBiZWZvcmUgdGhlIHN0YXJ0IG9mIGVhY2ggY2h1bmsgdXBsb2FkIHJlcXVlc3QgKGJlZm9yZSBmb3JtIGRhdGEgaW5pdGlhbGl6YXRpb24pOlxuICAgICAgLy8gY2h1bmtiZWZvcmVzZW5kOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZGNodW5rYmVmb3Jlc2VuZCcsIGZ1bmMpO1xuXG4gICAgICAvLyBDYWxsYmFjayBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggY2h1bmsgdXBsb2FkIHJlcXVlc3Q6XG4gICAgICAvLyBjaHVua3NlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLm9uKCdmaWxldXBsb2FkY2h1bmtzZW5kJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBzdWNjZXNzZnVsIGNodW5rIHVwbG9hZHM6XG4gICAgICAvLyBjaHVua2RvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLm9uKCdmaWxldXBsb2FkY2h1bmtkb25lJywgZnVuYyk7XG5cbiAgICAgIC8vIENhbGxiYWNrIGZvciBmYWlsZWQgKGFib3J0IG9yIGVycm9yKSBjaHVuayB1cGxvYWRzOlxuICAgICAgLy8gY2h1bmtmYWlsOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5vbignZmlsZXVwbG9hZGNodW5rZmFpbCcsIGZ1bmMpO1xuXG4gICAgICAvLyBDYWxsYmFjayBmb3IgY29tcGxldGVkIChzdWNjZXNzLCBhYm9ydCBvciBlcnJvcikgY2h1bmsgdXBsb2FkIHJlcXVlc3RzOlxuICAgICAgLy8gY2h1bmthbHdheXM6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLm9uKCdmaWxldXBsb2FkY2h1bmthbHdheXMnLCBmdW5jKTtcblxuICAgICAgLy8gVGhlIHBsdWdpbiBvcHRpb25zIGFyZSB1c2VkIGFzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGFqYXggY2FsbHMuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSBqUXVlcnkgYWpheCBzZXR0aW5ncyByZXF1aXJlZCBmb3IgdGhlIGZpbGUgdXBsb2FkczpcbiAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgIHRpbWVvdXQ6IDBcbiAgICB9LFxuXG4gICAgLy8galF1ZXJ5IHZlcnNpb25zIGJlZm9yZSAxLjggcmVxdWlyZSBwcm9taXNlLnBpcGUgaWYgdGhlIHJldHVybiB2YWx1ZSBpc1xuICAgIC8vIHVzZWQsIGFzIHByb21pc2UudGhlbiBpbiBvbGRlciB2ZXJzaW9ucyBoYXMgYSBkaWZmZXJlbnQgYmVoYXZpb3IsIHNlZTpcbiAgICAvLyBodHRwczovL2Jsb2cuanF1ZXJ5LmNvbS8yMDEyLzA4LzA5L2pxdWVyeS0xLTgtcmVsZWFzZWQvXG4gICAgLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExMDEwXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvalF1ZXJ5LUZpbGUtVXBsb2FkL3B1bGwvMzQzNVxuICAgIF9wcm9taXNlUGlwZTogKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJ0cyA9ICQuZm4uanF1ZXJ5LnNwbGl0KCcuJyk7XG4gICAgICByZXR1cm4gTnVtYmVyKHBhcnRzWzBdKSA+IDEgfHwgTnVtYmVyKHBhcnRzWzFdKSA+IDcgPyAndGhlbicgOiAncGlwZSc7XG4gICAgfSkoKSxcblxuICAgIC8vIEEgbGlzdCBvZiBvcHRpb25zIHRoYXQgcmVxdWlyZSByZWluaXRpYWxpemluZyBldmVudCBsaXN0ZW5lcnMgYW5kL29yXG4gICAgLy8gc3BlY2lhbCBpbml0aWFsaXphdGlvbiBjb2RlOlxuICAgIF9zcGVjaWFsT3B0aW9uczogW1xuICAgICAgJ2ZpbGVJbnB1dCcsXG4gICAgICAnZHJvcFpvbmUnLFxuICAgICAgJ3Bhc3RlWm9uZScsXG4gICAgICAnbXVsdGlwYXJ0JyxcbiAgICAgICdmb3JjZUlmcmFtZVRyYW5zcG9ydCdcbiAgICBdLFxuXG4gICAgX2Jsb2JTbGljZTpcbiAgICAgICQuc3VwcG9ydC5ibG9iU2xpY2UgJiZcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZSB8fCB0aGlzLndlYmtpdFNsaWNlIHx8IHRoaXMubW96U2xpY2U7XG4gICAgICAgIHJldHVybiBzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSxcblxuICAgIF9CaXRyYXRlVGltZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgICB0aGlzLmJpdHJhdGUgPSAwO1xuICAgICAgdGhpcy5nZXRCaXRyYXRlID0gZnVuY3Rpb24gKG5vdywgbG9hZGVkLCBpbnRlcnZhbCkge1xuICAgICAgICB2YXIgdGltZURpZmYgPSBub3cgLSB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKCF0aGlzLmJpdHJhdGUgfHwgIWludGVydmFsIHx8IHRpbWVEaWZmID4gaW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLmJpdHJhdGUgPSAobG9hZGVkIC0gdGhpcy5sb2FkZWQpICogKDEwMDAgLyB0aW1lRGlmZikgKiA4O1xuICAgICAgICAgIHRoaXMubG9hZGVkID0gbG9hZGVkO1xuICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJpdHJhdGU7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBfaXNYSFJVcGxvYWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAhb3B0aW9ucy5mb3JjZUlmcmFtZVRyYW5zcG9ydCAmJlxuICAgICAgICAoKCFvcHRpb25zLm11bHRpcGFydCAmJiAkLnN1cHBvcnQueGhyRmlsZVVwbG9hZCkgfHxcbiAgICAgICAgICAkLnN1cHBvcnQueGhyRm9ybURhdGFGaWxlVXBsb2FkKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgX2dldEZvcm1EYXRhOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGZvcm1EYXRhO1xuICAgICAgaWYgKCQudHlwZShvcHRpb25zLmZvcm1EYXRhKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mb3JtRGF0YShvcHRpb25zLmZvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKCQuaXNBcnJheShvcHRpb25zLmZvcm1EYXRhKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mb3JtRGF0YTtcbiAgICAgIH1cbiAgICAgIGlmICgkLnR5cGUob3B0aW9ucy5mb3JtRGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvcm1EYXRhID0gW107XG4gICAgICAgICQuZWFjaChvcHRpb25zLmZvcm1EYXRhLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICBfZ2V0VG90YWw6IGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICQuZWFjaChmaWxlcywgZnVuY3Rpb24gKGluZGV4LCBmaWxlKSB7XG4gICAgICAgIHRvdGFsICs9IGZpbGUuc2l6ZSB8fCAxO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIF9pbml0UHJvZ3Jlc3NPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBwcm9ncmVzcyA9IHtcbiAgICAgICAgbG9hZGVkOiAwLFxuICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgYml0cmF0ZTogMFxuICAgICAgfTtcbiAgICAgIGlmIChvYmouX3Byb2dyZXNzKSB7XG4gICAgICAgICQuZXh0ZW5kKG9iai5fcHJvZ3Jlc3MsIHByb2dyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRSZXNwb25zZU9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIHByb3A7XG4gICAgICBpZiAob2JqLl9yZXNwb25zZSkge1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqLl9yZXNwb25zZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLl9yZXNwb25zZSwgcHJvcCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX3Jlc3BvbnNlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLl9yZXNwb25zZSA9IHt9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25Qcm9ncmVzczogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIGxvYWRlZDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRhdGEuX3RpbWUgJiZcbiAgICAgICAgICBkYXRhLnByb2dyZXNzSW50ZXJ2YWwgJiZcbiAgICAgICAgICBub3cgLSBkYXRhLl90aW1lIDwgZGF0YS5wcm9ncmVzc0ludGVydmFsICYmXG4gICAgICAgICAgZS5sb2FkZWQgIT09IGUudG90YWxcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuX3RpbWUgPSBub3c7XG4gICAgICAgIGxvYWRlZCA9XG4gICAgICAgICAgTWF0aC5mbG9vcihcbiAgICAgICAgICAgIChlLmxvYWRlZCAvIGUudG90YWwpICogKGRhdGEuY2h1bmtTaXplIHx8IGRhdGEuX3Byb2dyZXNzLnRvdGFsKVxuICAgICAgICAgICkgKyAoZGF0YS51cGxvYWRlZEJ5dGVzIHx8IDApO1xuICAgICAgICAvLyBBZGQgdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXNseSBsb2FkZWQgc3RhdGVcbiAgICAgICAgLy8gdG8gdGhlIGdsb2JhbCBsb2FkZWQgY291bnRlcjpcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkICs9IGxvYWRlZCAtIGRhdGEuX3Byb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MuYml0cmF0ZSA9IHRoaXMuX2JpdHJhdGVUaW1lci5nZXRCaXRyYXRlKFxuICAgICAgICAgIG5vdyxcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQsXG4gICAgICAgICAgZGF0YS5iaXRyYXRlSW50ZXJ2YWxcbiAgICAgICAgKTtcbiAgICAgICAgZGF0YS5fcHJvZ3Jlc3MubG9hZGVkID0gZGF0YS5sb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgIGRhdGEuX3Byb2dyZXNzLmJpdHJhdGUgPSBkYXRhLmJpdHJhdGUgPSBkYXRhLl9iaXRyYXRlVGltZXIuZ2V0Qml0cmF0ZShcbiAgICAgICAgICBub3csXG4gICAgICAgICAgbG9hZGVkLFxuICAgICAgICAgIGRhdGEuYml0cmF0ZUludGVydmFsXG4gICAgICAgICk7XG4gICAgICAgIC8vIFRyaWdnZXIgYSBjdXN0b20gcHJvZ3Jlc3MgZXZlbnQgd2l0aCBhIHRvdGFsIGRhdGEgcHJvcGVydHkgc2V0XG4gICAgICAgIC8vIHRvIHRoZSBmaWxlIHNpemUocykgb2YgdGhlIGN1cnJlbnQgdXBsb2FkIGFuZCBhIGxvYWRlZCBkYXRhXG4gICAgICAgIC8vIHByb3BlcnR5IGNhbGN1bGF0ZWQgYWNjb3JkaW5nbHk6XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXG4gICAgICAgICAgJ3Byb2dyZXNzJyxcbiAgICAgICAgICAkLkV2ZW50KCdwcm9ncmVzcycsIHsgZGVsZWdhdGVkRXZlbnQ6IGUgfSksXG4gICAgICAgICAgZGF0YVxuICAgICAgICApO1xuICAgICAgICAvLyBUcmlnZ2VyIGEgZ2xvYmFsIHByb2dyZXNzIGV2ZW50IGZvciBhbGwgY3VycmVudCBmaWxlIHVwbG9hZHMsXG4gICAgICAgIC8vIGluY2x1ZGluZyBhamF4IGNhbGxzIHF1ZXVlZCBmb3Igc2VxdWVudGlhbCBmaWxlIHVwbG9hZHM6XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXG4gICAgICAgICAgJ3Byb2dyZXNzYWxsJyxcbiAgICAgICAgICAkLkV2ZW50KCdwcm9ncmVzc2FsbCcsIHsgZGVsZWdhdGVkRXZlbnQ6IGUgfSksXG4gICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRQcm9ncmVzc0xpc3RlbmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICB4aHIgPSBvcHRpb25zLnhociA/IG9wdGlvbnMueGhyKCkgOiAkLmFqYXhTZXR0aW5ncy54aHIoKTtcbiAgICAgIC8vIEFjY2Vzc3MgdG8gdGhlIG5hdGl2ZSBYSFIgb2JqZWN0IGlzIHJlcXVpcmVkIHRvIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIC8vIGZvciB0aGUgdXBsb2FkIHByb2dyZXNzIGV2ZW50OlxuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgJCh4aHIudXBsb2FkKS5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBvZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHByb2dyZXNzIGV2ZW50IHByb3BlcnRpZXMgZ2V0IGNvcGllZCBvdmVyOlxuICAgICAgICAgIGUubGVuZ3RoQ29tcHV0YWJsZSA9IG9lLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgZS5sb2FkZWQgPSBvZS5sb2FkZWQ7XG4gICAgICAgICAgZS50b3RhbCA9IG9lLnRvdGFsO1xuICAgICAgICAgIHRoYXQuX29uUHJvZ3Jlc3MoZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLnhociA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGVpbml0UHJvZ3Jlc3NMaXN0ZW5lcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA/IG9wdGlvbnMueGhyKCkgOiAkLmFqYXhTZXR0aW5ncy54aHIoKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgICQoeGhyLnVwbG9hZCkub2ZmKCdwcm9ncmVzcycpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaXNJbnN0YW5jZU9mOiBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG4gICAgICAvLyBDcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGNoZWNrXG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nO1xuICAgIH0sXG5cbiAgICBfZ2V0VW5pcXVlRmlsZW5hbWU6IGZ1bmN0aW9uIChuYW1lLCBtYXApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmIChtYXBbbmFtZV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyg/OiBcXCgoW1xcZF0rKVxcKSk/KFxcLlteLl0rKT8kLywgZnVuY3Rpb24gKFxuICAgICAgICAgIF8sXG4gICAgICAgICAgcDEsXG4gICAgICAgICAgcDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcDEgPyBOdW1iZXIocDEpICsgMSA6IDE7XG4gICAgICAgICAgdmFyIGV4dCA9IHAyIHx8ICcnO1xuICAgICAgICAgIHJldHVybiAnICgnICsgaW5kZXggKyAnKScgKyBleHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VW5pcXVlRmlsZW5hbWUobmFtZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIG1hcFtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuXG4gICAgX2luaXRYSFJEYXRhOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgZmlsZSA9IG9wdGlvbnMuZmlsZXNbMF0sXG4gICAgICAgIC8vIElnbm9yZSBub24tbXVsdGlwYXJ0IHNldHRpbmcgaWYgbm90IHN1cHBvcnRlZDpcbiAgICAgICAgbXVsdGlwYXJ0ID0gb3B0aW9ucy5tdWx0aXBhcnQgfHwgISQuc3VwcG9ydC54aHJGaWxlVXBsb2FkLFxuICAgICAgICBwYXJhbU5hbWUgPVxuICAgICAgICAgICQudHlwZShvcHRpb25zLnBhcmFtTmFtZSkgPT09ICdhcnJheSdcbiAgICAgICAgICAgID8gb3B0aW9ucy5wYXJhbU5hbWVbMF1cbiAgICAgICAgICAgIDogb3B0aW9ucy5wYXJhbU5hbWU7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRSYW5nZSkge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtUmFuZ2UnXSA9IG9wdGlvbnMuY29udGVudFJhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKCFtdWx0aXBhcnQgfHwgb3B0aW9ucy5ibG9iIHx8ICF0aGlzLl9pc0luc3RhbmNlT2YoJ0ZpbGUnLCBmaWxlKSkge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtRGlzcG9zaXRpb24nXSA9XG4gICAgICAgICAgJ2F0dGFjaG1lbnQ7IGZpbGVuYW1lPVwiJyArXG4gICAgICAgICAgZW5jb2RlVVJJKGZpbGUudXBsb2FkTmFtZSB8fCBmaWxlLm5hbWUpICtcbiAgICAgICAgICAnXCInO1xuICAgICAgfVxuICAgICAgaWYgKCFtdWx0aXBhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5jb250ZW50VHlwZSA9IGZpbGUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5ibG9iIHx8IGZpbGU7XG4gICAgICB9IGVsc2UgaWYgKCQuc3VwcG9ydC54aHJGb3JtRGF0YUZpbGVVcGxvYWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyB3aW5kb3cucG9zdE1lc3NhZ2UgZG9lcyBub3QgYWxsb3cgc2VuZGluZyBGb3JtRGF0YVxuICAgICAgICAgIC8vIG9iamVjdHMsIHNvIHdlIGp1c3QgYWRkIHRoZSBGaWxlL0Jsb2Igb2JqZWN0cyB0b1xuICAgICAgICAgIC8vIHRoZSBmb3JtRGF0YSBhcnJheSBhbmQgbGV0IHRoZSBwb3N0TWVzc2FnZSB3aW5kb3dcbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIEZvcm1EYXRhIG9iamVjdCBvdXQgb2YgdGhpcyBhcnJheTpcbiAgICAgICAgICBmb3JtRGF0YSA9IHRoaXMuX2dldEZvcm1EYXRhKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmJsb2IpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmJsb2JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVhY2gob3B0aW9ucy5maWxlcywgZnVuY3Rpb24gKGluZGV4LCBmaWxlKSB7XG4gICAgICAgICAgICAgIGZvcm1EYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6XG4gICAgICAgICAgICAgICAgICAoJC50eXBlKG9wdGlvbnMucGFyYW1OYW1lKSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtTmFtZVtpbmRleF0pIHx8XG4gICAgICAgICAgICAgICAgICBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZpbGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoYXQuX2lzSW5zdGFuY2VPZignRm9ybURhdGEnLCBvcHRpb25zLmZvcm1EYXRhKSkge1xuICAgICAgICAgICAgZm9ybURhdGEgPSBvcHRpb25zLmZvcm1EYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMuX2dldEZvcm1EYXRhKG9wdGlvbnMpLCBmdW5jdGlvbiAoaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChmaWVsZC5uYW1lLCBmaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYmxvYikge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgICBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgIG9wdGlvbnMuYmxvYixcbiAgICAgICAgICAgICAgZmlsZS51cGxvYWROYW1lIHx8IGZpbGUubmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMuZmlsZXMsIGZ1bmN0aW9uIChpbmRleCwgZmlsZSkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGFsbG93cyB0aGUgdGVzdHMgdG8gcnVuIHdpdGhcbiAgICAgICAgICAgICAgLy8gZHVtbXkgb2JqZWN0czpcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoYXQuX2lzSW5zdGFuY2VPZignRmlsZScsIGZpbGUpIHx8XG4gICAgICAgICAgICAgICAgdGhhdC5faXNJbnN0YW5jZU9mKCdCbG9iJywgZmlsZSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gZmlsZS51cGxvYWROYW1lIHx8IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bmlxdWVGaWxlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gdGhhdC5fZ2V0VW5pcXVlRmlsZW5hbWUoXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVuaXF1ZUZpbGVuYW1lc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgKCQudHlwZShvcHRpb25zLnBhcmFtTmFtZSkgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWVbaW5kZXhdKSB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWUsXG4gICAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgICAgZmlsZU5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5kYXRhID0gZm9ybURhdGE7XG4gICAgICB9XG4gICAgICAvLyBCbG9iIHJlZmVyZW5jZSBpcyBub3QgbmVlZGVkIGFueW1vcmUsIGZyZWUgbWVtb3J5OlxuICAgICAgb3B0aW9ucy5ibG9iID0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2luaXRJZnJhbWVTZXR0aW5nczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YXJnZXRIb3N0ID0gJCgnPGE+PC9hPicpLnByb3AoJ2hyZWYnLCBvcHRpb25zLnVybCkucHJvcCgnaG9zdCcpO1xuICAgICAgLy8gU2V0dGluZyB0aGUgZGF0YVR5cGUgdG8gaWZyYW1lIGVuYWJsZXMgdGhlIGlmcmFtZSB0cmFuc3BvcnQ6XG4gICAgICBvcHRpb25zLmRhdGFUeXBlID0gJ2lmcmFtZSAnICsgKG9wdGlvbnMuZGF0YVR5cGUgfHwgJycpO1xuICAgICAgLy8gVGhlIGlmcmFtZSB0cmFuc3BvcnQgYWNjZXB0cyBhIHNlcmlhbGl6ZWQgYXJyYXkgYXMgZm9ybSBkYXRhOlxuICAgICAgb3B0aW9ucy5mb3JtRGF0YSA9IHRoaXMuX2dldEZvcm1EYXRhKG9wdGlvbnMpO1xuICAgICAgLy8gQWRkIHJlZGlyZWN0IHVybCB0byBmb3JtIGRhdGEgb24gY3Jvc3MtZG9tYWluIHVwbG9hZHM6XG4gICAgICBpZiAob3B0aW9ucy5yZWRpcmVjdCAmJiB0YXJnZXRIb3N0ICYmIHRhcmdldEhvc3QgIT09IGxvY2F0aW9uLmhvc3QpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtRGF0YS5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBvcHRpb25zLnJlZGlyZWN0UGFyYW1OYW1lIHx8ICdyZWRpcmVjdCcsXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbnMucmVkaXJlY3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0RGF0YVNldHRpbmdzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2lzWEhSVXBsb2FkKG9wdGlvbnMpKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2h1bmtlZFVwbG9hZChvcHRpb25zLCB0cnVlKSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0WEhSRGF0YShvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faW5pdFByb2dyZXNzTGlzdGVuZXIob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBkYXRhVHlwZSB0byBwb3N0bWVzc2FnZSBlbmFibGVzIHRoZVxuICAgICAgICAgIC8vIHBvc3RNZXNzYWdlIHRyYW5zcG9ydDpcbiAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gJ3Bvc3RtZXNzYWdlICcgKyAob3B0aW9ucy5kYXRhVHlwZSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luaXRJZnJhbWVTZXR0aW5ncyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldFBhcmFtTmFtZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWxlSW5wdXQgPSAkKG9wdGlvbnMuZmlsZUlucHV0KSxcbiAgICAgICAgcGFyYW1OYW1lID0gb3B0aW9ucy5wYXJhbU5hbWU7XG4gICAgICBpZiAoIXBhcmFtTmFtZSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBbXTtcbiAgICAgICAgZmlsZUlucHV0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnB1dCA9ICQodGhpcyksXG4gICAgICAgICAgICBuYW1lID0gaW5wdXQucHJvcCgnbmFtZScpIHx8ICdmaWxlc1tdJyxcbiAgICAgICAgICAgIGkgPSAoaW5wdXQucHJvcCgnZmlsZXMnKSB8fCBbMV0pLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgICAgcGFyYW1OYW1lLnB1c2gobmFtZSk7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwYXJhbU5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgcGFyYW1OYW1lID0gW2ZpbGVJbnB1dC5wcm9wKCduYW1lJykgfHwgJ2ZpbGVzW10nXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghJC5pc0FycmF5KHBhcmFtTmFtZSkpIHtcbiAgICAgICAgcGFyYW1OYW1lID0gW3BhcmFtTmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1OYW1lO1xuICAgIH0sXG5cbiAgICBfaW5pdEZvcm1TZXR0aW5nczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIC8vIFJldHJpZXZlIG1pc3Npbmcgb3B0aW9ucyBmcm9tIHRoZSBpbnB1dCBmaWVsZCBhbmQgdGhlXG4gICAgICAvLyBhc3NvY2lhdGVkIGZvcm0sIGlmIGF2YWlsYWJsZTpcbiAgICAgIGlmICghb3B0aW9ucy5mb3JtIHx8ICFvcHRpb25zLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybSA9ICQob3B0aW9ucy5maWxlSW5wdXQucHJvcCgnZm9ybScpKTtcbiAgICAgICAgLy8gSWYgdGhlIGdpdmVuIGZpbGUgaW5wdXQgZG9lc24ndCBoYXZlIGFuIGFzc29jaWF0ZWQgZm9ybSxcbiAgICAgICAgLy8gdXNlIHRoZSBkZWZhdWx0IHdpZGdldCBmaWxlIGlucHV0J3MgZm9ybTpcbiAgICAgICAgaWYgKCFvcHRpb25zLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0aW9ucy5mb3JtID0gJCh0aGlzLm9wdGlvbnMuZmlsZUlucHV0LnByb3AoJ2Zvcm0nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucGFyYW1OYW1lID0gdGhpcy5fZ2V0UGFyYW1OYW1lKG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMuZm9ybS5wcm9wKCdhY3Rpb24nKSB8fCBsb2NhdGlvbi5ocmVmO1xuICAgICAgfVxuICAgICAgLy8gVGhlIEhUVFAgcmVxdWVzdCBtZXRob2QgbXVzdCBiZSBcIlBPU1RcIiBvciBcIlBVVFwiOlxuICAgICAgb3B0aW9ucy50eXBlID0gKFxuICAgICAgICBvcHRpb25zLnR5cGUgfHxcbiAgICAgICAgKCQudHlwZShvcHRpb25zLmZvcm0ucHJvcCgnbWV0aG9kJykpID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIG9wdGlvbnMuZm9ybS5wcm9wKCdtZXRob2QnKSkgfHxcbiAgICAgICAgJydcbiAgICAgICkudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy50eXBlICE9PSAnUE9TVCcgJiZcbiAgICAgICAgb3B0aW9ucy50eXBlICE9PSAnUFVUJyAmJlxuICAgICAgICBvcHRpb25zLnR5cGUgIT09ICdQQVRDSCdcbiAgICAgICkge1xuICAgICAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCc7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuZm9ybUFjY2VwdENoYXJzZXQpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtQWNjZXB0Q2hhcnNldCA9IG9wdGlvbnMuZm9ybS5hdHRyKCdhY2NlcHQtY2hhcnNldCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0QUpBWFNldHRpbmdzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBkYXRhKTtcbiAgICAgIHRoaXMuX2luaXRGb3JtU2V0dGluZ3Mob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0RGF0YVNldHRpbmdzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcblxuICAgIC8vIGpRdWVyeSAxLjYgZG9lc24ndCBwcm92aWRlIC5zdGF0ZSgpLFxuICAgIC8vIHdoaWxlIGpRdWVyeSAxLjgrIHJlbW92ZWQgLmlzUmVqZWN0ZWQoKSBhbmQgLmlzUmVzb2x2ZWQoKTpcbiAgICBfZ2V0RGVmZXJyZWRTdGF0ZTogZnVuY3Rpb24gKGRlZmVycmVkKSB7XG4gICAgICBpZiAoZGVmZXJyZWQuc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnN0YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmZXJyZWQuaXNSZXNvbHZlZCgpKSB7XG4gICAgICAgIHJldHVybiAncmVzb2x2ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmVycmVkLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm4gJ3JlamVjdGVkJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgfSxcblxuICAgIC8vIE1hcHMganFYSFIgY2FsbGJhY2tzIHRvIHRoZSBlcXVpdmFsZW50XG4gICAgLy8gbWV0aG9kcyBvZiB0aGUgZ2l2ZW4gUHJvbWlzZSBvYmplY3Q6XG4gICAgX2VuaGFuY2VQcm9taXNlOiBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgcHJvbWlzZS5zdWNjZXNzID0gcHJvbWlzZS5kb25lO1xuICAgICAgcHJvbWlzZS5lcnJvciA9IHByb21pc2UuZmFpbDtcbiAgICAgIHByb21pc2UuY29tcGxldGUgPSBwcm9taXNlLmFsd2F5cztcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgZW5oYW5jZWQgd2l0aFxuICAgIC8vIHRoZSBqcVhIUiBtZXRob2RzIGFib3J0LCBzdWNjZXNzLCBlcnJvciBhbmQgY29tcGxldGU6XG4gICAgX2dldFhIUlByb21pc2U6IGZ1bmN0aW9uIChyZXNvbHZlT3JSZWplY3QsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgIHZhciBkZmQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgIHByb21pc2UgPSBkZmQucHJvbWlzZSgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLm9wdGlvbnMuY29udGV4dCB8fCBwcm9taXNlO1xuICAgICAgaWYgKHJlc29sdmVPclJlamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICBkZmQucmVzb2x2ZVdpdGgoY29udGV4dCwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKHJlc29sdmVPclJlamVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGZkLnJlamVjdFdpdGgoY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgICBwcm9taXNlLmFib3J0ID0gZGZkLnByb21pc2U7XG4gICAgICByZXR1cm4gdGhpcy5fZW5oYW5jZVByb21pc2UocHJvbWlzZSk7XG4gICAgfSxcblxuICAgIC8vIEFkZHMgY29udmVuaWVuY2UgbWV0aG9kcyB0byB0aGUgZGF0YSBjYWxsYmFjayBhcmd1bWVudDpcbiAgICBfYWRkQ29udmVuaWVuY2VNZXRob2RzOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBnZXRQcm9taXNlID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmVXaXRoKHRoYXQsIGFyZ3MpLnByb21pc2UoKTtcbiAgICAgICAgfTtcbiAgICAgIGRhdGEucHJvY2VzcyA9IGZ1bmN0aW9uIChyZXNvbHZlRnVuYywgcmVqZWN0RnVuYykge1xuICAgICAgICBpZiAocmVzb2x2ZUZ1bmMgfHwgcmVqZWN0RnVuYykge1xuICAgICAgICAgIGRhdGEuX3Byb2Nlc3NRdWV1ZSA9IHRoaXMuX3Byb2Nlc3NRdWV1ZSA9ICh0aGlzLl9wcm9jZXNzUXVldWUgfHxcbiAgICAgICAgICAgIGdldFByb21pc2UoW3RoaXNdKSlcbiAgICAgICAgICAgIFt0aGF0Ll9wcm9taXNlUGlwZV0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVqZWN0V2l0aCh0aGF0LCBbZGF0YV0pLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvbWlzZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFt0aGF0Ll9wcm9taXNlUGlwZV0ocmVzb2x2ZUZ1bmMsIHJlamVjdEZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUXVldWUgfHwgZ2V0UHJvbWlzZShbdGhpc10pO1xuICAgICAgfTtcbiAgICAgIGRhdGEuc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSgpICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICBkYXRhLmpxWEhSID0gdGhpcy5qcVhIUiA9XG4gICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAgICAgJC5FdmVudCgnc3VibWl0JywgeyBkZWxlZ2F0ZWRFdmVudDogZSB9KSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKSAhPT0gZmFsc2UgJiYgdGhhdC5fb25TZW5kKGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpxWEhSIHx8IHRoYXQuX2dldFhIUlByb21pc2UoKTtcbiAgICAgIH07XG4gICAgICBkYXRhLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5qcVhIUikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmpxWEhSLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvclRocm93biA9ICdhYm9ydCc7XG4gICAgICAgIHRoYXQuX3RyaWdnZXIoJ2ZhaWwnLCBudWxsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoYXQuX2dldFhIUlByb21pc2UoZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIGRhdGEuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmpxWEhSKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuX2dldERlZmVycmVkU3RhdGUodGhpcy5qcVhIUik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NRdWV1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGF0Ll9nZXREZWZlcnJlZFN0YXRlKHRoaXMuX3Byb2Nlc3NRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkYXRhLnByb2Nlc3NpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgIXRoaXMuanFYSFIgJiZcbiAgICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUgJiZcbiAgICAgICAgICB0aGF0Ll9nZXREZWZlcnJlZFN0YXRlKHRoaXMuX3Byb2Nlc3NRdWV1ZSkgPT09ICdwZW5kaW5nJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGRhdGEucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgICAgIH07XG4gICAgICBkYXRhLnJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBQYXJzZXMgdGhlIFJhbmdlIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAvLyBhbmQgcmV0dXJucyB0aGUgdXBsb2FkZWQgYnl0ZXM6XG4gICAgX2dldFVwbG9hZGVkQnl0ZXM6IGZ1bmN0aW9uIChqcVhIUikge1xuICAgICAgdmFyIHJhbmdlID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1JhbmdlJyksXG4gICAgICAgIHBhcnRzID0gcmFuZ2UgJiYgcmFuZ2Uuc3BsaXQoJy0nKSxcbiAgICAgICAgdXBwZXJCeXRlc1BvcyA9IHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgJiYgcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgIHJldHVybiB1cHBlckJ5dGVzUG9zICYmIHVwcGVyQnl0ZXNQb3MgKyAxO1xuICAgIH0sXG5cbiAgICAvLyBVcGxvYWRzIGEgZmlsZSBpbiBtdWx0aXBsZSwgc2VxdWVudGlhbCByZXF1ZXN0c1xuICAgIC8vIGJ5IHNwbGl0dGluZyB0aGUgZmlsZSB1cCBpbiBtdWx0aXBsZSBibG9iIGNodW5rcy5cbiAgICAvLyBJZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0cnVlLCBvbmx5IHRlc3RzIGlmIHRoZSBmaWxlXG4gICAgLy8gc2hvdWxkIGJlIHVwbG9hZGVkIGluIGNodW5rcywgYnV0IGRvZXMgbm90IGludm9rZSBhbnlcbiAgICAvLyB1cGxvYWQgcmVxdWVzdHM6XG4gICAgX2NodW5rZWRVcGxvYWQ6IGZ1bmN0aW9uIChvcHRpb25zLCB0ZXN0T25seSkge1xuICAgICAgb3B0aW9ucy51cGxvYWRlZEJ5dGVzID0gb3B0aW9ucy51cGxvYWRlZEJ5dGVzIHx8IDA7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGZpbGUgPSBvcHRpb25zLmZpbGVzWzBdLFxuICAgICAgICBmcyA9IGZpbGUuc2l6ZSxcbiAgICAgICAgdWIgPSBvcHRpb25zLnVwbG9hZGVkQnl0ZXMsXG4gICAgICAgIG1jcyA9IG9wdGlvbnMubWF4Q2h1bmtTaXplIHx8IGZzLFxuICAgICAgICBzbGljZSA9IHRoaXMuX2Jsb2JTbGljZSxcbiAgICAgICAgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICBwcm9taXNlID0gZGZkLnByb21pc2UoKSxcbiAgICAgICAganFYSFIsXG4gICAgICAgIHVwbG9hZDtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICB0aGlzLl9pc1hIUlVwbG9hZChvcHRpb25zKSAmJlxuICAgICAgICAgIHNsaWNlICYmXG4gICAgICAgICAgKHViIHx8ICgkLnR5cGUobWNzKSA9PT0gJ2Z1bmN0aW9uJyA/IG1jcyhvcHRpb25zKSA6IG1jcykgPCBmcylcbiAgICAgICAgKSB8fFxuICAgICAgICBvcHRpb25zLmRhdGFcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGVzdE9ubHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodWIgPj0gZnMpIHtcbiAgICAgICAgZmlsZS5lcnJvciA9IG9wdGlvbnMuaTE4bigndXBsb2FkZWRCeXRlcycpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0WEhSUHJvbWlzZShmYWxzZSwgb3B0aW9ucy5jb250ZXh0LCBbXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgIGZpbGUuZXJyb3JcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICAvLyBUaGUgY2h1bmsgdXBsb2FkIG1ldGhvZDpcbiAgICAgIHVwbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2xvbmUgdGhlIG9wdGlvbnMgb2JqZWN0IGZvciBlYWNoIGNodW5rIHVwbG9hZDpcbiAgICAgICAgdmFyIG8gPSAkLmV4dGVuZCh7fSwgb3B0aW9ucyksXG4gICAgICAgICAgY3VycmVudExvYWRlZCA9IG8uX3Byb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgby5ibG9iID0gc2xpY2UuY2FsbChcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIHViLFxuICAgICAgICAgIHViICsgKCQudHlwZShtY3MpID09PSAnZnVuY3Rpb24nID8gbWNzKG8pIDogbWNzKSxcbiAgICAgICAgICBmaWxlLnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgY2h1bmsgc2l6ZSwgYXMgdGhlIGJsb2IgaXRzZWxmXG4gICAgICAgIC8vIHdpbGwgYmUgZGVyZWZlcmVuY2VkIGFmdGVyIGRhdGEgcHJvY2Vzc2luZzpcbiAgICAgICAgby5jaHVua1NpemUgPSBvLmJsb2Iuc2l6ZTtcbiAgICAgICAgLy8gRXhwb3NlIHRoZSBjaHVuayBieXRlcyBwb3NpdGlvbiByYW5nZTpcbiAgICAgICAgby5jb250ZW50UmFuZ2UgPVxuICAgICAgICAgICdieXRlcyAnICsgdWIgKyAnLScgKyAodWIgKyBvLmNodW5rU2l6ZSAtIDEpICsgJy8nICsgZnM7XG4gICAgICAgIC8vIFRyaWdnZXIgY2h1bmtiZWZvcmVzZW5kIHRvIGFsbG93IGZvcm0gZGF0YSB0byBiZSB1cGRhdGVkIGZvciB0aGlzIGNodW5rXG4gICAgICAgIHRoYXQuX3RyaWdnZXIoJ2NodW5rYmVmb3Jlc2VuZCcsIG51bGwsIG8pO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSB1cGxvYWQgZGF0YSAodGhlIGJsb2IgYW5kIHBvdGVudGlhbCBmb3JtIGRhdGEpOlxuICAgICAgICB0aGF0Ll9pbml0WEhSRGF0YShvKTtcbiAgICAgICAgLy8gQWRkIHByb2dyZXNzIGxpc3RlbmVycyBmb3IgdGhpcyBjaHVuayB1cGxvYWQ6XG4gICAgICAgIHRoYXQuX2luaXRQcm9ncmVzc0xpc3RlbmVyKG8pO1xuICAgICAgICBqcVhIUiA9IChcbiAgICAgICAgICAodGhhdC5fdHJpZ2dlcignY2h1bmtzZW5kJywgbnVsbCwgbykgIT09IGZhbHNlICYmICQuYWpheChvKSkgfHxcbiAgICAgICAgICB0aGF0Ll9nZXRYSFJQcm9taXNlKGZhbHNlLCBvLmNvbnRleHQpXG4gICAgICAgIClcbiAgICAgICAgICAuZG9uZShmdW5jdGlvbiAocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgdWIgPSB0aGF0Ll9nZXRVcGxvYWRlZEJ5dGVzKGpxWEhSKSB8fCB1YiArIG8uY2h1bmtTaXplO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZ3Jlc3MgZXZlbnQgaWYgbm8gZmluYWwgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgIC8vIHdpdGggbG9hZGVkIGVxdWFsaW5nIHRvdGFsIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgICAgLy8gZm9yIHRoaXMgY2h1bms6XG4gICAgICAgICAgICBpZiAoY3VycmVudExvYWRlZCArIG8uY2h1bmtTaXplIC0gby5fcHJvZ3Jlc3MubG9hZGVkKSB7XG4gICAgICAgICAgICAgIHRoYXQuX29uUHJvZ3Jlc3MoXG4gICAgICAgICAgICAgICAgJC5FdmVudCgncHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgbG9hZGVkOiB1YiAtIG8udXBsb2FkZWRCeXRlcyxcbiAgICAgICAgICAgICAgICAgIHRvdGFsOiB1YiAtIG8udXBsb2FkZWRCeXRlc1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMudXBsb2FkZWRCeXRlcyA9IG8udXBsb2FkZWRCeXRlcyA9IHViO1xuICAgICAgICAgICAgby5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICBvLnRleHRTdGF0dXMgPSB0ZXh0U3RhdHVzO1xuICAgICAgICAgICAgby5qcVhIUiA9IGpxWEhSO1xuICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignY2h1bmtkb25lJywgbnVsbCwgbyk7XG4gICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdjaHVua2Fsd2F5cycsIG51bGwsIG8pO1xuICAgICAgICAgICAgaWYgKHViIDwgZnMpIHtcbiAgICAgICAgICAgICAgLy8gRmlsZSB1cGxvYWQgbm90IHlldCBjb21wbGV0ZSxcbiAgICAgICAgICAgICAgLy8gY29udGludWUgd2l0aCB0aGUgbmV4dCBjaHVuazpcbiAgICAgICAgICAgICAgdXBsb2FkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZmQucmVzb2x2ZVdpdGgoby5jb250ZXh0LCBbcmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZhaWwoZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgby5qcVhIUiA9IGpxWEhSO1xuICAgICAgICAgICAgby50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgICAgICAgIG8uZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ2NodW5rZmFpbCcsIG51bGwsIG8pO1xuICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignY2h1bmthbHdheXMnLCBudWxsLCBvKTtcbiAgICAgICAgICAgIGRmZC5yZWplY3RXaXRoKG8uY29udGV4dCwgW2pxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bl0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Ll9kZWluaXRQcm9ncmVzc0xpc3RlbmVyKG8pO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2VuaGFuY2VQcm9taXNlKHByb21pc2UpO1xuICAgICAgcHJvbWlzZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICB9O1xuICAgICAgdXBsb2FkKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuXG4gICAgX2JlZm9yZVNlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlID09PSAwKSB7XG4gICAgICAgIC8vIHRoZSBzdGFydCBjYWxsYmFjayBpcyB0cmlnZ2VyZWQgd2hlbiBhbiB1cGxvYWQgc3RhcnRzXG4gICAgICAgIC8vIGFuZCBubyBvdGhlciB1cGxvYWRzIGFyZSBjdXJyZW50bHkgcnVubmluZyxcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdGFydCBldmVudDpcbiAgICAgICAgdGhpcy5fdHJpZ2dlcignc3RhcnQnKTtcbiAgICAgICAgLy8gU2V0IHRpbWVyIGZvciBnbG9iYWwgYml0cmF0ZSBwcm9ncmVzcyBjYWxjdWxhdGlvbjpcbiAgICAgICAgdGhpcy5fYml0cmF0ZVRpbWVyID0gbmV3IHRoaXMuX0JpdHJhdGVUaW1lcigpO1xuICAgICAgICAvLyBSZXNldCB0aGUgZ2xvYmFsIHByb2dyZXNzIHZhbHVlczpcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkID0gdGhpcy5fcHJvZ3Jlc3MudG90YWwgPSAwO1xuICAgICAgICB0aGlzLl9wcm9ncmVzcy5iaXRyYXRlID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGFpbmVyIG9iamVjdHMgZm9yIHRoZSAucmVzcG9uc2UoKSBhbmRcbiAgICAgIC8vIC5wcm9ncmVzcygpIG1ldGhvZHMgb24gdGhlIGRhdGEgb2JqZWN0IGFyZSBhdmFpbGFibGVcbiAgICAgIC8vIGFuZCByZXNldCB0byB0aGVpciBpbml0aWFsIHN0YXRlOlxuICAgICAgdGhpcy5faW5pdFJlc3BvbnNlT2JqZWN0KGRhdGEpO1xuICAgICAgdGhpcy5faW5pdFByb2dyZXNzT2JqZWN0KGRhdGEpO1xuICAgICAgZGF0YS5fcHJvZ3Jlc3MubG9hZGVkID0gZGF0YS5sb2FkZWQgPSBkYXRhLnVwbG9hZGVkQnl0ZXMgfHwgMDtcbiAgICAgIGRhdGEuX3Byb2dyZXNzLnRvdGFsID0gZGF0YS50b3RhbCA9IHRoaXMuX2dldFRvdGFsKGRhdGEuZmlsZXMpIHx8IDE7XG4gICAgICBkYXRhLl9wcm9ncmVzcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlID0gMDtcbiAgICAgIHRoaXMuX2FjdGl2ZSArPSAxO1xuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIHByb2dyZXNzIHZhbHVlczpcbiAgICAgIHRoaXMuX3Byb2dyZXNzLmxvYWRlZCArPSBkYXRhLmxvYWRlZDtcbiAgICAgIHRoaXMuX3Byb2dyZXNzLnRvdGFsICs9IGRhdGEudG90YWw7XG4gICAgfSxcblxuICAgIF9vbkRvbmU6IGZ1bmN0aW9uIChyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdG90YWwgPSBvcHRpb25zLl9wcm9ncmVzcy50b3RhbCxcbiAgICAgICAgcmVzcG9uc2UgPSBvcHRpb25zLl9yZXNwb25zZTtcbiAgICAgIGlmIChvcHRpb25zLl9wcm9ncmVzcy5sb2FkZWQgPCB0b3RhbCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBwcm9ncmVzcyBldmVudCBpZiBubyBmaW5hbCBwcm9ncmVzcyBldmVudFxuICAgICAgICAvLyB3aXRoIGxvYWRlZCBlcXVhbGluZyB0b3RhbCBoYXMgYmVlbiB0cmlnZ2VyZWQ6XG4gICAgICAgIHRoaXMuX29uUHJvZ3Jlc3MoXG4gICAgICAgICAgJC5FdmVudCgncHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbG9hZGVkOiB0b3RhbCxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLnJlc3VsdCA9IG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgcmVzcG9uc2UudGV4dFN0YXR1cyA9IG9wdGlvbnMudGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICByZXNwb25zZS5qcVhIUiA9IG9wdGlvbnMuanFYSFIgPSBqcVhIUjtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2RvbmUnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgX29uRmFpbDogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3BvbnNlID0gb3B0aW9ucy5fcmVzcG9uc2U7XG4gICAgICBpZiAob3B0aW9ucy5yZWNhbGN1bGF0ZVByb2dyZXNzKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZmFpbGVkIChlcnJvciBvciBhYm9ydCkgZmlsZSB1cGxvYWQgZnJvbVxuICAgICAgICAvLyB0aGUgZ2xvYmFsIHByb2dyZXNzIGNhbGN1bGF0aW9uOlxuICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQgLT0gb3B0aW9ucy5fcHJvZ3Jlc3MubG9hZGVkO1xuICAgICAgICB0aGlzLl9wcm9ncmVzcy50b3RhbCAtPSBvcHRpb25zLl9wcm9ncmVzcy50b3RhbDtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLmpxWEhSID0gb3B0aW9ucy5qcVhIUiA9IGpxWEhSO1xuICAgICAgcmVzcG9uc2UudGV4dFN0YXR1cyA9IG9wdGlvbnMudGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICByZXNwb25zZS5lcnJvclRocm93biA9IG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2ZhaWwnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgX29uQWx3YXlzOiBmdW5jdGlvbiAoanFYSFJvclJlc3VsdCwgdGV4dFN0YXR1cywganFYSFJvckVycm9yLCBvcHRpb25zKSB7XG4gICAgICAvLyBqcVhIUm9yUmVzdWx0LCB0ZXh0U3RhdHVzIGFuZCBqcVhIUm9yRXJyb3IgYXJlIGFkZGVkIHRvIHRoZVxuICAgICAgLy8gb3B0aW9ucyBvYmplY3QgdmlhIGRvbmUgYW5kIGZhaWwgY2FsbGJhY2tzXG4gICAgICB0aGlzLl90cmlnZ2VyKCdhbHdheXMnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgX29uU2VuZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgIGlmICghZGF0YS5zdWJtaXQpIHtcbiAgICAgICAgdGhpcy5fYWRkQ29udmVuaWVuY2VNZXRob2RzKGUsIGRhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBqcVhIUixcbiAgICAgICAgYWJvcnRlZCxcbiAgICAgICAgc2xvdCxcbiAgICAgICAgcGlwZSxcbiAgICAgICAgb3B0aW9ucyA9IHRoYXQuX2dldEFKQVhTZXR0aW5ncyhkYXRhKSxcbiAgICAgICAgc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0Ll9zZW5kaW5nICs9IDE7XG4gICAgICAgICAgLy8gU2V0IHRpbWVyIGZvciBiaXRyYXRlIHByb2dyZXNzIGNhbGN1bGF0aW9uOlxuICAgICAgICAgIG9wdGlvbnMuX2JpdHJhdGVUaW1lciA9IG5ldyB0aGF0Ll9CaXRyYXRlVGltZXIoKTtcbiAgICAgICAgICBqcVhIUiA9XG4gICAgICAgICAgICBqcVhIUiB8fFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAoKGFib3J0ZWQgfHxcbiAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgJC5FdmVudCgnc2VuZCcsIHsgZGVsZWdhdGVkRXZlbnQ6IGUgfSksXG4gICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKSA9PT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgdGhhdC5fZ2V0WEhSUHJvbWlzZShmYWxzZSwgb3B0aW9ucy5jb250ZXh0LCBhYm9ydGVkKSkgfHxcbiAgICAgICAgICAgICAgdGhhdC5fY2h1bmtlZFVwbG9hZChvcHRpb25zKSB8fFxuICAgICAgICAgICAgICAkLmFqYXgob3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9vbkRvbmUocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9vbkZhaWwoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmFsd2F5cyhmdW5jdGlvbiAoanFYSFJvclJlc3VsdCwgdGV4dFN0YXR1cywganFYSFJvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fZGVpbml0UHJvZ3Jlc3NMaXN0ZW5lcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9vbkFsd2F5cyhcbiAgICAgICAgICAgICAgICAgIGpxWEhSb3JSZXN1bHQsXG4gICAgICAgICAgICAgICAgICB0ZXh0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAganFYSFJvckVycm9yLFxuICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhhdC5fc2VuZGluZyAtPSAxO1xuICAgICAgICAgICAgICAgIHRoYXQuX2FjdGl2ZSAtPSAxO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5saW1pdENvbmN1cnJlbnRVcGxvYWRzID4gdGhhdC5fc2VuZGluZ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgcXVldWVkIHVwbG9hZCxcbiAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaGFzIG5vdCBiZWVuIGFib3J0ZWQ6XG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dFNsb3QgPSB0aGF0Ll9zbG90cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHRTbG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9nZXREZWZlcnJlZFN0YXRlKG5leHRTbG90KSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFNsb3QucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHRTbG90ID0gdGhhdC5fc2xvdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuX2FjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0b3AgY2FsbGJhY2sgaXMgdHJpZ2dlcmVkIHdoZW4gYWxsIHVwbG9hZHMgaGF2ZVxuICAgICAgICAgICAgICAgICAgLy8gYmVlbiBjb21wbGV0ZWQsIGVxdWl2YWxlbnQgdG8gdGhlIGdsb2JhbCBhamF4U3RvcCBldmVudDpcbiAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ3N0b3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgfTtcbiAgICAgIHRoaXMuX2JlZm9yZVNlbmQoZSwgb3B0aW9ucyk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub3B0aW9ucy5zZXF1ZW50aWFsVXBsb2FkcyB8fFxuICAgICAgICAodGhpcy5vcHRpb25zLmxpbWl0Q29uY3VycmVudFVwbG9hZHMgJiZcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyA8PSB0aGlzLl9zZW5kaW5nKVxuICAgICAgKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyA+IDEpIHtcbiAgICAgICAgICBzbG90ID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgIHRoaXMuX3Nsb3RzLnB1c2goc2xvdCk7XG4gICAgICAgICAgcGlwZSA9IHNsb3RbdGhhdC5fcHJvbWlzZVBpcGVdKHNlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NlcXVlbmNlID0gdGhpcy5fc2VxdWVuY2VbdGhhdC5fcHJvbWlzZVBpcGVdKHNlbmQsIHNlbmQpO1xuICAgICAgICAgIHBpcGUgPSB0aGlzLl9zZXF1ZW5jZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHBpcGVkIFByb21pc2Ugb2JqZWN0LCBlbmhhbmNlZCB3aXRoIGFuIGFib3J0IG1ldGhvZCxcbiAgICAgICAgLy8gd2hpY2ggaXMgZGVsZWdhdGVkIHRvIHRoZSBqcVhIUiBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgdXBsb2FkLFxuICAgICAgICAvLyBhbmQganFYSFIgY2FsbGJhY2tzIG1hcHBlZCB0byB0aGUgZXF1aXZhbGVudCBQcm9taXNlIG1ldGhvZHM6XG4gICAgICAgIHBpcGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYWJvcnRlZCA9IFt1bmRlZmluZWQsICdhYm9ydCcsICdhYm9ydCddO1xuICAgICAgICAgIGlmICghanFYSFIpIHtcbiAgICAgICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICAgIHNsb3QucmVqZWN0V2l0aChvcHRpb25zLmNvbnRleHQsIGFib3J0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmhhbmNlUHJvbWlzZShwaXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kKCk7XG4gICAgfSxcblxuICAgIF9vbkFkZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIGRhdGEpLFxuICAgICAgICBmaWxlcyA9IGRhdGEuZmlsZXMsXG4gICAgICAgIGZpbGVzTGVuZ3RoID0gZmlsZXMubGVuZ3RoLFxuICAgICAgICBsaW1pdCA9IG9wdGlvbnMubGltaXRNdWx0aUZpbGVVcGxvYWRzLFxuICAgICAgICBsaW1pdFNpemUgPSBvcHRpb25zLmxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZSxcbiAgICAgICAgb3ZlcmhlYWQgPSBvcHRpb25zLmxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZU92ZXJoZWFkLFxuICAgICAgICBiYXRjaFNpemUgPSAwLFxuICAgICAgICBwYXJhbU5hbWUgPSB0aGlzLl9nZXRQYXJhbU5hbWUob3B0aW9ucyksXG4gICAgICAgIHBhcmFtTmFtZVNldCxcbiAgICAgICAgcGFyYW1OYW1lU2xpY2UsXG4gICAgICAgIGZpbGVTZXQsXG4gICAgICAgIGksXG4gICAgICAgIGogPSAwO1xuICAgICAgaWYgKCFmaWxlc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobGltaXRTaXplICYmIGZpbGVzWzBdLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdFNpemUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICEob3B0aW9ucy5zaW5nbGVGaWxlVXBsb2FkcyB8fCBsaW1pdCB8fCBsaW1pdFNpemUpIHx8XG4gICAgICAgICF0aGlzLl9pc1hIUlVwbG9hZChvcHRpb25zKVxuICAgICAgKSB7XG4gICAgICAgIGZpbGVTZXQgPSBbZmlsZXNdO1xuICAgICAgICBwYXJhbU5hbWVTZXQgPSBbcGFyYW1OYW1lXTtcbiAgICAgIH0gZWxzZSBpZiAoIShvcHRpb25zLnNpbmdsZUZpbGVVcGxvYWRzIHx8IGxpbWl0U2l6ZSkgJiYgbGltaXQpIHtcbiAgICAgICAgZmlsZVNldCA9IFtdO1xuICAgICAgICBwYXJhbU5hbWVTZXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbGVzTGVuZ3RoOyBpICs9IGxpbWl0KSB7XG4gICAgICAgICAgZmlsZVNldC5wdXNoKGZpbGVzLnNsaWNlKGksIGkgKyBsaW1pdCkpO1xuICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lLnNsaWNlKGksIGkgKyBsaW1pdCk7XG4gICAgICAgICAgaWYgKCFwYXJhbU5hbWVTbGljZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbU5hbWVTZXQucHVzaChwYXJhbU5hbWVTbGljZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2luZ2xlRmlsZVVwbG9hZHMgJiYgbGltaXRTaXplKSB7XG4gICAgICAgIGZpbGVTZXQgPSBbXTtcbiAgICAgICAgcGFyYW1OYW1lU2V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlc0xlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYmF0Y2hTaXplICs9IGZpbGVzW2ldLnNpemUgKyBvdmVyaGVhZDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpICsgMSA9PT0gZmlsZXNMZW5ndGggfHxcbiAgICAgICAgICAgIGJhdGNoU2l6ZSArIGZpbGVzW2kgKyAxXS5zaXplICsgb3ZlcmhlYWQgPiBsaW1pdFNpemUgfHxcbiAgICAgICAgICAgIChsaW1pdCAmJiBpICsgMSAtIGogPj0gbGltaXQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmaWxlU2V0LnB1c2goZmlsZXMuc2xpY2UoaiwgaSArIDEpKTtcbiAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lLnNsaWNlKGosIGkgKyAxKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1OYW1lU2xpY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1OYW1lU2V0LnB1c2gocGFyYW1OYW1lU2xpY2UpO1xuICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtTmFtZVNldCA9IHBhcmFtTmFtZTtcbiAgICAgIH1cbiAgICAgIGRhdGEub3JpZ2luYWxGaWxlcyA9IGZpbGVzO1xuICAgICAgJC5lYWNoKGZpbGVTZXQgfHwgZmlsZXMsIGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgbmV3RGF0YSA9ICQuZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgbmV3RGF0YS5maWxlcyA9IGZpbGVTZXQgPyBlbGVtZW50IDogW2VsZW1lbnRdO1xuICAgICAgICBuZXdEYXRhLnBhcmFtTmFtZSA9IHBhcmFtTmFtZVNldFtpbmRleF07XG4gICAgICAgIHRoYXQuX2luaXRSZXNwb25zZU9iamVjdChuZXdEYXRhKTtcbiAgICAgICAgdGhhdC5faW5pdFByb2dyZXNzT2JqZWN0KG5ld0RhdGEpO1xuICAgICAgICB0aGF0Ll9hZGRDb252ZW5pZW5jZU1ldGhvZHMoZSwgbmV3RGF0YSk7XG4gICAgICAgIHJlc3VsdCA9IHRoYXQuX3RyaWdnZXIoXG4gICAgICAgICAgJ2FkZCcsXG4gICAgICAgICAgJC5FdmVudCgnYWRkJywgeyBkZWxlZ2F0ZWRFdmVudDogZSB9KSxcbiAgICAgICAgICBuZXdEYXRhXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9yZXBsYWNlRmlsZUlucHV0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGlucHV0ID0gZGF0YS5maWxlSW5wdXQsXG4gICAgICAgIGlucHV0Q2xvbmUgPSBpbnB1dC5jbG9uZSh0cnVlKSxcbiAgICAgICAgcmVzdG9yZUZvY3VzID0gaW5wdXQuaXMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAvLyBBZGQgYSByZWZlcmVuY2UgZm9yIHRoZSBuZXcgY2xvbmVkIGZpbGUgaW5wdXQgdG8gdGhlIGRhdGEgYXJndW1lbnQ6XG4gICAgICBkYXRhLmZpbGVJbnB1dENsb25lID0gaW5wdXRDbG9uZTtcbiAgICAgICQoJzxmb3JtPjwvZm9ybT4nKS5hcHBlbmQoaW5wdXRDbG9uZSlbMF0ucmVzZXQoKTtcbiAgICAgIC8vIERldGFjaGluZyBhbGxvd3MgdG8gaW5zZXJ0IHRoZSBmaWxlSW5wdXQgb24gYW5vdGhlciBmb3JtXG4gICAgICAvLyB3aXRob3V0IGxvb3NpbmcgdGhlIGZpbGUgaW5wdXQgdmFsdWU6XG4gICAgICBpbnB1dC5hZnRlcihpbnB1dENsb25lKS5kZXRhY2goKTtcbiAgICAgIC8vIElmIHRoZSBmaWxlSW5wdXQgaGFkIGZvY3VzIGJlZm9yZSBpdCB3YXMgZGV0YWNoZWQsXG4gICAgICAvLyByZXN0b3JlIGZvY3VzIHRvIHRoZSBpbnB1dENsb25lLlxuICAgICAgaWYgKHJlc3RvcmVGb2N1cykge1xuICAgICAgICBpbnB1dENsb25lLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICB9XG4gICAgICAvLyBBdm9pZCBtZW1vcnkgbGVha3Mgd2l0aCB0aGUgZGV0YWNoZWQgZmlsZSBpbnB1dDpcbiAgICAgICQuY2xlYW5EYXRhKGlucHV0Lm9mZigncmVtb3ZlJykpO1xuICAgICAgLy8gUmVwbGFjZSB0aGUgb3JpZ2luYWwgZmlsZSBpbnB1dCBlbGVtZW50IGluIHRoZSBmaWxlSW5wdXRcbiAgICAgIC8vIGVsZW1lbnRzIHNldCB3aXRoIHRoZSBjbG9uZSwgd2hpY2ggaGFzIGJlZW4gY29waWVkIGluY2x1ZGluZ1xuICAgICAgLy8gZXZlbnQgaGFuZGxlcnM6XG4gICAgICB0aGlzLm9wdGlvbnMuZmlsZUlucHV0ID0gdGhpcy5vcHRpb25zLmZpbGVJbnB1dC5tYXAoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgIGlmIChlbCA9PT0gaW5wdXRbMF0pIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRDbG9uZVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHRoZSB3aWRnZXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb24gdGhlIGZpbGUgaW5wdXQgaXRzZWxmLFxuICAgICAgLy8gb3ZlcnJpZGUgdGhpcy5lbGVtZW50IHdpdGggdGhlIGZpbGUgaW5wdXQgY2xvbmU6XG4gICAgICBpZiAoaW5wdXRbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBpbnB1dENsb25lO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlRmlsZVRyZWVFbnRyeTogZnVuY3Rpb24gKGVudHJ5LCBwYXRoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGRmZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgZW50cmllcyA9IFtdLFxuICAgICAgICBkaXJSZWFkZXIsXG4gICAgICAgIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgIWUuZW50cnkpIHtcbiAgICAgICAgICAgIGUuZW50cnkgPSBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2luY2UgJC53aGVuIHJldHVybnMgaW1tZWRpYXRlbHkgaWYgb25lXG4gICAgICAgICAgLy8gRGVmZXJyZWQgaXMgcmVqZWN0ZWQsIHdlIHVzZSByZXNvbHZlIGluc3RlYWQuXG4gICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdmFsaWQgZmlsZXMgYW5kIGludmFsaWQgaXRlbXNcbiAgICAgICAgICAvLyB0byBiZSByZXR1cm5lZCB0b2dldGhlciBpbiBvbmUgc2V0OlxuICAgICAgICAgIGRmZC5yZXNvbHZlKFtlXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICB0aGF0XG4gICAgICAgICAgICAuX2hhbmRsZUZpbGVUcmVlRW50cmllcyhlbnRyaWVzLCBwYXRoICsgZW50cnkubmFtZSArICcvJylcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgICBkZmQucmVzb2x2ZShmaWxlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZEVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyUmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NIYW5kbGVyKGVudHJpZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW50cmllcyA9IGVudHJpZXMuY29uY2F0KHJlc3VsdHMpO1xuICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHBhdGggPSBwYXRoIHx8ICcnO1xuICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICBpZiAoZW50cnkuX2ZpbGUpIHtcbiAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBDaHJvbWUgYnVnICMxNDk3MzVcbiAgICAgICAgICBlbnRyeS5fZmlsZS5yZWxhdGl2ZVBhdGggPSBwYXRoO1xuICAgICAgICAgIGRmZC5yZXNvbHZlKGVudHJ5Ll9maWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICBmaWxlLnJlbGF0aXZlUGF0aCA9IHBhdGg7XG4gICAgICAgICAgICBkZmQucmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgIGRpclJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGFuIGVtcHR5IGxpc3QgZm9yIGZpbGUgc3lzdGVtIGl0ZW1zXG4gICAgICAgIC8vIG90aGVyIHRoYW4gZmlsZXMgb3IgZGlyZWN0b3JpZXM6XG4gICAgICAgIGRmZC5yZXNvbHZlKFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZmQucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlRmlsZVRyZWVFbnRyaWVzOiBmdW5jdGlvbiAoZW50cmllcywgcGF0aCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuICQud2hlblxuICAgICAgICAuYXBwbHkoXG4gICAgICAgICAgJCxcbiAgICAgICAgICAkLm1hcChlbnRyaWVzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGF0Ll9oYW5kbGVGaWxlVHJlZUVudHJ5KGVudHJ5LCBwYXRoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIFt0aGlzLl9wcm9taXNlUGlwZV0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldERyb3BwZWRGaWxlczogZnVuY3Rpb24gKGRhdGFUcmFuc2Zlcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBkYXRhVHJhbnNmZXIgPSBkYXRhVHJhbnNmZXIgfHwge307XG4gICAgICB2YXIgaXRlbXMgPSBkYXRhVHJhbnNmZXIuaXRlbXM7XG4gICAgICBpZiAoXG4gICAgICAgIGl0ZW1zICYmXG4gICAgICAgIGl0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAoaXRlbXNbMF0ud2Via2l0R2V0QXNFbnRyeSB8fCBpdGVtc1swXS5nZXRBc0VudHJ5KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVGaWxlVHJlZUVudHJpZXMoXG4gICAgICAgICAgJC5tYXAoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgICAgICBpZiAoaXRlbS53ZWJraXRHZXRBc0VudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIENocm9tZSBidWcgIzE0OTczNTpcbiAgICAgICAgICAgICAgICBlbnRyeS5fZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2V0QXNFbnRyeSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmUoJC5tYWtlQXJyYXkoZGF0YVRyYW5zZmVyLmZpbGVzKSkucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICBfZ2V0U2luZ2xlRmlsZUlucHV0RmlsZXM6IGZ1bmN0aW9uIChmaWxlSW5wdXQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZmlsZUlucHV0ID0gJChmaWxlSW5wdXQpO1xuICAgICAgdmFyIGVudHJpZXMgPVxuICAgICAgICAgIGZpbGVJbnB1dC5wcm9wKCd3ZWJraXRFbnRyaWVzJykgfHwgZmlsZUlucHV0LnByb3AoJ2VudHJpZXMnKSxcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIHZhbHVlO1xuICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUZpbGVUcmVlRW50cmllcyhlbnRyaWVzKTtcbiAgICAgIH1cbiAgICAgIGZpbGVzID0gJC5tYWtlQXJyYXkoZmlsZUlucHV0LnByb3AoJ2ZpbGVzJykpO1xuICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBmaWxlSW5wdXQucHJvcCgndmFsdWUnKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZShbXSkucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBmaWxlcyBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgYnJvd3NlciBkb2VzIG5vdFxuICAgICAgICAvLyBzdXBwb3J0IHRoZSBGaWxlIEFQSSBhbmQgd2UgYWRkIGEgcHNldWRvIEZpbGUgb2JqZWN0IHdpdGhcbiAgICAgICAgLy8gdGhlIGlucHV0IHZhbHVlIGFzIG5hbWUgd2l0aCBwYXRoIGluZm9ybWF0aW9uIHJlbW92ZWQ6XG4gICAgICAgIGZpbGVzID0gW3sgbmFtZTogdmFsdWUucmVwbGFjZSgvXi4qXFxcXC8sICcnKSB9XTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZXNbMF0ubmFtZSA9PT0gdW5kZWZpbmVkICYmIGZpbGVzWzBdLmZpbGVOYW1lKSB7XG4gICAgICAgIC8vIEZpbGUgbm9ybWFsaXphdGlvbiBmb3IgU2FmYXJpIDQgYW5kIEZpcmVmb3ggMzpcbiAgICAgICAgJC5lYWNoKGZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGZpbGUpIHtcbiAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlLmZpbGVOYW1lO1xuICAgICAgICAgIGZpbGUuc2l6ZSA9IGZpbGUuZmlsZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKGZpbGVzKS5wcm9taXNlKCk7XG4gICAgfSxcblxuICAgIF9nZXRGaWxlSW5wdXRGaWxlczogZnVuY3Rpb24gKGZpbGVJbnB1dCkge1xuICAgICAgaWYgKCEoZmlsZUlucHV0IGluc3RhbmNlb2YgJCkgfHwgZmlsZUlucHV0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2luZ2xlRmlsZUlucHV0RmlsZXMoZmlsZUlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkLndoZW5cbiAgICAgICAgLmFwcGx5KCQsICQubWFwKGZpbGVJbnB1dCwgdGhpcy5fZ2V0U2luZ2xlRmlsZUlucHV0RmlsZXMpKVxuICAgICAgICBbdGhpcy5fcHJvbWlzZVBpcGVdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9vbkNoYW5nZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICBmaWxlSW5wdXQ6ICQoZS50YXJnZXQpLFxuICAgICAgICAgIGZvcm06ICQoZS50YXJnZXQuZm9ybSlcbiAgICAgICAgfTtcbiAgICAgIHRoaXMuX2dldEZpbGVJbnB1dEZpbGVzKGRhdGEuZmlsZUlucHV0KS5hbHdheXMoZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgIGRhdGEuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5yZXBsYWNlRmlsZUlucHV0KSB7XG4gICAgICAgICAgdGhhdC5fcmVwbGFjZUZpbGVJbnB1dChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhhdC5fdHJpZ2dlcihcbiAgICAgICAgICAgICdjaGFuZ2UnLFxuICAgICAgICAgICAgJC5FdmVudCgnY2hhbmdlJywgeyBkZWxlZ2F0ZWRFdmVudDogZSB9KSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICApICE9PSBmYWxzZVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGF0Ll9vbkFkZChlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9vblBhc3RlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGl0ZW1zID1cbiAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQgJiZcbiAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSAmJlxuICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5jbGlwYm9hcmREYXRhLml0ZW1zLFxuICAgICAgICBkYXRhID0geyBmaWxlczogW10gfTtcbiAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgJC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgICB2YXIgZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlICYmIGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIGRhdGEuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcbiAgICAgICAgICAgICdwYXN0ZScsXG4gICAgICAgICAgICAkLkV2ZW50KCdwYXN0ZScsIHsgZGVsZWdhdGVkRXZlbnQ6IGUgfSksXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgKSAhPT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5fb25BZGQoZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uRHJvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuZGF0YVRyYW5zZmVyID0gZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyLFxuICAgICAgICBkYXRhID0ge307XG4gICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGRhdGFUcmFuc2Zlci5maWxlcyAmJiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fZ2V0RHJvcHBlZEZpbGVzKGRhdGFUcmFuc2ZlcikuYWx3YXlzKGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgIGRhdGEuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgICAgICQuRXZlbnQoJ2Ryb3AnLCB7IGRlbGVnYXRlZEV2ZW50OiBlIH0pLFxuICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICApICE9PSBmYWxzZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhhdC5fb25BZGQoZSwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uRHJhZ092ZXI6IGdldERyYWdIYW5kbGVyKCdkcmFnb3ZlcicpLFxuXG4gICAgX29uRHJhZ0VudGVyOiBnZXREcmFnSGFuZGxlcignZHJhZ2VudGVyJyksXG5cbiAgICBfb25EcmFnTGVhdmU6IGdldERyYWdIYW5kbGVyKCdkcmFnbGVhdmUnKSxcblxuICAgIF9pbml0RXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2lzWEhSVXBsb2FkKHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5fb24odGhpcy5vcHRpb25zLmRyb3Bab25lLCB7XG4gICAgICAgICAgZHJhZ292ZXI6IHRoaXMuX29uRHJhZ092ZXIsXG4gICAgICAgICAgZHJvcDogdGhpcy5fb25Ecm9wLFxuICAgICAgICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgb24gZHJhZ2VudGVyIGlzIHJlcXVpcmVkIGZvciBJRTEwKzpcbiAgICAgICAgICBkcmFnZW50ZXI6IHRoaXMuX29uRHJhZ0VudGVyLFxuICAgICAgICAgIC8vIGRyYWdsZWF2ZSBpcyBub3QgcmVxdWlyZWQsIGJ1dCBhZGRlZCBmb3IgY29tcGxldGVuZXNzOlxuICAgICAgICAgIGRyYWdsZWF2ZTogdGhpcy5fb25EcmFnTGVhdmVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uKHRoaXMub3B0aW9ucy5wYXN0ZVpvbmUsIHtcbiAgICAgICAgICBwYXN0ZTogdGhpcy5fb25QYXN0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICgkLnN1cHBvcnQuZmlsZUlucHV0KSB7XG4gICAgICAgIHRoaXMuX29uKHRoaXMub3B0aW9ucy5maWxlSW5wdXQsIHtcbiAgICAgICAgICBjaGFuZ2U6IHRoaXMuX29uQ2hhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGVzdHJveUV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZih0aGlzLm9wdGlvbnMuZHJvcFpvbmUsICdkcmFnZW50ZXIgZHJhZ2xlYXZlIGRyYWdvdmVyIGRyb3AnKTtcbiAgICAgIHRoaXMuX29mZih0aGlzLm9wdGlvbnMucGFzdGVab25lLCAncGFzdGUnKTtcbiAgICAgIHRoaXMuX29mZih0aGlzLm9wdGlvbnMuZmlsZUlucHV0LCAnY2hhbmdlJyk7XG4gICAgfSxcblxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RXZlbnRIYW5kbGVycygpO1xuICAgIH0sXG5cbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHJlaW5pdCA9ICQuaW5BcnJheShrZXksIHRoaXMuX3NwZWNpYWxPcHRpb25zKSAhPT0gLTE7XG4gICAgICBpZiAocmVpbml0KSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lFdmVudEhhbmRsZXJzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcbiAgICAgIGlmIChyZWluaXQpIHtcbiAgICAgICAgdGhpcy5faW5pdFNwZWNpYWxPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX2luaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0U3BlY2lhbE9wdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuZmlsZUlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQgPSB0aGlzLmVsZW1lbnQuaXMoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgICAgICA/IHRoaXMuZWxlbWVudFxuICAgICAgICAgIDogdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJyk7XG4gICAgICB9IGVsc2UgaWYgKCEob3B0aW9ucy5maWxlSW5wdXQgaW5zdGFuY2VvZiAkKSkge1xuICAgICAgICBvcHRpb25zLmZpbGVJbnB1dCA9ICQob3B0aW9ucy5maWxlSW5wdXQpO1xuICAgICAgfVxuICAgICAgaWYgKCEob3B0aW9ucy5kcm9wWm9uZSBpbnN0YW5jZW9mICQpKSB7XG4gICAgICAgIG9wdGlvbnMuZHJvcFpvbmUgPSAkKG9wdGlvbnMuZHJvcFpvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKCEob3B0aW9ucy5wYXN0ZVpvbmUgaW5zdGFuY2VvZiAkKSkge1xuICAgICAgICBvcHRpb25zLnBhc3RlWm9uZSA9ICQob3B0aW9ucy5wYXN0ZVpvbmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0UmVnRXhwOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKSxcbiAgICAgICAgbW9kaWZpZXJzID0gcGFydHMucG9wKCk7XG4gICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignLycpLCBtb2RpZmllcnMpO1xuICAgIH0sXG5cbiAgICBfaXNSZWdFeHBPcHRpb246IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBrZXkgIT09ICd1cmwnICYmXG4gICAgICAgICQudHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIC9eXFwvLipcXC9baWdtXXswLDN9JC8udGVzdCh2YWx1ZSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIF9pbml0RGF0YUF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZGF0YSA9IHRoaXMuZWxlbWVudC5kYXRhKCk7XG4gICAgICAvLyBJbml0aWFsaXplIG9wdGlvbnMgc2V0IHZpYSBIVE1MNSBkYXRhLWF0dHJpYnV0ZXM6XG4gICAgICAkLmVhY2godGhpcy5lbGVtZW50WzBdLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChpbmRleCwgYXR0cikge1xuICAgICAgICB2YXIga2V5ID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgdmFsdWU7XG4gICAgICAgIGlmICgvXmRhdGEtLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IGh5cGhlbi1hdGVkIGtleSB0byBjYW1lbENhc2U6XG4gICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDUpLnJlcGxhY2UoLy1bYS16XS9nLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICAgIGlmICh0aGF0Ll9pc1JlZ0V4cE9wdGlvbihrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGF0Ll9nZXRSZWdFeHAodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2luaXREYXRhQXR0cmlidXRlcygpO1xuICAgICAgdGhpcy5faW5pdFNwZWNpYWxPcHRpb25zKCk7XG4gICAgICB0aGlzLl9zbG90cyA9IFtdO1xuICAgICAgdGhpcy5fc2VxdWVuY2UgPSB0aGlzLl9nZXRYSFJQcm9taXNlKHRydWUpO1xuICAgICAgdGhpcy5fc2VuZGluZyA9IHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICB0aGlzLl9pbml0UHJvZ3Jlc3NPYmplY3QodGhpcyk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRIYW5kbGVycygpO1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHRvIHRoZSB3aWRnZXQgQVBJIGFuZCBhbGxvd3MgdG8gcXVlcnlcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSB1cGxvYWRzOlxuICAgIGFjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBtZXRob2QgaXMgZXhwb3NlZCB0byB0aGUgd2lkZ2V0IEFQSSBhbmQgYWxsb3dzIHRvIHF1ZXJ5XG4gICAgLy8gdGhlIHdpZGdldCB1cGxvYWQgcHJvZ3Jlc3MuXG4gICAgLy8gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBsb2FkZWQsIHRvdGFsIGFuZCBiaXRyYXRlIHByb3BlcnRpZXNcbiAgICAvLyBmb3IgdGhlIHJ1bm5pbmcgdXBsb2FkczpcbiAgICBwcm9ncmVzczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHRvIHRoZSB3aWRnZXQgQVBJIGFuZCBhbGxvd3MgYWRkaW5nIGZpbGVzXG4gICAgLy8gdXNpbmcgdGhlIGZpbGV1cGxvYWQgQVBJLiBUaGUgZGF0YSBwYXJhbWV0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2hpY2hcbiAgICAvLyBtdXN0IGhhdmUgYSBmaWxlcyBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYWRkaXRpb25hbCBvcHRpb25zOlxuICAgIC8vIC5maWxldXBsb2FkKCdhZGQnLCB7ZmlsZXM6IGZpbGVzTGlzdH0pO1xuICAgIGFkZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZmlsZUlucHV0ICYmICFkYXRhLmZpbGVzKSB7XG4gICAgICAgIHRoaXMuX2dldEZpbGVJbnB1dEZpbGVzKGRhdGEuZmlsZUlucHV0KS5hbHdheXMoZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgZGF0YS5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgIHRoYXQuX29uQWRkKG51bGwsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuZmlsZXMgPSAkLm1ha2VBcnJheShkYXRhLmZpbGVzKTtcbiAgICAgICAgdGhpcy5fb25BZGQobnVsbCwgZGF0YSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgdG8gdGhlIHdpZGdldCBBUEkgYW5kIGFsbG93cyBzZW5kaW5nIGZpbGVzXG4gICAgLy8gdXNpbmcgdGhlIGZpbGV1cGxvYWQgQVBJLiBUaGUgZGF0YSBwYXJhbWV0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2hpY2hcbiAgICAvLyBtdXN0IGhhdmUgYSBmaWxlcyBvciBmaWxlSW5wdXQgcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFkZGl0aW9uYWwgb3B0aW9uczpcbiAgICAvLyAuZmlsZXVwbG9hZCgnc2VuZCcsIHtmaWxlczogZmlsZXNMaXN0fSk7XG4gICAgLy8gVGhlIG1ldGhvZCByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgZm9yIHRoZSBmaWxlIHVwbG9hZCBjYWxsLlxuICAgIHNlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YSAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgIGlmIChkYXRhLmZpbGVJbnB1dCAmJiAhZGF0YS5maWxlcykge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGRmZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIHByb21pc2UgPSBkZmQucHJvbWlzZSgpLFxuICAgICAgICAgICAganFYSFIsXG4gICAgICAgICAgICBhYm9ydGVkO1xuICAgICAgICAgIHByb21pc2UuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChqcVhIUikge1xuICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRmZC5yZWplY3QobnVsbCwgJ2Fib3J0JywgJ2Fib3J0Jyk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2dldEZpbGVJbnB1dEZpbGVzKGRhdGEuZmlsZUlucHV0KS5hbHdheXMoZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkZmQucmVqZWN0KCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgICAgIGpxWEhSID0gdGhhdC5fb25TZW5kKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAganFYSFIudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZShyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIGRmZC5yZWplY3QoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5oYW5jZVByb21pc2UocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5maWxlcyA9ICQubWFrZUFycmF5KGRhdGEuZmlsZXMpO1xuICAgICAgICBpZiAoZGF0YS5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25TZW5kKG51bGwsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0WEhSUHJvbWlzZShmYWxzZSwgZGF0YSAmJiBkYXRhLmNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcbiAgfVxufSkoKTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2UgIT09IG9wdHMud2l0aENyZWRlbnRpYWxzO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMgPSBvcHRzLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSAhIW9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIGRldGVjdCBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudFxuICB0aGlzLmlzUmVhY3ROYXRpdmUgPSAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnKTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIG9yIFJlYWN0TmF0aXZlIGNsaWVudFxuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaXNSZWFjdE5hdGl2ZSkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0gfHwge307XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogb3B0aW9ucy5wb3J0IHx8IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGgsXG4gICAgZm9yY2VKU09OUDogb3B0aW9ucy5mb3JjZUpTT05QIHx8IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiBvcHRpb25zLmZvcmNlQmFzZTY0IHx8IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogb3B0aW9ucy5lbmFibGVzWERSIHx8IHRoaXMuZW5hYmxlc1hEUixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzIHx8IHRoaXMud2l0aENyZWRlbnRpYWxzLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiBvcHRpb25zLnRpbWVzdGFtcFJlcXVlc3RzIHx8IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiBvcHRpb25zLnBvbGljeVBvcnQgfHwgdGhpcy5wb2xpY3lQb3J0LFxuICAgIHBmeDogb3B0aW9ucy5wZnggfHwgdGhpcy5wZngsXG4gICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UgfHwgdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCB8fCB0aGlzLmNlcnQsXG4gICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMgfHwgdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogb3B0aW9ucy5mb3JjZU5vZGUgfHwgdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICByZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCB0aGlzLnJlcXVlc3RUaW1lb3V0LFxuICAgIHByb3RvY29sczogb3B0aW9ucy5wcm90b2NvbHMgfHwgdm9pZCAoMCksXG4gICAgaXNSZWFjdE5hdGl2ZTogdGhpcy5pc1JlYWN0TmF0aXZlXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3BlbiAoKSB7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09PSBtc2cudHlwZSAmJiAncHJvYmUnID09PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG4gICAgb25lcnJvcigndHJhbnNwb3J0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSAodG8pIHtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IG9wdHMud2l0aENyZWRlbnRpYWxzO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyByZXN1bHRzIG9mIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGRldGVjdGlvblxuICB0aGlzLmlzUmVhY3ROYXRpdmUgPSBvcHRzLmlzUmVhY3ROYXRpdmU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyAob3B0cykge1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vZ2xvYmFsVGhpcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBjYWxsYmFja3MgPSBnbG9iYWxUaGlzLl9fX2VpbyA9IChnbG9iYWxUaGlzLl9fX2VpbyB8fCBbXSk7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuIiwiLyogZ2xvYmFsIGF0dGFjaEV2ZW50ICovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2dsb2JhbFRoaXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkge31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG4gIG9wdHMud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IG9wdHMud2l0aENyZWRlbnRpYWxzO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zdXBwb3J0c0JpbmFyeSAmJiBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHwgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07IGNoYXJzZXQ9VVRGLTgnKSB7XG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHR5cGVvZiB4aHIuc3RhdHVzID09PSAnbnVtYmVyJyA/IHhoci5zdGF0dXMgOiAwKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHwgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07IGNoYXJzZXQ9VVRGLTgnKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBhdHRhY2hFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRlcm1pbmF0aW9uRXZlbnQgPSAnb25wYWdlaGlkZScgaW4gZ2xvYmFsVGhpcyA/ICdwYWdlaGlkZScgOiAndW5sb2FkJztcbiAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG9uUGF1c2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSAoKSB7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cbnZhciBCcm93c2VyV2ViU29ja2V0LCBOb2RlV2ViU29ja2V0O1xuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldDtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldEltcGwgPSBCcm93c2VyV2ViU29ja2V0IHx8IE5vZGVXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcblxuICB2YXIgb3B0cyA9IHt9O1xuXG4gIGlmICghdGhpcy5pc1JlYWN0TmF0aXZlKSB7XG4gICAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQ7XG4gICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMucGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICAgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gICAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICAgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gICAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgfVxuXG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPVxuICAgICAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgJiYgIXRoaXMuaXNSZWFjdE5hdGl2ZVxuICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgID8gbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmkpXG4gICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0SW1wbCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldEltcGwgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuL2dsb2JhbFRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpc1tbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cclxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG4iLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgdXJpLnBhdGhOYW1lcyA9IHBhdGhOYW1lcyh1cmksIHVyaVsncGF0aCddKTtcbiAgICB1cmkucXVlcnlLZXkgPSBxdWVyeUtleSh1cmksIHVyaVsncXVlcnknXSk7XG5cbiAgICByZXR1cm4gdXJpO1xufTtcblxuZnVuY3Rpb24gcGF0aE5hbWVzKG9iaiwgcGF0aCkge1xuICAgIHZhciByZWd4ID0gL1xcL3syLDl9L2csXG4gICAgICAgIG5hbWVzID0gcGF0aC5yZXBsYWNlKHJlZ3gsIFwiL1wiKS5zcGxpdChcIi9cIik7XG5cbiAgICBpZiAocGF0aC5zdWJzdHIoMCwgMSkgPT0gJy8nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc3Vic3RyKHBhdGgubGVuZ3RoIC0gMSwgMSkgPT0gJy8nKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZShuYW1lcy5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZXM7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHVyaSwgcXVlcnkpIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgcXVlcnkucmVwbGFjZSgvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgZGF0YVskMV0gPSAkMjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xuXG52YXIgYmFzZTY0ZW5jb2RlcjtcbmlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1dGY4ZW5jb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogZnIucmVzdWx0IH0sIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICB0cnkge1xuICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWJhc2U2NGVuY29kZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgZmFsc2UsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmIChjaHIgIT09ICc6Jykge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cblxuICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcblxuICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgIGkgKz0gbjtcbiAgICBsZW5ndGggPSAnJztcbiAgfVxuXG4gIGlmIChsZW5ndGggIT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PT0gMjU1KSBicmVhaztcblxuICAgICAgLy8gMzEwID0gY2hhciBsZW5ndGggb2YgTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG4iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG5cbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgY291bnRlciA9IDA7XG5cdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR2YXIgdmFsdWU7XG5cdHZhciBleHRyYTtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHZhciBpbmRleCA9IC0xO1xuXHR2YXIgdmFsdWU7XG5cdHZhciBvdXRwdXQgPSAnJztcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHR9XG5cdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0fVxuXHR2YXIgc3ltYm9sID0gJyc7XG5cdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICghY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkpIHtcblx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHR9XG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0fVxuXHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdHJldHVybiBzeW1ib2w7XG59XG5cbmZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdHZhciBpbmRleCA9IC0xO1xuXHR2YXIgY29kZVBvaW50O1xuXHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcblx0fVxuXHRyZXR1cm4gYnl0ZVN0cmluZztcbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0fVxuXG5cdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRieXRlSW5kZXgrKztcblxuXHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHR9XG5cblx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG5cdHZhciBieXRlMTtcblx0dmFyIGJ5dGUyO1xuXHR2YXIgYnl0ZTM7XG5cdHZhciBieXRlNDtcblx0dmFyIGNvZGVQb2ludDtcblxuXHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdHJldHVybiBieXRlMTtcblx0fVxuXG5cdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdH1cblx0fVxuXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG59XG5cbnZhciBieXRlQXJyYXk7XG52YXIgYnl0ZUNvdW50O1xudmFyIGJ5dGVJbmRleDtcbmZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZywgb3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRieXRlSW5kZXggPSAwO1xuXHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHR2YXIgdG1wO1xuXHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcblx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0fVxuXHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHZlcnNpb246ICcyLjEuMicsXG5cdGVuY29kZTogdXRmOGVuY29kZSxcblx0ZGVjb2RlOiB1dGY4ZGVjb2RlXG59O1xuIiwiLyogZ2xvYmFsIEJsb2IgRmlsZSAqL1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoRmlsZSkgPT09ICdbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0nO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogU3VwcG9ydHMgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQmxvYiBhbmQgRmlsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gIGlmIChvYmoudG9KU09OICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCIvKiFcbklDYW5IYXouanMgdmVyc2lvbiAwLjEwLjIgLS0gYnkgQEhlbnJpa0pvcmV0ZWdcbk1vcmUgaW5mbyBhdDogaHR0cDovL2ljYW5oYXpqcy5jb21cbiovXG4oZnVuY3Rpb24gKCkge1xuLypcbiAgbXVzdGFjaGUuanMg4oCUIExvZ2ljLWxlc3MgdGVtcGxhdGVzIGluIEphdmFTY3JpcHRcblxuICBTZWUgaHR0cDovL211c3RhY2hlLmdpdGh1Yi5jb20vIGZvciBtb3JlIGluZm8uXG4qL1xuXG52YXIgTXVzdGFjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIEFycmF5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICB2YXIgX3RyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0sIHRyaW07XG5cbiAgaWYgKF90cmltKSB7XG4gICAgdHJpbSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dCA9PSBudWxsID8gXCJcIiA6IF90cmltLmNhbGwodGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0cmltTGVmdCwgdHJpbVJpZ2h0O1xuXG4gICAgLy8gSUUgZG9lc24ndCBtYXRjaCBub24tYnJlYWtpbmcgc3BhY2VzIHdpdGggXFxzLlxuICAgIGlmICgoL1xcUy8pLnRlc3QoXCJcXHhBMFwiKSkge1xuICAgICAgdHJpbUxlZnQgPSAvXltcXHNcXHhBMF0rLztcbiAgICAgIHRyaW1SaWdodCA9IC9bXFxzXFx4QTBdKyQvO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmltTGVmdCA9IC9eXFxzKy87XG4gICAgICB0cmltUmlnaHQgPSAvXFxzKyQvO1xuICAgIH1cblxuICAgIHRyaW0gPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/IFwiXCIgOlxuICAgICAgICB0ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSh0cmltTGVmdCwgXCJcIikucmVwbGFjZSh0cmltUmlnaHQsIFwiXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgXCImXCI6IFwiJmFtcDtcIixcbiAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSFRNTChzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvJig/IVxcdys7KXxbPD5cIiddL2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gZXNjYXBlTWFwW3NdIHx8IHM7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcmVnZXhDYWNoZSA9IHt9O1xuICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gICAgb3RhZzogXCJ7e1wiLFxuICAgIGN0YWc6IFwifX1cIixcbiAgICBwcmFnbWFzOiB7fSxcbiAgICBidWZmZXI6IFtdLFxuICAgIHByYWdtYXNfaW1wbGVtZW50ZWQ6IHtcbiAgICAgIFwiSU1QTElDSVQtSVRFUkFUT1JcIjogdHJ1ZVxuICAgIH0sXG4gICAgY29udGV4dDoge30sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMsIGluX3JlY3Vyc2lvbikge1xuICAgICAgLy8gcmVzZXQgYnVmZmVyICYgc2V0IGNvbnRleHRcbiAgICAgIGlmICghaW5fcmVjdXJzaW9uKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107IC8vIFRPRE86IG1ha2UgdGhpcyBub24tbGF6eVxuICAgICAgfVxuXG4gICAgICAvLyBmYWlsIGZhc3RcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlcyhcIlwiLCB0ZW1wbGF0ZSkpIHtcbiAgICAgICAgaWYgKGluX3JlY3Vyc2lvbikge1xuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbmQodGVtcGxhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHByYWdtYXMgdG9nZXRoZXJcbiAgICAgIHRlbXBsYXRlID0gdGhpcy5yZW5kZXJfcHJhZ21hcyh0ZW1wbGF0ZSk7XG5cbiAgICAgIC8vIHJlbmRlciB0aGUgdGVtcGxhdGVcbiAgICAgIHZhciBodG1sID0gdGhpcy5yZW5kZXJfc2VjdGlvbih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpO1xuXG4gICAgICAvLyByZW5kZXJfc2VjdGlvbiBkaWQgbm90IGZpbmQgYW55IHNlY3Rpb25zLCB3ZSBzdGlsbCBuZWVkIHRvIHJlbmRlciB0aGUgdGFnc1xuICAgICAgaWYgKGh0bWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGh0bWwgPSB0aGlzLnJlbmRlcl90YWdzKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscywgaW5fcmVjdXJzaW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluX3JlY3Vyc2lvbikge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VuZExpbmVzKGh0bWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAgU2VuZHMgcGFyc2VkIGxpbmVzXG4gICAgKi9cbiAgICBzZW5kOiBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUgIT09IFwiXCIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VuZExpbmVzOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2VuZChsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLypcbiAgICAgIExvb2tzIGZvciAlUFJBR01BU1xuICAgICovXG4gICAgcmVuZGVyX3ByYWdtYXM6IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgLy8gbm8gcHJhZ21hc1xuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVzKFwiJVwiLCB0ZW1wbGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgcmVnZXggPSB0aGlzLmdldENhY2hlZFJlZ2V4KFwicmVuZGVyX3ByYWdtYXNcIiwgZnVuY3Rpb24gKG90YWcsIGN0YWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob3RhZyArIFwiJShbXFxcXHctXSspID8oW1xcXFx3XSs9W1xcXFx3XSspP1wiICsgY3RhZywgXCJnXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIHByYWdtYSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoYXQucHJhZ21hc19pbXBsZW1lbnRlZFtwcmFnbWFdKSB7XG4gICAgICAgICAgdGhyb3coe21lc3NhZ2U6XG4gICAgICAgICAgICBcIlRoaXMgaW1wbGVtZW50YXRpb24gb2YgbXVzdGFjaGUgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSAnXCIgK1xuICAgICAgICAgICAgcHJhZ21hICsgXCInIHByYWdtYVwifSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5wcmFnbWFzW3ByYWdtYV0gPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IG9wdGlvbnMuc3BsaXQoXCI9XCIpO1xuICAgICAgICAgIHRoYXQucHJhZ21hc1twcmFnbWFdW29wdHNbMF1dID0gb3B0c1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgLy8gaWdub3JlIHVua25vd24gcHJhZ21hcyBzaWxlbnRseVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICBUcmllcyB0byBmaW5kIGEgcGFydGlhbCBpbiB0aGUgY3VyZW50IHNjb3BlIGFuZCByZW5kZXIgaXRcbiAgICAqL1xuICAgIHJlbmRlcl9wYXJ0aWFsOiBmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgcGFydGlhbHMpIHtcbiAgICAgIG5hbWUgPSB0cmltKG5hbWUpO1xuICAgICAgaWYgKCFwYXJ0aWFscyB8fCBwYXJ0aWFsc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93KHttZXNzYWdlOiBcInVua25vd25fcGFydGlhbCAnXCIgKyBuYW1lICsgXCInXCJ9KTtcbiAgICAgIH1cbiAgICAgIGlmICghY29udGV4dCB8fCB0eXBlb2YgY29udGV4dFtuYW1lXSAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcihwYXJ0aWFsc1tuYW1lXSwgY29udGV4dCwgcGFydGlhbHMsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHBhcnRpYWxzW25hbWVdLCBjb250ZXh0W25hbWVdLCBwYXJ0aWFscywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICBSZW5kZXJzIGludmVydGVkICheKSBhbmQgbm9ybWFsICgjKSBzZWN0aW9uc1xuICAgICovXG4gICAgcmVuZGVyX3NlY3Rpb246IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpIHtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlcyhcIiNcIiwgdGVtcGxhdGUpICYmICF0aGlzLmluY2x1ZGVzKFwiXlwiLCB0ZW1wbGF0ZSkpIHtcbiAgICAgICAgLy8gZGlkIG5vdCByZW5kZXIgYW55dGhpbmcsIHRoZXJlIHdlcmUgbm8gc2VjdGlvbnNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciByZWdleCA9IHRoaXMuZ2V0Q2FjaGVkUmVnZXgoXCJyZW5kZXJfc2VjdGlvblwiLCBmdW5jdGlvbiAob3RhZywgY3RhZykge1xuICAgICAgICAvLyBUaGlzIHJlZ2V4IG1hdGNoZXMgX3RoZSBmaXJzdF8gc2VjdGlvbiAoe3sjZm9vfX17ey9mb299fSksIGFuZCBjYXB0dXJlcyB0aGUgcmVtYWluZGVyXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgICAgIFwiXihbXFxcXHNcXFxcU10qPylcIiArICAgICAgICAgLy8gYWxsIHRoZSBjcmFwIGF0IHRoZSBiZWdpbm5pbmcgdGhhdCBpcyBub3Qge3sqfX0gKCQxKVxuXG4gICAgICAgICAgb3RhZyArICAgICAgICAgICAgICAgICAgICAvLyB7e1xuICAgICAgICAgIFwiKFxcXFxefFxcXFwjKVxcXFxzKiguKylcXFxccypcIiArIC8vICAjZm9vICgjID09ICQyLCBmb28gPT0gJDMpXG4gICAgICAgICAgY3RhZyArICAgICAgICAgICAgICAgICAgICAvLyB9fVxuXG4gICAgICAgICAgXCJcXG4qKFtcXFxcc1xcXFxTXSo/KVwiICsgICAgICAgLy8gYmV0d2VlbiB0aGUgdGFnICgkMikuIGxlYWRpbmcgbmV3bGluZXMgYXJlIGRyb3BwZWRcblxuICAgICAgICAgIG90YWcgKyAgICAgICAgICAgICAgICAgICAgLy8ge3tcbiAgICAgICAgICBcIlxcXFwvXFxcXHMqXFxcXDNcXFxccypcIiArICAgICAgICAvLyAgL2ZvbyAoYmFja3JlZmVyZW5jZSB0byB0aGUgb3BlbmluZyB0YWcpLlxuICAgICAgICAgIGN0YWcgKyAgICAgICAgICAgICAgICAgICAgLy8gfX1cblxuICAgICAgICAgIFwiXFxcXHMqKFtcXFxcc1xcXFxTXSopJFwiLCAgICAgICAvLyBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIHN0cmluZyAoJDQpLiBsZWFkaW5nIHdoaXRlc3BhY2UgaXMgZHJvcHBlZC5cblxuICAgICAgICBcImdcIik7XG4gICAgICB9KTtcblxuXG4gICAgICAvLyBmb3IgZWFjaCB7eyNmb299fXt7L2Zvb319IHNlY3Rpb24gZG8uLi5cbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIGJlZm9yZSwgdHlwZSwgbmFtZSwgY29udGVudCwgYWZ0ZXIpIHtcbiAgICAgICAgLy8gYmVmb3JlIGNvbnRhaW5zIG9ubHkgdGFncywgbm8gc2VjdGlvbnNcbiAgICAgICAgdmFyIHJlbmRlcmVkQmVmb3JlID0gYmVmb3JlID8gdGhhdC5yZW5kZXJfdGFncyhiZWZvcmUsIGNvbnRleHQsIHBhcnRpYWxzLCB0cnVlKSA6IFwiXCIsXG5cbiAgICAgICAgLy8gYWZ0ZXIgbWF5IGNvbnRhaW4gYm90aCBzZWN0aW9ucyBhbmQgdGFncywgc28gdXNlIGZ1bGwgcmVuZGVyaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgICByZW5kZXJlZEFmdGVyID0gYWZ0ZXIgPyB0aGF0LnJlbmRlcihhZnRlciwgY29udGV4dCwgcGFydGlhbHMsIHRydWUpIDogXCJcIixcblxuICAgICAgICAvLyB3aWxsIGJlIGNvbXB1dGVkIGJlbG93XG4gICAgICAgICAgICByZW5kZXJlZENvbnRlbnQsXG5cbiAgICAgICAgICAgIHZhbHVlID0gdGhhdC5maW5kKG5hbWUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcIl5cIikgeyAvLyBpbnZlcnRlZCBzZWN0aW9uXG4gICAgICAgICAgaWYgKCF2YWx1ZSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGZhbHNlIG9yIGVtcHR5IGxpc3QsIHJlbmRlciBpdFxuICAgICAgICAgICAgcmVuZGVyZWRDb250ZW50ID0gdGhhdC5yZW5kZXIoY29udGVudCwgY29udGV4dCwgcGFydGlhbHMsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIiNcIikgeyAvLyBub3JtYWwgc2VjdGlvblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgeyAvLyBFbnVtZXJhYmxlLCBMZXQncyBsb29wIVxuICAgICAgICAgICAgcmVuZGVyZWRDb250ZW50ID0gdGhhdC5tYXAodmFsdWUsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoYXQucmVuZGVyKGNvbnRlbnQsIHRoYXQuY3JlYXRlX2NvbnRleHQocm93KSwgcGFydGlhbHMsIHRydWUpO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuaXNfb2JqZWN0KHZhbHVlKSkgeyAvLyBPYmplY3QsIFVzZSBpdCBhcyBzdWJjb250ZXh0IVxuICAgICAgICAgICAgcmVuZGVyZWRDb250ZW50ID0gdGhhdC5yZW5kZXIoY29udGVudCwgdGhhdC5jcmVhdGVfY29udGV4dCh2YWx1ZSksXG4gICAgICAgICAgICAgIHBhcnRpYWxzLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGhpZ2hlciBvcmRlciBzZWN0aW9uXG4gICAgICAgICAgICByZW5kZXJlZENvbnRlbnQgPSB2YWx1ZS5jYWxsKGNvbnRleHQsIGNvbnRlbnQsIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGF0LnJlbmRlcih0ZXh0LCBjb250ZXh0LCBwYXJ0aWFscywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7IC8vIGJvb2xlYW4gc2VjdGlvblxuICAgICAgICAgICAgcmVuZGVyZWRDb250ZW50ID0gdGhhdC5yZW5kZXIoY29udGVudCwgY29udGV4dCwgcGFydGlhbHMsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlZEJlZm9yZSArIHJlbmRlcmVkQ29udGVudCArIHJlbmRlcmVkQWZ0ZXI7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgIFJlcGxhY2Uge3tmb299fSBhbmQgZnJpZW5kcyB3aXRoIHZhbHVlcyBmcm9tIG91ciB2aWV3XG4gICAgKi9cbiAgICByZW5kZXJfdGFnczogZnVuY3Rpb24gKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscywgaW5fcmVjdXJzaW9uKSB7XG4gICAgICAvLyB0aXQgZm9yIHRhdFxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICB2YXIgbmV3X3JlZ2V4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhhdC5nZXRDYWNoZWRSZWdleChcInJlbmRlcl90YWdzXCIsIGZ1bmN0aW9uIChvdGFnLCBjdGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob3RhZyArIFwiKD18IXw+fCZ8XFxcXHt8JSk/KFteI1xcXFxeXSs/KVxcXFwxP1wiICsgY3RhZyArIFwiK1wiLCBcImdcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlZ2V4ID0gbmV3X3JlZ2V4KCk7XG4gICAgICB2YXIgdGFnX3JlcGxhY2VfY2FsbGJhY2sgPSBmdW5jdGlvbiAobWF0Y2gsIG9wZXJhdG9yLCBuYW1lKSB7XG4gICAgICAgIHN3aXRjaChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiIVwiOiAvLyBpZ25vcmUgY29tbWVudHNcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgY2FzZSBcIj1cIjogLy8gc2V0IG5ldyBkZWxpbWl0ZXJzLCByZWJ1aWxkIHRoZSByZXBsYWNlIHJlZ2V4cFxuICAgICAgICAgIHRoYXQuc2V0X2RlbGltaXRlcnMobmFtZSk7XG4gICAgICAgICAgcmVnZXggPSBuZXdfcmVnZXgoKTtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgY2FzZSBcIj5cIjogLy8gcmVuZGVyIHBhcnRpYWxcbiAgICAgICAgICByZXR1cm4gdGhhdC5yZW5kZXJfcGFydGlhbChuYW1lLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgICAgIGNhc2UgXCJ7XCI6IC8vIHRoZSB0cmlwbGUgbXVzdGFjaGUgaXMgdW5lc2NhcGVkXG4gICAgICAgIGNhc2UgXCImXCI6IC8vICYgb3BlcmF0b3IgaXMgYW4gYWx0ZXJuYXRpdmUgdW5lc2NhcGUgbWV0aG9kXG4gICAgICAgICAgcmV0dXJuIHRoYXQuZmluZChuYW1lLCBjb250ZXh0KTtcbiAgICAgICAgZGVmYXVsdDogLy8gZXNjYXBlIHRoZSB2YWx1ZVxuICAgICAgICAgIHJldHVybiBlc2NhcGVIVE1MKHRoYXQuZmluZChuYW1lLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgbGluZXMgPSB0ZW1wbGF0ZS5zcGxpdChcIlxcblwiKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnJlcGxhY2UocmVnZXgsIHRhZ19yZXBsYWNlX2NhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKCFpbl9yZWN1cnNpb24pIHtcbiAgICAgICAgICB0aGlzLnNlbmQobGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbl9yZWN1cnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldF9kZWxpbWl0ZXJzOiBmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICAgICAgdmFyIGRlbHMgPSBkZWxpbWl0ZXJzLnNwbGl0KFwiIFwiKTtcbiAgICAgIHRoaXMub3RhZyA9IHRoaXMuZXNjYXBlX3JlZ2V4KGRlbHNbMF0pO1xuICAgICAgdGhpcy5jdGFnID0gdGhpcy5lc2NhcGVfcmVnZXgoZGVsc1sxXSk7XG4gICAgfSxcblxuICAgIGVzY2FwZV9yZWdleDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIC8vIHRoYW5rIHlvdSBTaW1vbiBXaWxsaXNvblxuICAgICAgaWYgKCFhcmd1bWVudHMuY2FsbGVlLnNSRSkge1xuICAgICAgICB2YXIgc3BlY2lhbHMgPSBbXG4gICAgICAgICAgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JyxcbiAgICAgICAgICAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCdcbiAgICAgICAgXTtcbiAgICAgICAgYXJndW1lbnRzLmNhbGxlZS5zUkUgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICcoXFxcXCcgKyBzcGVjaWFscy5qb2luKCd8XFxcXCcpICsgJyknLCAnZydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoYXJndW1lbnRzLmNhbGxlZS5zUkUsICdcXFxcJDEnKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgIGZpbmQgYG5hbWVgIGluIGN1cnJlbnQgYGNvbnRleHRgLiBUaGF0IGlzIGZpbmQgbWUgYSB2YWx1ZVxuICAgICAgZnJvbSB0aGUgdmlldyBvYmplY3RcbiAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0KSB7XG4gICAgICBuYW1lID0gdHJpbShuYW1lKTtcblxuICAgICAgLy8gQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0aHJ1dGh5IG9yIGZhbHNlIG9yIDBcbiAgICAgIGZ1bmN0aW9uIGlzX2tpbmRhX3RydXRoeShib29sKSB7XG4gICAgICAgIHJldHVybiBib29sID09PSBmYWxzZSB8fCBib29sID09PSAwIHx8IGJvb2w7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGRvdCBub3RhdGlvbiBlZy4gZm9vLmJhclxuICAgICAgaWYgKG5hbWUubWF0Y2goLyhbYS16X10rKVxcLi9pZykpIHtcbiAgICAgICAgdmFyIGNoaWxkVmFsdWUgPSB0aGlzLndhbGtfY29udGV4dChuYW1lLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGlzX2tpbmRhX3RydXRoeShjaGlsZFZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzX2tpbmRhX3RydXRoeShjb250ZXh0W25hbWVdKSkge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dFtuYW1lXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19raW5kYV90cnV0aHkodGhpcy5jb250ZXh0W25hbWVdKSkge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5jb250ZXh0W25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZSB1bmtvd24gdmFyaWFibGVzXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9LFxuXG4gICAgd2Fsa19jb250ZXh0OiBmdW5jdGlvbiAobmFtZSwgY29udGV4dCkge1xuICAgICAgdmFyIHBhdGggPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAvLyBpZiB0aGUgdmFyIGRvZXNuJ3QgZXhpc3QgaW4gY3VycmVudCBjb250ZXh0LCBjaGVjayB0aGUgdG9wIGxldmVsIGNvbnRleHRcbiAgICAgIHZhciB2YWx1ZV9jb250ZXh0ID0gKGNvbnRleHRbcGF0aFswXV0gIT0gdW5kZWZpbmVkKSA/IGNvbnRleHQgOiB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZV9jb250ZXh0W3BhdGguc2hpZnQoKV07XG4gICAgICB3aGlsZSAodmFsdWUgIT0gdW5kZWZpbmVkICYmIHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICB2YWx1ZV9jb250ZXh0ID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdmFsdWVbcGF0aC5zaGlmdCgpXTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0LCBiaW5kaW5nIHRoZSBjb3JyZWN0IGNvbnRleHRcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh2YWx1ZV9jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLy8gVXRpbGl0eSBtZXRob2RzXG5cbiAgICAvKiBpbmNsdWRlcyB0YWcgKi9cbiAgICBpbmNsdWRlczogZnVuY3Rpb24gKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKHRoaXMub3RhZyArIG5lZWRsZSkgIT0gLTE7XG4gICAgfSxcblxuICAgIC8vIGJ5IEBsYW5nYWxleCwgc3VwcG9ydCBmb3IgYXJyYXlzIG9mIHN0cmluZ3NcbiAgICBjcmVhdGVfY29udGV4dDogZnVuY3Rpb24gKF9jb250ZXh0KSB7XG4gICAgICBpZiAodGhpcy5pc19vYmplY3QoX2NvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBfY29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IFwiLlwiO1xuICAgICAgICBpZiAodGhpcy5wcmFnbWFzW1wiSU1QTElDSVQtSVRFUkFUT1JcIl0pIHtcbiAgICAgICAgICBpdGVyYXRvciA9IHRoaXMucHJhZ21hc1tcIklNUExJQ0lULUlURVJBVE9SXCJdLml0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdHggPSB7fTtcbiAgICAgICAgY3R4W2l0ZXJhdG9yXSA9IF9jb250ZXh0O1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc19vYmplY3Q6IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAgV2h5LCB3aHksIHdoeT8gQmVjYXVzZSBJRS4gQ3J5LCBjcnkgY3J5LlxuICAgICovXG4gICAgbWFwOiBmdW5jdGlvbiAoYXJyYXksIGZuKSB7XG4gICAgICBpZiAodHlwZW9mIGFycmF5Lm1hcCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHIucHVzaChmbihhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDYWNoZWRSZWdleDogZnVuY3Rpb24gKG5hbWUsIGdlbmVyYXRvcikge1xuICAgICAgdmFyIGJ5T3RhZyA9IHJlZ2V4Q2FjaGVbdGhpcy5vdGFnXTtcbiAgICAgIGlmICghYnlPdGFnKSB7XG4gICAgICAgIGJ5T3RhZyA9IHJlZ2V4Q2FjaGVbdGhpcy5vdGFnXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgYnlDdGFnID0gYnlPdGFnW3RoaXMuY3RhZ107XG4gICAgICBpZiAoIWJ5Q3RhZykge1xuICAgICAgICBieUN0YWcgPSBieU90YWdbdGhpcy5jdGFnXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnZXggPSBieUN0YWdbbmFtZV07XG4gICAgICBpZiAoIXJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ID0gYnlDdGFnW25hbWVdID0gZ2VuZXJhdG9yKHRoaXMub3RhZywgdGhpcy5jdGFnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2V4O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4oe1xuICAgIG5hbWU6IFwibXVzdGFjaGUuanNcIixcbiAgICB2ZXJzaW9uOiBcIjAuNC4wXCIsXG5cbiAgICAvKlxuICAgICAgVHVybnMgYSB0ZW1wbGF0ZSBhbmQgdmlldyBpbnRvIEhUTUxcbiAgICAqL1xuICAgIHRvX2h0bWw6IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHNlbmRfZnVuKSB7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgICAgIGlmIChzZW5kX2Z1bikge1xuICAgICAgICByZW5kZXJlci5zZW5kID0gc2VuZF9mdW47XG4gICAgICB9XG4gICAgICByZW5kZXJlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcgfHwge30sIHBhcnRpYWxzKTtcbiAgICAgIGlmICghc2VuZF9mdW4pIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KCk7XG4vKiFcbiAgSUNhbkhhei5qcyAtLSBieSBASGVucmlrSm9yZXRlZ1xuKi9cbi8qZ2xvYmFsICAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiB0cmltKHN0dWZmKSB7XG4gICAgICAgIGlmICgnJy50cmltKSByZXR1cm4gc3R1ZmYudHJpbSgpO1xuICAgICAgICBlbHNlIHJldHVybiBzdHVmZi5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9XG5cbiAgICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgICB2YXIgaWNoID0ge1xuICAgICAgICBWRVJTSU9OOiBcIjAuMTAuMlwiLFxuICAgICAgICB0ZW1wbGF0ZXM6IHt9LFxuXG4gICAgICAgIC8vIGdyYWIganF1ZXJ5IG9yIHplcHRvIGlmIGl0J3MgdGhlcmVcbiAgICAgICAgJDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IG51bGwgOiBudWxsLFxuXG4gICAgICAgIC8vIHB1YmxpYyBmdW5jdGlvbiBmb3IgYWRkaW5nIHRlbXBsYXRlc1xuICAgICAgICAvLyBjYW4gdGFrZSBhIG5hbWUgYW5kIHRlbXBsYXRlIHN0cmluZyBhcmd1bWVudHNcbiAgICAgICAgLy8gb3IgY2FuIHRha2UgYW4gb2JqZWN0IHdpdGggbmFtZS90ZW1wbGF0ZSBwYWlyc1xuICAgICAgICAvLyBXZSdyZSBlbmZvcmNpbmcgdW5pcXVlbmVzcyB0byBhdm9pZCBhY2NpZGVudGFsIHRlbXBsYXRlIG92ZXJ3cml0ZXMuXG4gICAgICAgIC8vIElmIHlvdSB3YW50IGEgZGlmZmVyZW50IHRlbXBsYXRlLCBpdCBzaG91bGQgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgICBhZGRUZW1wbGF0ZTogZnVuY3Rpb24gKG5hbWUsIHRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGVtcGxhdGUgaW4gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRlbXBsYXRlKHRlbXBsYXRlLCBuYW1lW3RlbXBsYXRlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpY2hbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBuYW1lOiBcIiArIG5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGljaC50ZW1wbGF0ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGVtcGxhdGUgXFxcIlwiICsgbmFtZSArIFwiICBcXFwiIGV4aXN0c1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWNoLnRlbXBsYXRlc1tuYW1lXSA9IHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICAgICAgICAgIGljaFtuYW1lXSA9IGZ1bmN0aW9uIChkYXRhLCByYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBNdXN0YWNoZS50b19odG1sKGljaC50ZW1wbGF0ZXNbbmFtZV0sIGRhdGEsIGljaC50ZW1wbGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGljaC4kICYmICFyYXcpID8gaWNoLiQodHJpbShyZXN1bHQpKSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGNsZWFycyBhbGwgcmV0cmlldmFsIGZ1bmN0aW9ucyBhbmQgZW1wdGllcyBjYWNoZVxuICAgICAgICBjbGVhckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGljaC50ZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaWNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpY2gudGVtcGxhdGVzID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gY2xlYXJzL2dyYWJzXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGljaC5jbGVhckFsbCgpO1xuICAgICAgICAgICAgaWNoLmdyYWJUZW1wbGF0ZXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBncmFicyB0ZW1wbGF0ZXMgZnJvbSB0aGUgRE9NIGFuZCBjYWNoZXMgdGhlbS5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFuZCBhZGQgdGVtcGxhdGVzLlxuICAgICAgICAvLyBXaGl0ZXNwYWNlIGF0IGJlZ2lubmluZyBhbmQgZW5kIG9mIGFsbCB0ZW1wbGF0ZXMgaW5zaWRlIDxzY3JpcHQ+IHRhZ3Mgd2lsbFxuICAgICAgICAvLyBiZSB0cmltbWVkLiBJZiB5b3Ugd2FudCB3aGl0ZXNwYWNlIGFyb3VuZCBhIHBhcnRpYWwsIGFkZCBpdCBpbiB0aGUgcGFyZW50LFxuICAgICAgICAvLyBub3QgdGhlIHBhcnRpYWwuIE9yIGRvIGl0IGV4cGxpY2l0bHkgdXNpbmcgPGJyLz4gb3IgJm5ic3A7XG4gICAgICAgIGdyYWJUZW1wbGF0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcbiAgICAgICAgICAgICAgICBzY3JpcHQsXG4gICAgICAgICAgICAgICAgdHJhc2ggPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzY3JpcHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IHNjcmlwdHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaW5uZXJIVE1MICYmIHNjcmlwdC5pZCAmJiAoc2NyaXB0LnR5cGUgPT09IFwidGV4dC9odG1sXCIgfHwgc2NyaXB0LnR5cGUgPT09IFwidGV4dC94LWljYW5oYXpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNoLmFkZFRlbXBsYXRlKHNjcmlwdC5pZCwgdHJpbShzY3JpcHQuaW5uZXJIVE1MKSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYXNoLnVuc2hpZnQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdHJhc2gubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJhc2hbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0cmFzaFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRXhwb3J0IHRoZSBJQ2FuSGF6IG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gICAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgaWNoYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gICAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGljaDtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLmljaCA9IGljaDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290WydpY2gnXSA9IGljaDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoaWNoLiQpIHtcbiAgICAgICAgICAgIGljaC4kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpY2guZ3JhYlRlbXBsYXRlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGljaC5ncmFiVGVtcGxhdGVzKCk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxufSkoKTtcbn0pKCk7XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIoIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59ICggZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG5yZXR1cm4gJC51aS52ZXJzaW9uID0gXCIxLjEyLjFcIjtcblxufSApICk7XG4iLCIvKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFdpZGdldFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgc3RhdGVmdWwgd2lkZ2V0cyB3aXRoIGEgY29tbW9uIEFQSS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3dpZGdldC9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbnZhciB3aWRnZXRVdWlkID0gMDtcbnZhciB3aWRnZXRTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuJC5jbGVhbkRhdGEgPSAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBldmVudHMsIGVsZW0sIGk7XG5cdFx0Zm9yICggaSA9IDA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdC8vIE9ubHkgdHJpZ2dlciByZW1vdmUgd2hlbiBuZWNlc3NhcnkgdG8gc2F2ZSB0aW1lXG5cdFx0XHRcdGV2ZW50cyA9ICQuX2RhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHRcdFx0aWYgKCBldmVudHMgJiYgZXZlbnRzLnJlbW92ZSApIHtcblx0XHRcdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIdHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0fVxuXHRcdG9yaWcoIGVsZW1zICk7XG5cdH07XG59ICkoICQuY2xlYW5EYXRhICk7XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlO1xuXG5cdC8vIFByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0dmFyIHByb3hpZWRQcm90b3R5cGUgPSB7fTtcblxuXHR2YXIgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHR2YXIgZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0aWYgKCAkLmlzQXJyYXkoIHByb3RvdHlwZSApICkge1xuXHRcdHByb3RvdHlwZSA9ICQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIHt9IF0uY29uY2F0KCBwcm90b3R5cGUgKSApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gRXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXG5cdFx0Ly8gQ29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblxuXHRcdC8vIFRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9ICk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cblx0Ly8gV2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuY3Rpb24gX3N1cGVyKCkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIF9zdXBlckFwcGx5KCBhcmdzICkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXI7XG5cdFx0XHRcdHZhciBfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5O1xuXHRcdFx0XHR2YXIgcmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9ICkoKTtcblx0fSApO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblxuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/ICggYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lICkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSApO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gUmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLFxuXHRcdFx0XHRjaGlsZC5fcHJvdG8gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xuXG5cdHJldHVybiBjb25zdHJ1Y3Rvcjtcbn07XG5cbiQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdHZhciBpbnB1dCA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHR2YXIgaW5wdXRJbmRleCA9IDA7XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGtleTtcblx0dmFyIHZhbHVlO1xuXG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHRhcmdldFsga2V5IF0sIHZhbHVlICkgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiO1xuXHRcdHZhciBhcmdzID0gd2lkZ2V0U2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGVtcHR5IGNvbGxlY3Rpb24sIHdlIG5lZWQgdG8gaGF2ZSB0aGUgaW5zdGFuY2UgbWV0aG9kXG5cdFx0XHQvLyByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgdGhlIGpRdWVyeSBpbnN0YW5jZVxuXHRcdFx0aWYgKCAhdGhpcy5sZW5ndGggJiYgb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblxuXHRcdFx0XHRcdGlmICggb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBpbnN0YW5jZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVsgb3B0aW9ucyBdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdFx0aWYgKCBhcmdzLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KCBhcmdzICkgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApO1xuXHRcdFx0XHRcdGlmICggaW5zdGFuY2UuX2luaXQgKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5faW5pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7fSxcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB3aWRnZXRVdWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblx0XHR0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwID0ge307XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblxuXHRcdFx0XHQvLyBFbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFsgMCBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbIDAgXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0JC5lYWNoKCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCB2YWx1ZSwga2V5ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gV2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIENsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0fSxcblxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5O1xuXHRcdHZhciBwYXJ0cztcblx0XHR2YXIgY3VyT3B0aW9uO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBEb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJjbGFzc2VzXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25DbGFzc2VzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uQ2xhc3NlczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc0tleSwgZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50cztcblxuXHRcdGZvciAoIGNsYXNzS2V5IGluIHZhbHVlICkge1xuXHRcdFx0Y3VycmVudEVsZW1lbnRzID0gdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3NLZXkgXTtcblx0XHRcdGlmICggdmFsdWVbIGNsYXNzS2V5IF0gPT09IHRoaXMub3B0aW9ucy5jbGFzc2VzWyBjbGFzc0tleSBdIHx8XG5cdFx0XHRcdFx0IWN1cnJlbnRFbGVtZW50cyB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgYXJlIGRvaW5nIHRoaXMgdG8gY3JlYXRlIGEgbmV3IGpRdWVyeSBvYmplY3QgYmVjYXVzZSB0aGUgX3JlbW92ZUNsYXNzKCkgY2FsbFxuXHRcdFx0Ly8gb24gdGhlIG5leHQgbGluZSBpcyBnb2luZyB0byBkZXN0cm95IHRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZWxlbWVudHMgYmVpbmdcblx0XHRcdC8vIHRyYWNrZWQuIFdlIG5lZWQgdG8gc2F2ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCB0aGUgbmV3IGNsYXNzZXNcblx0XHRcdC8vIGJlbG93LlxuXHRcdFx0ZWxlbWVudHMgPSAkKCBjdXJyZW50RWxlbWVudHMuZ2V0KCkgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50RWxlbWVudHMsIGNsYXNzS2V5ICk7XG5cblx0XHRcdC8vIFdlIGRvbid0IHVzZSBfYWRkQ2xhc3MoKSBoZXJlLCBiZWNhdXNlIHRoYXQgdXNlcyB0aGlzLm9wdGlvbnMuY2xhc3Nlc1xuXHRcdFx0Ly8gZm9yIGdlbmVyYXRpbmcgdGhlIHN0cmluZyBvZiBjbGFzc2VzLiBXZSB3YW50IHRvIHVzZSB0aGUgdmFsdWUgcGFzc2VkIGluIGZyb21cblx0XHRcdC8vIF9zZXRPcHRpb24oKSwgdGhpcyBpcyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBjbGFzc2VzIG9wdGlvbiB3aGljaCB3YXMgcGFzc2VkIHRvXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCkuIFdlIHBhc3MgdGhpcyB2YWx1ZSBkaXJlY3RseSB0byBfY2xhc3NlcygpLlxuXHRcdFx0ZWxlbWVudHMuYWRkQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudHMsXG5cdFx0XHRcdGtleXM6IGNsYXNzS2V5LFxuXHRcdFx0XHRjbGFzc2VzOiB2YWx1ZSxcblx0XHRcdFx0YWRkOiB0cnVlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0KCksIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZFwiLCBudWxsLCAhIXZhbHVlICk7XG5cblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGlzIGJlY29taW5nIGRpc2FibGVkLCB0aGVuIG5vdGhpbmcgaXMgaW50ZXJhY3RpdmVcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaG92ZXJhYmxlLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmZvY3VzYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IGZhbHNlIH0gKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogdHJ1ZSB9ICk7XG5cdH0sXG5cblx0X2NsYXNzZXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBmdWxsID0gW107XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7XG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRjbGFzc2VzOiB0aGlzLm9wdGlvbnMuY2xhc3NlcyB8fCB7fVxuXHRcdH0sIG9wdGlvbnMgKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NDbGFzc1N0cmluZyggY2xhc3NlcywgY2hlY2tPcHRpb24gKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgaTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Y3VycmVudCA9IHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdIHx8ICQoKTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmFkZCApIHtcblx0XHRcdFx0XHRjdXJyZW50ID0gJCggJC51bmlxdWUoIGN1cnJlbnQuZ2V0KCkuY29uY2F0KCBvcHRpb25zLmVsZW1lbnQuZ2V0KCkgKSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoIGN1cnJlbnQubm90KCBvcHRpb25zLmVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdID0gY3VycmVudDtcblx0XHRcdFx0ZnVsbC5wdXNoKCBjbGFzc2VzWyBpIF0gKTtcblx0XHRcdFx0aWYgKCBjaGVja09wdGlvbiAmJiBvcHRpb25zLmNsYXNzZXNbIGNsYXNzZXNbIGkgXSBdICkge1xuXHRcdFx0XHRcdGZ1bGwucHVzaCggb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fb24oIG9wdGlvbnMuZWxlbWVudCwge1xuXHRcdFx0XCJyZW1vdmVcIjogXCJfdW50cmFja0NsYXNzZXNFbGVtZW50XCJcblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMua2V5cyApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5rZXlzLm1hdGNoKCAvXFxTKy9nICkgfHwgW10sIHRydWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmV4dHJhICkge1xuXHRcdFx0cHJvY2Vzc0NsYXNzU3RyaW5nKCBvcHRpb25zLmV4dHJhLm1hdGNoKCAvXFxTKy9nICkgfHwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVsbC5qb2luKCBcIiBcIiApO1xuXHR9LFxuXG5cdF91bnRyYWNrQ2xhc3Nlc0VsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0JC5lYWNoKCB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdGlmICggJC5pbkFycmF5KCBldmVudC50YXJnZXQsIHZhbHVlICkgIT09IC0xICkge1xuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBrZXkgXSA9ICQoIHZhbHVlLm5vdCggZXZlbnQudGFyZ2V0ICkuZ2V0KCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X3JlbW92ZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgZmFsc2UgKTtcblx0fSxcblxuXHRfYWRkQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXlzLCBleHRyYSApIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGVsZW1lbnQsIGtleXMsIGV4dHJhLCB0cnVlICk7XG5cdH0sXG5cblx0X3RvZ2dsZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEsIGFkZCApIHtcblx0XHRhZGQgPSAoIHR5cGVvZiBhZGQgPT09IFwiYm9vbGVhblwiICkgPyBhZGQgOiBleHRyYTtcblx0XHR2YXIgc2hpZnQgPSAoIHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiIHx8IGVsZW1lbnQgPT09IG51bGwgKSxcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGV4dHJhOiBzaGlmdCA/IGtleXMgOiBleHRyYSxcblx0XHRcdFx0a2V5czogc2hpZnQgPyBlbGVtZW50IDoga2V5cyxcblx0XHRcdFx0ZWxlbWVudDogc2hpZnQgPyB0aGlzLmVsZW1lbnQgOiBlbGVtZW50LFxuXHRcdFx0XHRhZGQ6IGFkZFxuXHRcdFx0fTtcblx0XHRvcHRpb25zLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIG9wdGlvbnMgKSwgYWRkICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50O1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBObyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXG5cdFx0XHRcdC8vIEFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFtcXHc6LV0qKVxccyooLiopJC8gKTtcblx0XHRcdHZhciBldmVudE5hbWUgPSBtYXRjaFsgMSBdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2U7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQub24oIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5vbiggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoIGV2ZW50TmFtZSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgK1xuXHRcdFx0dGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50Lm9mZiggZXZlbnROYW1lICkub2ZmKCBldmVudE5hbWUgKTtcblxuXHRcdC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1Nilcblx0XHR0aGlzLmJpbmRpbmdzID0gJCggdGhpcy5iaW5kaW5ncy5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCggdGhpcy5mb2N1c2FibGUubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoIHRoaXMuaG92ZXJhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWc7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XG5cdFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcblxuXHRcdC8vIENvcHkgb3JpZ2luYWwgZXZlbnQgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBuZXcgZXZlbnRcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcblx0XHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WyAwIF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIGhhc09wdGlvbnM7XG5cdFx0dmFyIGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRtZXRob2QgOlxuXHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNPcHRpb25zICYmICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIGVmZmVjdE5hbWUgIT09IG1ldGhvZCAmJiBlbGVtZW50WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBlZmZlY3ROYW1lIF0oIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnF1ZXVlKCBmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbnJldHVybiAkLndpZGdldDtcblxufSApICk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB2YXIgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2VuZXJhdGUgYHNvY2tldC5pZGAgZm9yIHRoZSBnaXZlbiBgbnNwYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuc3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG4gIHJldHVybiAobnNwID09PSAnLycgPyAnJyA6IChuc3AgKyAnIycpKSArIHRoaXMuZW5naW5lLmlkO1xufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7IC8vIHByZXZlbnRzIGEgcmFjZSBjb25kaXRpb24gd2l0aCB0aGUgJ29wZW4nIGV2ZW50XG4gICAgfVxuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmZsYWdzID0ge307XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICBpZiAoIXRoaXMuaW8ucmVjb25uZWN0aW5nKSB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiAodGhpcy5mbGFncy5iaW5hcnkgIT09IHVuZGVmaW5lZCA/IHRoaXMuZmxhZ3MuYmluYXJ5IDogaGFzQmluKGFyZ3MpKSA/IHBhcnNlci5CSU5BUllfRVZFTlQgOiBwYXJzZXIuRVZFTlQsXG4gICAgZGF0YTogYXJnc1xuICB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgdGhpcy5mbGFncyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeSA9IHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyA/IHBhcnNlcXMuZW5jb2RlKHRoaXMucXVlcnkpIDogdGhpcy5xdWVyeTtcbiAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgdmFyIHJvb3ROYW1lc3BhY2VFcnJvciA9IHBhY2tldC50eXBlID09PSBwYXJzZXIuRVJST1IgJiYgcGFja2V0Lm5zcCA9PT0gJy8nO1xuXG4gIGlmICghc2FtZU5hbWVzcGFjZSAmJiAhcm9vdE5hbWVzcGFjZUVycm9yKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmluYXJ5IGZsYWdcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIGVtaXR0ZWQgZGF0YSBjb250YWlucyBiaW5hcnlcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcbiAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uKTtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXHJcbiAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxyXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgfVxyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcbiAgdmFyIHFyeSA9IHt9O1xuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcXJ5O1xufTtcbiIsIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcbiAgICAgICAgdXJpID0ge30sXG4gICAgICAgIGkgPSAxNDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB1cmkucGF0aE5hbWVzID0gcGF0aE5hbWVzKHVyaSwgdXJpWydwYXRoJ10pO1xuICAgIHVyaS5xdWVyeUtleSA9IHF1ZXJ5S2V5KHVyaSwgdXJpWydxdWVyeSddKTtcblxuICAgIHJldHVybiB1cmk7XG59O1xuXG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gICAgdmFyIHJlZ3ggPSAvXFwvezIsOX0vZyxcbiAgICAgICAgbmFtZXMgPSBwYXRoLnJlcGxhY2UocmVneCwgXCIvXCIpLnNwbGl0KFwiL1wiKTtcblxuICAgIGlmIChwYXRoLnN1YnN0cigwLCAxKSA9PSAnLycgfHwgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKDAsIDEpO1xuICAgIH1cbiAgICBpZiAocGF0aC5zdWJzdHIocGF0aC5sZW5ndGggLSAxLCAxKSA9PSAnLycpIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKG5hbWVzLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lcztcbn1cblxuZnVuY3Rpb24gcXVlcnlLZXkodXJpLCBxdWVyeSkge1xuICAgIHZhciBkYXRhID0ge307XG5cbiAgICBxdWVyeS5yZXBsYWNlKC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgaWYgKCQxKSB7XG4gICAgICAgICAgICBkYXRhWyQxXSA9ICQyO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nKTtcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXScpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG52YXIgRVJST1JfUEFDS0VUID0gZXhwb3J0cy5FUlJPUiArICdcImVuY29kZSBlcnJvclwiJztcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBzdHIgKz0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG52YXIgd2l0aE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbnZhciB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgOiAob2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuICh3aXRoTmF0aXZlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHsgbmF0aXZlQ3JlYXRlIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuXG4vLyBDcmVhdGUgYSBuYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG5mdW5jdGlvbiBjdG9yKCkge1xuICByZXR1cm4gZnVuY3Rpb24oKXt9O1xufVxuXG4vLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90b3R5cGUpIHtcbiAgaWYgKCFpc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgdmFyIEN0b3IgPSBjdG9yKCk7XG4gIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSAnLi9tYXRjaGVyLmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcbmltcG9ydCBvcHRpbWl6ZUNiIGZyb20gJy4vX29wdGltaXplQ2IuanMnO1xuXG4vLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBlYWNoXG4vLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBfLmlkZW50aXR5YCxcbi8vIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpKSByZXR1cm4gbWF0Y2hlcih2YWx1ZSk7XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG4iLCJpbXBvcnQgXyBmcm9tICcuL3VuZGVyc2NvcmUuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGl0ZXJhdGVlIGZyb20gJy4vaXRlcmF0ZWUuanMnO1xuXG4vLyBUaGUgZnVuY3Rpb24gd2UgY2FsbCBpbnRlcm5hbGx5IHRvIGdlbmVyYXRlIGEgY2FsbGJhY2suIEl0IGludm9rZXNcbi8vIGBfLml0ZXJhdGVlYCBpZiBvdmVycmlkZGVuLCBvdGhlcndpc2UgYGJhc2VJdGVyYXRlZWAuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgaWYgKF8uaXRlcmF0ZWUgIT09IGl0ZXJhdGVlKSByZXR1cm4gXy5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gIHJldHVybiBiYXNlSXRlcmF0ZWUodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbn1cbiIsImltcG9ydCBfIGZyb20gJy4vdW5kZXJzY29yZS5qcyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNoYWluUmVzdWx0KGluc3RhbmNlLCBvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xufVxuIiwiaW1wb3J0IHsgbm9uRW51bWVyYWJsZVByb3BzLCBPYmpQcm90byB9IGZyb20gJy4vX3NldHVwLmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaGFzIGZyb20gJy4vX2hhcy5qcyc7XG5cbi8vIEludGVybmFsIGhlbHBlciB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIHN0cnVjdHVyZS5cbi8vIGBjb2xsZWN0Tm9uRW51bVByb3BzYCB1c2VkIHRvIGRlcGVuZCBvbiBgXy5jb250YWluc2AsIGJ1dCB0aGlzIGxlZCB0b1xuLy8gY2lyY3VsYXIgaW1wb3J0cy4gYGVtdWxhdGVkU2V0YCBpcyBhIG9uZS1vZmYgc29sdXRpb24gdGhhdCBvbmx5IHdvcmtzIGZvclxuLy8gYXJyYXlzIG9mIHN0cmluZ3MuXG5mdW5jdGlvbiBlbXVsYXRlZFNldChrZXlzKSB7XG4gIHZhciBoYXNoID0ge307XG4gIGZvciAodmFyIGwgPSBrZXlzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyArK2kpIGhhc2hba2V5c1tpXV0gPSB0cnVlO1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGhhc2hba2V5XTsgfSxcbiAgICBwdXNoOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGhhc2hba2V5XSA9IHRydWU7XG4gICAgICByZXR1cm4ga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBJbnRlcm5hbCBoZWxwZXIuIENoZWNrcyBga2V5c2AgZm9yIHRoZSBwcmVzZW5jZSBvZiBrZXlzIGluIElFIDwgOSB0aGF0IHdvbid0XG4vLyBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC4gRXh0ZW5kcyBga2V5c2AgaW4gcGxhY2UgaWZcbi8vIG5lZWRlZC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gIGtleXMgPSBlbXVsYXRlZFNldChrZXlzKTtcbiAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gIHZhciBwcm90byA9IGlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCBPYmpQcm90bztcblxuICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICBpZiAoaGFzKG9iaiwgcHJvcCkgJiYgIWtleXMuY29udGFpbnMocHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAha2V5cy5jb250YWlucyhwcm9wKSkge1xuICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGtleXNGdW5jLCBkZWZhdWx0cykge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGRlZmF1bHRzKSBvYmogPSBPYmplY3Qob2JqKTtcbiAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFkZWZhdWx0cyB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuIiwiaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLy8gSW50ZXJuYWwgaGVscGVyIHRvIGdlbmVyYXRlIGZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5nc1xuLy8gdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVFc2NhcGVyKG1hcCkge1xuICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hcFttYXRjaF07XG4gIH07XG4gIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgdmFyIHNvdXJjZSA9ICcoPzonICsga2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICB9O1xufVxuIiwiaW1wb3J0IGdldExlbmd0aCBmcm9tICcuL19nZXRMZW5ndGguanMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL19zZXR1cC5qcyc7XG5pbXBvcnQgaXNOYU4gZnJvbSAnLi9pc05hTi5qcyc7XG5cbi8vIEludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBgXy5pbmRleE9mYCBhbmQgYF8ubGFzdEluZGV4T2ZgIGZ1bmN0aW9ucy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgaXNOYU4pO1xuICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgIH1cbiAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xufVxuIiwiaW1wb3J0IGNiIGZyb20gJy4vX2NiLmpzJztcbmltcG9ydCBnZXRMZW5ndGggZnJvbSAnLi9fZ2V0TGVuZ3RoLmpzJztcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG59XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCBvcHRpbWl6ZUNiIGZyb20gJy4vX29wdGltaXplQ2IuanMnO1xuXG4vLyBJbnRlcm5hbCBoZWxwZXIgdG8gY3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24sIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAvLyBXcmFwIGNvZGUgdGhhdCByZWFzc2lnbnMgYXJndW1lbnQgdmFyaWFibGVzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gdGhhblxuICAvLyB0aGUgb25lIHRoYXQgYWNjZXNzZXMgYGFyZ3VtZW50cy5sZW5ndGhgIHRvIGF2b2lkIGEgcGVyZiBoaXQuICgjMTk5MSlcbiAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgdmFyIF9rZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYga2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoX2tleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgbWVtbyA9IG9ialtfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgIGluZGV4ICs9IGRpcjtcbiAgICB9XG4gICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMztcbiAgICByZXR1cm4gcmVkdWNlcihvYmosIG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpLCBtZW1vLCBpbml0aWFsKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7IE1BWF9BUlJBWV9JTkRFWCB9IGZyb20gJy4vX3NldHVwLmpzJztcblxuLy8gQ29tbW9uIGludGVybmFsIGxvZ2ljIGZvciBgaXNBcnJheUxpa2VgIGFuZCBgaXNCdWZmZXJMaWtlYC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrKGdldFNpemVQcm9wZXJ0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBzaXplUHJvcGVydHkgPSBnZXRTaXplUHJvcGVydHkoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBzaXplUHJvcGVydHkgPT0gJ251bWJlcicgJiYgc2l6ZVByb3BlcnR5ID49IDAgJiYgc2l6ZVByb3BlcnR5IDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfVxufVxuIiwiLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gb2J0YWluIGEgbmVzdGVkIHByb3BlcnR5IGluIGBvYmpgIGFsb25nIGBwYXRoYC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZXBHZXQob2JqLCBwYXRoKSB7XG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gIH1cbiAgcmV0dXJuIGxlbmd0aCA/IG9iaiA6IHZvaWQgMDtcbn1cbiIsIi8vIEludGVybmFsIGxpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG5leHBvcnQgZGVmYXVsdCB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnXG59O1xuIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8vIEludGVybmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYHNvdXJjZUZ1bmNgIGJvdW5kIHRvIGBjb250ZXh0YCB3aXRoIG9wdGlvbmFsXG4vLyBgYXJnc2AuIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvciBvciBhcyBhXG4vLyBub3JtYWwgZnVuY3Rpb24uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleGVjdXRlQm91bmQoc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgaWYgKGlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IGdldExlbmd0aCBmcm9tICcuL19nZXRMZW5ndGguanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vX2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5cbi8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZsYXR0ZW4oaW5wdXQsIGRlcHRoLCBzdHJpY3QsIG91dHB1dCkge1xuICBvdXRwdXQgPSBvdXRwdXQgfHwgW107XG4gIGlmICghZGVwdGggJiYgZGVwdGggIT09IDApIHtcbiAgICBkZXB0aCA9IEluZmluaXR5O1xuICB9IGVsc2UgaWYgKGRlcHRoIDw9IDApIHtcbiAgICByZXR1cm4gb3V0cHV0LmNvbmNhdChpbnB1dCk7XG4gIH1cbiAgdmFyIGlkeCA9IG91dHB1dC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAvLyBGbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdC5cbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgZmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBzdHJpY3QsIG91dHB1dCk7XG4gICAgICAgIGlkeCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwiaW1wb3J0IHNoYWxsb3dQcm9wZXJ0eSBmcm9tICcuL19zaGFsbG93UHJvcGVydHkuanMnO1xuXG4vLyBJbnRlcm5hbCBoZWxwZXIgdG8gb2J0YWluIHRoZSBgYnl0ZUxlbmd0aGAgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuZXhwb3J0IGRlZmF1bHQgc2hhbGxvd1Byb3BlcnR5KCdieXRlTGVuZ3RoJyk7XG4iLCJpbXBvcnQgc2hhbGxvd1Byb3BlcnR5IGZyb20gJy4vX3NoYWxsb3dQcm9wZXJ0eS5qcyc7XG5cbi8vIEludGVybmFsIGhlbHBlciB0byBvYnRhaW4gdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbmV4cG9ydCBkZWZhdWx0IHNoYWxsb3dQcm9wZXJ0eSgnbGVuZ3RoJyk7XG4iLCJpbXBvcnQgY2IgZnJvbSAnLi9fY2IuanMnO1xuaW1wb3J0IGVhY2ggZnJvbSAnLi9lYWNoLmpzJztcblxuLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JvdXAoYmVoYXZpb3IsIHBhcnRpdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBwYXJ0aXRpb24gPyBbW10sIFtdXSA6IHt9O1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJy4vX3NldHVwLmpzJztcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gY2hlY2sgd2hldGhlciBga2V5YCBpcyBhbiBvd24gcHJvcGVydHkgbmFtZSBvZiBgb2JqYC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG4iLCJpbXBvcnQgY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2sgZnJvbSAnLi9fY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2suanMnO1xuaW1wb3J0IGdldExlbmd0aCBmcm9tICcuL19nZXRMZW5ndGguanMnO1xuXG4vLyBJbnRlcm5hbCBoZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbi8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3QuXG4vLyBSZWxhdGVkOiBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbi8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTaXplUHJvcGVydHlDaGVjayhnZXRMZW5ndGgpO1xuIiwiaW1wb3J0IGNyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrIGZyb20gJy4vX2NyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrLmpzJztcbmltcG9ydCBnZXRCeXRlTGVuZ3RoIGZyb20gJy4vX2dldEJ5dGVMZW5ndGguanMnO1xuXG4vLyBJbnRlcm5hbCBoZWxwZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2Ugc2hvdWxkIHNwZW5kIGV4dGVuc2l2ZSBjaGVja3MgYWdhaW5zdFxuLy8gYEFycmF5QnVmZmVyYCBldCBhbC5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrKGdldEJ5dGVMZW5ndGgpO1xuIiwiLy8gSW50ZXJuYWwgYF8ucGlja2AgaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGBrZXlgIGlzIGFuIGVudW1lcmFibGVcbi8vIHByb3BlcnR5IG5hbWUgb2YgYG9iamAuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBrZXlJbk9iaih2YWx1ZSwga2V5LCBvYmopIHtcbiAgcmV0dXJuIGtleSBpbiBvYmo7XG59XG4iLCIvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4vLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuLy8gZnVuY3Rpb25zLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3B0aW1pemVDYihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgIH07XG4gICAgLy8gVGhlIDItYXJndW1lbnQgY2FzZSBpcyBvbWl0dGVkIGJlY2F1c2Ugd2XigJlyZSBub3QgdXNpbmcgaXQuXG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvLyBDdXJyZW50IHZlcnNpb24uXG5leHBvcnQgdmFyIFZFUlNJT04gPSAnMS4xMS4wJztcblxuLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIGBnbG9iYWxgXG4vLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4vLyBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuZXhwb3J0IHZhciByb290ID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHxcbiAgICAgICAgICB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHxcbiAgICAgICAgICBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpIHx8XG4gICAgICAgICAge307XG5cbi8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG5leHBvcnQgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgU3ltYm9sUHJvdG8gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5wcm90b3R5cGUgOiBudWxsO1xuXG4vLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbmV4cG9ydCB2YXIgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4vLyBNb2Rlcm4gZmVhdHVyZSBkZXRlY3Rpb24uXG5leHBvcnQgdmFyIHN1cHBvcnRzQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBBbGwgKipFQ01BU2NyaXB0IDUrKiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4vLyBhcmUgZGVjbGFyZWQgaGVyZS5cbmV4cG9ydCB2YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgbmF0aXZlSXNWaWV3ID0gc3VwcG9ydHNBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5cbi8vIENyZWF0ZSByZWZlcmVuY2VzIHRvIHRoZXNlIGJ1aWx0aW4gZnVuY3Rpb25zIGJlY2F1c2Ugd2Ugb3ZlcnJpZGUgdGhlbS5cbmV4cG9ydCB2YXIgX2lzTmFOID0gaXNOYU4sXG4gICAgX2lzRmluaXRlID0gaXNGaW5pdGU7XG5cbi8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG5leHBvcnQgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbmV4cG9ydCB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuLy8gVGhlIGxhcmdlc3QgaW50ZWdlciB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBleGFjdGx5LlxuZXhwb3J0IHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuIiwiLy8gSW50ZXJuYWwgaGVscGVyIHRvIGdlbmVyYXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIHByb3BlcnR5IGBrZXlgIGZyb20gYG9iamAuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaGFsbG93UHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgfTtcbn1cbiIsImltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuXG4vLyBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBgdG9TdHJpbmdgLWJhc2VkIHR5cGUgdGVzdGVyLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGFnVGVzdGVyKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICB9O1xufVxuIiwiaW1wb3J0IGludmVydCBmcm9tICcuL2ludmVydC5qcyc7XG5pbXBvcnQgZXNjYXBlTWFwIGZyb20gJy4vX2VzY2FwZU1hcC5qcyc7XG5cbi8vIEludGVybmFsIGxpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgdW5lc2NhcGluZy5cbmV4cG9ydCBkZWZhdWx0IGludmVydChlc2NhcGVNYXApO1xuIiwiLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZnRlcih0aW1lcywgZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB7IGhhc0VudW1CdWcgfSBmcm9tICcuL19zZXR1cC5qcyc7XG5pbXBvcnQgY29sbGVjdE5vbkVudW1Qcm9wcyBmcm9tICcuL19jb2xsZWN0Tm9uRW51bVByb3BzLmpzJztcblxuLy8gUmV0cmlldmUgYWxsIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFsbEtleXMob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgLy8gQWhlbSwgSUUgPCA5LlxuICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICByZXR1cm4ga2V5cztcbn1cbiIsIi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZVxuLy8gTnRoIGNhbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiZWZvcmUodGltZXMsIGZ1bmMpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn1cbiIsImltcG9ydCByZXN0QXJndW1lbnRzIGZyb20gJy4vcmVzdEFyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGV4ZWN1dGVCb3VuZCBmcm9tICcuL19leGVjdXRlQm91bmQuanMnO1xuXG4vLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbi8vIG9wdGlvbmFsbHkpLlxuZXhwb3J0IGRlZmF1bHQgcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdzKSB7XG4gIGlmICghaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gIHZhciBib3VuZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oY2FsbEFyZ3MpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChjYWxsQXJncykpO1xuICB9KTtcbiAgcmV0dXJuIGJvdW5kO1xufSk7XG4iLCJpbXBvcnQgcmVzdEFyZ3VtZW50cyBmcm9tICcuL3Jlc3RBcmd1bWVudHMuanMnO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSAnLi9fZmxhdHRlbi5qcyc7XG5pbXBvcnQgYmluZCBmcm9tICcuL2JpbmQuanMnO1xuXG4vLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbi8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuZXhwb3J0IGRlZmF1bHQgcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gIGlmIChpbmRleCA8IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICBvYmpba2V5XSA9IGJpbmQob2JqW2tleV0sIG9iaik7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0pO1xuIiwiaW1wb3J0IF8gZnJvbSAnLi91bmRlcnNjb3JlLmpzJztcblxuLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2hhaW4ob2JqKSB7XG4gIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL19zZXR1cC5qcyc7XG5cbi8vIENodW5rIGEgc2luZ2xlIGFycmF5IGludG8gbXVsdGlwbGUgYXJyYXlzLCBlYWNoIGNvbnRhaW5pbmcgYGNvdW50YCBvciBmZXdlclxuLy8gaXRlbXMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjaHVuayhhcnJheSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKSByZXR1cm4gW107XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goc2xpY2UuY2FsbChhcnJheSwgaSwgaSArPSBjb3VudCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuL2V4dGVuZC5qcyc7XG5cbi8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHJldHVybiBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGV4dGVuZCh7fSwgb2JqKTtcbn1cbiIsImltcG9ydCBmaWx0ZXIgZnJvbSAnLi9maWx0ZXIuanMnO1xuXG4vLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gIHJldHVybiBmaWx0ZXIoYXJyYXksIEJvb2xlYW4pO1xufVxuIiwiLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbi8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSBzdGFydDtcbiAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuIiwiLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb24uIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vX2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMuanMnO1xuaW1wb3J0IGluZGV4T2YgZnJvbSAnLi9pbmRleE9mLmpzJztcblxuLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSB2YWx1ZXMob2JqKTtcbiAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gIHJldHVybiBpbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xufVxuIiwiaW1wb3J0IGdyb3VwIGZyb20gJy4vX2dyb3VwLmpzJztcbmltcG9ydCBoYXMgZnJvbSAnLi9faGFzLmpzJztcblxuLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4vLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbi8vIGNyaXRlcmlvbi5cbmV4cG9ydCBkZWZhdWx0IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG59KTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGV4dGVuZE93biBmcm9tICcuL2V4dGVuZE93bi5qcyc7XG5cbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbi8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyBjcmVhdGVkIG9iamVjdC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BzKSB7XG4gIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gIGlmIChwcm9wcykgZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHJlc3RBcmd1bWVudHMgZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcbmltcG9ydCBkZWxheSBmcm9tICcuL2RlbGF5LmpzJztcblxuLy8gV2hlbiBhIHNlcXVlbmNlIG9mIGNhbGxzIG9mIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBlbmRzLCB0aGUgYXJndW1lbnRcbi8vIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZC4gVGhlIGVuZCBvZiBhIHNlcXVlbmNlIGlzIGRlZmluZWQgYnkgdGhlIGB3YWl0YFxuLy8gcGFyYW1ldGVyLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRoZSBhcmd1bWVudCBmdW5jdGlvbiB3aWxsIGJlXG4vLyB0cmlnZ2VyZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VxdWVuY2UgaW5zdGVhZCBvZiBhdCB0aGUgZW5kLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0LCByZXN1bHQ7XG5cbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIGlmIChhcmdzKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBkZWJvdW5jZWQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIHZhciBjYWxsTm93ID0gIXRpbWVvdXQ7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IGRlbGF5KGxhdGVyLCB3YWl0LCB0aGlzLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICBkZWJvdW5jZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG4iLCJpbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuaW1wb3J0IGFsbEtleXMgZnJvbSAnLi9hbGxLZXlzLmpzJztcblxuLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyKGFsbEtleXMsIHRydWUpO1xuIiwiaW1wb3J0IHBhcnRpYWwgZnJvbSAnLi9wYXJ0aWFsLmpzJztcbmltcG9ydCBkZWxheSBmcm9tICcuL2RlbGF5LmpzJztcbmltcG9ydCBfIGZyb20gJy4vdW5kZXJzY29yZS5qcyc7XG5cbi8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuLy8gY2xlYXJlZC5cbmV4cG9ydCBkZWZhdWx0IHBhcnRpYWwoZGVsYXksIF8sIDEpO1xuIiwiaW1wb3J0IHJlc3RBcmd1bWVudHMgZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcblxuLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuZXhwb3J0IGRlZmF1bHQgcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9LCB3YWl0KTtcbn0pO1xuIiwiaW1wb3J0IHJlc3RBcmd1bWVudHMgZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcbmltcG9ydCBmbGF0dGVuIGZyb20gJy4vX2ZsYXR0ZW4uanMnO1xuaW1wb3J0IGZpbHRlciBmcm9tICcuL2ZpbHRlci5qcyc7XG5pbXBvcnQgY29udGFpbnMgZnJvbSAnLi9jb250YWlucy5qcyc7XG5cbi8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbi8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG5leHBvcnQgZGVmYXVsdCByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCByZXN0KSB7XG4gIHJlc3QgPSBmbGF0dGVuKHJlc3QsIHRydWUsIHRydWUpO1xuICByZXR1cm4gZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgcmV0dXJuICFjb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gIH0pO1xufSk7XG4iLCJpbXBvcnQgb3B0aW1pemVDYiBmcm9tICcuL19vcHRpbWl6ZUNiLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vLyBUaGUgY29ybmVyc3RvbmUgZm9yIGNvbGxlY3Rpb24gZnVuY3Rpb25zLCBhbiBgZWFjaGBcbi8vIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB2YXIgaSwgbGVuZ3RoO1xuICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgX2tleXMgPSBrZXlzKG9iaik7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gX2tleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZXJhdGVlKG9ialtfa2V5c1tpXV0sIF9rZXlzW2ldLCBvYmopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuIiwiaW1wb3J0IGNyZWF0ZUVzY2FwZXIgZnJvbSAnLi9fY3JlYXRlRXNjYXBlci5qcyc7XG5pbXBvcnQgZXNjYXBlTWFwIGZyb20gJy4vX2VzY2FwZU1hcC5qcyc7XG5cbi8vIEZ1bmN0aW9uIGZvciBlc2NhcGluZyBzdHJpbmdzIHRvIEhUTUwgaW50ZXJwb2xhdGlvbi5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiIsImltcG9ydCBjYiBmcm9tICcuL19jYi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBwYXNzIGEgdHJ1dGggdGVzdC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV2ZXJ5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgIGxlbmd0aCA9IChfa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQgYWxsS2V5cyBmcm9tICcuL2FsbEtleXMuanMnO1xuXG4vLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyKGFsbEtleXMpO1xuIiwiaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW5cbi8vIG9iamVjdChzKS5cbi8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQXNzaWduZXIoa2V5cyk7XG4iLCJpbXBvcnQgY2IgZnJvbSAnLi9fY2IuanMnO1xuaW1wb3J0IGVhY2ggZnJvbSAnLi9lYWNoLmpzJztcblxuLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbHRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGZpbmRJbmRleCBmcm9tICcuL2ZpbmRJbmRleC5qcyc7XG5pbXBvcnQgZmluZEtleSBmcm9tICcuL2ZpbmRLZXkuanMnO1xuXG4vLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gIHZhciBrZXlGaW5kZXIgPSBpc0FycmF5TGlrZShvYmopID8gZmluZEluZGV4IDogZmluZEtleTtcbiAgdmFyIGtleSA9IGtleUZpbmRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG59XG4iLCJpbXBvcnQgY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIgZnJvbSAnLi9fY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIuanMnO1xuXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdC5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuIiwiaW1wb3J0IGNiIGZyb20gJy4vX2NiLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSB0cnV0aCB0ZXN0LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICB2YXIgX2tleXMgPSBrZXlzKG9iaiksIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gX2tleXNbaV07XG4gICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIgZnJvbSAnLi9fY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIuanMnO1xuXG4vLyBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSB0cnV0aCB0ZXN0LlxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuIiwiaW1wb3J0IGZpbmQgZnJvbSAnLi9maW5kLmpzJztcbmltcG9ydCBtYXRjaGVyIGZyb20gJy4vbWF0Y2hlci5qcyc7XG5cbi8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYF8uZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0XG4vLyBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRXaGVyZShvYmosIGF0dHJzKSB7XG4gIHJldHVybiBmaW5kKG9iaiwgbWF0Y2hlcihhdHRycykpO1xufVxuIiwiaW1wb3J0IGluaXRpYWwgZnJvbSAnLi9pbml0aWFsLmpzJztcblxuLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4vLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpcnN0KGFycmF5LCBuLCBndWFyZCkge1xuICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsIHx8IGd1YXJkID8gdm9pZCAwIDogW107XG4gIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgcmV0dXJuIGluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xufVxuIiwiaW1wb3J0IF9mbGF0dGVuIGZyb20gJy4vX2ZsYXR0ZW4uanMnO1xuXG4vLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IgdXAgdG8gYGRlcHRoYC5cbi8vIFBhc3NpbmcgYHRydWVgIG9yIGBmYWxzZWAgYXMgYGRlcHRoYCBtZWFucyBgMWAgb3IgYEluZmluaXR5YCwgcmVzcGVjdGl2ZWx5LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgZGVwdGgpIHtcbiAgcmV0dXJuIF9mbGF0dGVuKGFycmF5LCBkZXB0aCwgZmFsc2UpO1xufVxuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcblxuLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuY3Rpb25zKG9iaikge1xuICB2YXIgbmFtZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBuYW1lcy5zb3J0KCk7XG59XG4iLCJpbXBvcnQgZ3JvdXAgZnJvbSAnLi9fZ3JvdXAuanMnO1xuaW1wb3J0IGhhcyBmcm9tICcuL19oYXMuanMnO1xuXG4vLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4vLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbmV4cG9ydCBkZWZhdWx0IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xufSk7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9faGFzLmpzJztcbmltcG9ydCB7IGhhc093blByb3BlcnR5IH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuXG4vLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5IG9uXG4vLyBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLiBVbmxpa2UgdGhlIGludGVybmFsIGBoYXNgXG4vLyBmdW5jdGlvbiwgdGhpcyBwdWJsaWMgdmVyc2lvbiBjYW4gYWxzbyB0cmF2ZXJzZSBuZXN0ZWQgcHJvcGVydGllcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhcyhvYmosIHBhdGgpIHtcbiAgaWYgKCFpc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIF9oYXMob2JqLCBwYXRoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpXTtcbiAgICBpZiAob2JqID09IG51bGwgfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiAhIWxlbmd0aDtcbn1cbiIsIi8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG4iLCIvLyBFU00gRXhwb3J0c1xuLy8gPT09PT09PT09PT1cbi8vIFRoaXMgbW9kdWxlIGlzIHRoZSBwYWNrYWdlIGVudHJ5IHBvaW50IGZvciBFUyBtb2R1bGUgdXNlcnMuIEluIG90aGVyIHdvcmRzLFxuLy8gaXQgaXMgdGhlIG1vZHVsZSB0aGV5IGFyZSBpbnRlcmZhY2luZyB3aXRoIHdoZW4gdGhleSBpbXBvcnQgZnJvbSB0aGUgd2hvbGVcbi8vIHBhY2thZ2UgaW5zdGVhZCBvZiBmcm9tIGEgc3VibW9kdWxlLCBsaWtlIHRoaXM6XG4vL1xuLy8gYGBganNcbi8vIGltcG9ydCB7IG1hcCB9IGZyb20gJ3VuZGVyc2NvcmUnO1xuLy8gYGBgXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2Ugd2l0aCBgLi9pbmRleC1kZWZhdWx0YCwgd2hpY2ggaXMgdGhlIHBhY2thZ2UgZW50cnkgcG9pbnQgZm9yXG4vLyBDb21tb25KUywgQU1EIGFuZCBVTUQgdXNlcnMsIGlzIHB1cmVseSB0ZWNobmljYWwuIEluIEVTIG1vZHVsZXMsIG5hbWVkIGFuZFxuLy8gZGVmYXVsdCBleHBvcnRzIGFyZSBjb25zaWRlcmVkIHRvIGJlIHNpYmxpbmdzLCBzbyB3aGVuIHlvdSBoYXZlIGEgZGVmYXVsdFxuLy8gZXhwb3J0LCBpdHMgcHJvcGVydGllcyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgYXZhaWxhYmxlIGFzIG5hbWVkIGV4cG9ydHMuIEZvclxuLy8gdGhpcyByZWFzb24sIHdlIHJlLWV4cG9ydCB0aGUgbmFtZWQgZXhwb3J0cyBpbiBhZGRpdGlvbiB0byBwcm92aWRpbmcgdGhlIHNhbWVcbi8vIGRlZmF1bHQgZXhwb3J0IGFzIGluIGAuL2luZGV4LWRlZmF1bHRgLlxuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vaW5kZXgtZGVmYXVsdC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZGV4LmpzJztcbiIsIi8vIERlZmF1bHQgRXhwb3J0XG4vLyA9PT09PT09PT09PT09PVxuLy8gSW4gdGhpcyBtb2R1bGUsIHdlIG1peCBvdXIgYnVuZGxlZCBleHBvcnRzIGludG8gdGhlIGBfYCBvYmplY3QgYW5kIGV4cG9ydFxuLy8gdGhlIHJlc3VsdC4gVGhpcyBpcyBhbmFsb2dvdXMgdG8gc2V0dGluZyBgbW9kdWxlLmV4cG9ydHMgPSBfYCBpbiBDb21tb25KUy5cbi8vIEhlbmNlLCB0aGlzIG1vZHVsZSBpcyBhbHNvIHRoZSBlbnRyeSBwb2ludCBvZiBvdXIgVU1EIGJ1bmRsZSBhbmQgdGhlIHBhY2thZ2Vcbi8vIGVudHJ5IHBvaW50IGZvciBDb21tb25KUyBhbmQgQU1EIHVzZXJzLiBJbiBvdGhlciB3b3JkcywgdGhpcyBpcyAodGhlIHNvdXJjZVxuLy8gb2YpIHRoZSBtb2R1bGUgeW91IGFyZSBpbnRlcmZhY2luZyB3aXRoIHdoZW4geW91IGRvIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuLy9cbi8vIGBgYGpzXG4vLyAvLyBDb21tb25KU1xuLy8gdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4vL1xuLy8gLy8gQU1EXG4vLyBkZWZpbmUoWyd1bmRlcnNjb3JlJ10sIGZ1bmN0aW9uKF8pIHsuLi59KTtcbi8vXG4vLyAvLyBVTUQgaW4gdGhlIGJyb3dzZXJcbi8vIC8vIF8gaXMgYXZhaWxhYmxlIGFzIGEgZ2xvYmFsIHZhcmlhYmxlXG4vLyBgYGBcbmltcG9ydCAqIGFzIGFsbEV4cG9ydHMgZnJvbSAnLi9pbmRleC5qcyc7XG5pbXBvcnQgeyBtaXhpbiB9IGZyb20gJy4vaW5kZXguanMnO1xuXG4vLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG52YXIgXyA9IG1peGluKGFsbEV4cG9ydHMpO1xuLy8gTGVnYWN5IE5vZGUuanMgQVBJLlxuXy5fID0gXztcbi8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBBUEkuXG5leHBvcnQgZGVmYXVsdCBfO1xuIiwiLy8gTmFtZWQgRXhwb3J0c1xuLy8gPT09PT09PT09PT09PVxuXG4vLyAgICAgVW5kZXJzY29yZS5qcyAxLjExLjBcbi8vICAgICBodHRwczovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDIwIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuLy8gQmFzZWxpbmUgc2V0dXAuXG5leHBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZXN0QXJndW1lbnRzIH0gZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcblxuLy8gT2JqZWN0IEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3VyIG1vc3QgZnVuZGFtZW50YWwgZnVuY3Rpb25zIG9wZXJhdGUgb24gYW55IEphdmFTY3JpcHQgb2JqZWN0LlxuLy8gTW9zdCBmdW5jdGlvbnMgaW4gVW5kZXJzY29yZSBkZXBlbmQgb24gYXQgbGVhc3Qgb25lIGZ1bmN0aW9uIGluIHRoaXMgc2VjdGlvbi5cblxuLy8gQSBncm91cCBvZiBmdW5jdGlvbnMgdGhhdCBjaGVjayB0aGUgdHlwZXMgb2YgY29yZSBKYXZhU2NyaXB0IHZhbHVlcy5cbi8vIFRoZXNlIGFyZSBvZnRlbiBpbmZvcm1hbGx5IHJlZmVycmVkIHRvIGFzIHRoZSBcImlzVHlwZVwiIGZ1bmN0aW9ucy5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNPYmplY3QgfSBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNOdWxsIH0gZnJvbSAnLi9pc051bGwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc1VuZGVmaW5lZCB9IGZyb20gJy4vaXNVbmRlZmluZWQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc0Jvb2xlYW4gfSBmcm9tICcuL2lzQm9vbGVhbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlzRWxlbWVudCB9IGZyb20gJy4vaXNFbGVtZW50LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNTdHJpbmcgfSBmcm9tICcuL2lzU3RyaW5nLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNOdW1iZXIgfSBmcm9tICcuL2lzTnVtYmVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNEYXRlIH0gZnJvbSAnLi9pc0RhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc1JlZ0V4cCB9IGZyb20gJy4vaXNSZWdFeHAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc0Vycm9yIH0gZnJvbSAnLi9pc0Vycm9yLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNTeW1ib2wgfSBmcm9tICcuL2lzU3ltYm9sLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNNYXAgfSBmcm9tICcuL2lzTWFwLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNXZWFrTWFwIH0gZnJvbSAnLi9pc1dlYWtNYXAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc1NldCB9IGZyb20gJy4vaXNTZXQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc1dlYWtTZXQgfSBmcm9tICcuL2lzV2Vha1NldC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlzQXJyYXlCdWZmZXIgfSBmcm9tICcuL2lzQXJyYXlCdWZmZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc0RhdGFWaWV3IH0gZnJvbSAnLi9pc0RhdGFWaWV3LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNBcnJheSB9IGZyb20gJy4vaXNBcnJheS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc0FyZ3VtZW50cyB9IGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc0Zpbml0ZSB9IGZyb20gJy4vaXNGaW5pdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc05hTiB9IGZyb20gJy4vaXNOYU4uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc1R5cGVkQXJyYXkgfSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlzRW1wdHkgfSBmcm9tICcuL2lzRW1wdHkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc01hdGNoIH0gZnJvbSAnLi9pc01hdGNoLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNFcXVhbCB9IGZyb20gJy4vaXNFcXVhbC5qcyc7XG5cbi8vIEZ1bmN0aW9ucyB0aGF0IHRyZWF0IGFuIG9iamVjdCBhcyBhIGRpY3Rpb25hcnkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBrZXlzIH0gZnJvbSAnLi9rZXlzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYWxsS2V5cyB9IGZyb20gJy4vYWxsS2V5cy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbHVlcyB9IGZyb20gJy4vdmFsdWVzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFpcnMgfSBmcm9tICcuL3BhaXJzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW52ZXJ0IH0gZnJvbSAnLi9pbnZlcnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmdW5jdGlvbnMsXG4gICAgICAgICBkZWZhdWx0IGFzIG1ldGhvZHMgICB9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXh0ZW5kIH0gZnJvbSAnLi9leHRlbmQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBleHRlbmRPd24sXG4gICAgICAgICBkZWZhdWx0IGFzIGFzc2lnbiAgICB9IGZyb20gJy4vZXh0ZW5kT3duLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlIH0gZnJvbSAnLi9jcmVhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjbG9uZSB9IGZyb20gJy4vY2xvbmUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0YXAgfSBmcm9tICcuL3RhcC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhhcyB9IGZyb20gJy4vaGFzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWFwT2JqZWN0IH0gZnJvbSAnLi9tYXBPYmplY3QuanMnO1xuXG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEEgYml0IG9mIGEgZ3JhYiBiYWc6IFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggZmlsdGVycyBhbmRcbi8vIGxvb3BzLCBzdHJpbmcgZXNjYXBpbmcgYW5kIHRlbXBsYXRpbmcsIGNyZWF0ZSByYW5kb20gbnVtYmVycyBhbmQgdW5pcXVlIGlkcyxcbi8vIGFuZCBmdW5jdGlvbnMgdGhhdCBmYWNpbGl0YXRlIFVuZGVyc2NvcmUncyBjaGFpbmluZyBhbmQgaXRlcmF0aW9uIGNvbnZlbnRpb25zLlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBpZGVudGl0eSB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb25zdGFudCB9IGZyb20gJy4vY29uc3RhbnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBub29wIH0gZnJvbSAnLi9ub29wLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvcGVydHkgfSBmcm9tICcuL3Byb3BlcnR5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvcGVydHlPZiB9IGZyb20gJy4vcHJvcGVydHlPZi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hdGNoZXIsXG4gICAgICAgICBkZWZhdWx0IGFzIG1hdGNoZXMgfSBmcm9tICcuL21hdGNoZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0aW1lcyB9IGZyb20gJy4vdGltZXMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByYW5kb20gfSBmcm9tICcuL3JhbmRvbS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vdyB9IGZyb20gJy4vbm93LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXNjYXBlIH0gZnJvbSAnLi9lc2NhcGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmVzY2FwZSB9IGZyb20gJy4vdW5lc2NhcGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0ZW1wbGF0ZVNldHRpbmdzIH0gZnJvbSAnLi90ZW1wbGF0ZVNldHRpbmdzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGVtcGxhdGUgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVzdWx0IH0gZnJvbSAnLi9yZXN1bHQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmlxdWVJZCB9IGZyb20gJy4vdW5pcXVlSWQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjaGFpbiB9IGZyb20gJy4vY2hhaW4uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpdGVyYXRlZSB9IGZyb20gJy4vaXRlcmF0ZWUuanMnO1xuXG4vLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGVzZSBmdW5jdGlvbnMgdGFrZSBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm4gYSBuZXcgZnVuY3Rpb25cbi8vIGFzIHRoZSByZXN1bHQuIEFsc28ga25vd24gYXMgaGlnaGVyLW9yZGVyIGZ1bmN0aW9ucy5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydGlhbCB9IGZyb20gJy4vcGFydGlhbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJpbmQgfSBmcm9tICcuL2JpbmQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBiaW5kQWxsIH0gZnJvbSAnLi9iaW5kQWxsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVtb2l6ZSB9IGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlbGF5IH0gZnJvbSAnLi9kZWxheS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlZmVyIH0gZnJvbSAnLi9kZWZlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRocm90dGxlIH0gZnJvbSAnLi90aHJvdHRsZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlYm91bmNlIH0gZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHdyYXAgfSBmcm9tICcuL3dyYXAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBuZWdhdGUgfSBmcm9tICcuL25lZ2F0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXBvc2UgfSBmcm9tICcuL2NvbXBvc2UuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhZnRlciB9IGZyb20gJy4vYWZ0ZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBiZWZvcmUgfSBmcm9tICcuL2JlZm9yZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9uY2UgfSBmcm9tICcuL29uY2UuanMnO1xuXG4vLyBGaW5kZXJzXG4vLyAtLS0tLS0tXG4vLyBGdW5jdGlvbnMgdGhhdCBleHRyYWN0ICh0aGUgcG9zaXRpb24gb2YpIGEgc2luZ2xlIGVsZW1lbnQgZnJvbSBhbiBvYmplY3Rcbi8vIG9yIGFycmF5IGJhc2VkIG9uIHNvbWUgY3JpdGVyaW9uLlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaW5kS2V5IH0gZnJvbSAnLi9maW5kS2V5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmluZEluZGV4IH0gZnJvbSAnLi9maW5kSW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaW5kTGFzdEluZGV4IH0gZnJvbSAnLi9maW5kTGFzdEluZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc29ydGVkSW5kZXggfSBmcm9tICcuL3NvcnRlZEluZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5kZXhPZiB9IGZyb20gJy4vaW5kZXhPZi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxhc3RJbmRleE9mIH0gZnJvbSAnLi9sYXN0SW5kZXhPZi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmQsXG4gICAgICAgICBkZWZhdWx0IGFzIGRldGVjdCB9IGZyb20gJy4vZmluZC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmRXaGVyZSB9IGZyb20gJy4vZmluZFdoZXJlLmpzJztcblxuLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGdW5jdGlvbnMgdGhhdCB3b3JrIG9uIGFueSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzOiBlaXRoZXIgYW4gYXJyYXksIG9yXG4vLyBhbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzLlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBlYWNoLFxuICAgICAgICAgZGVmYXVsdCBhcyBmb3JFYWNoIH0gZnJvbSAnLi9lYWNoLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWFwLFxuICAgICAgICAgZGVmYXVsdCBhcyBjb2xsZWN0IH0gZnJvbSAnLi9tYXAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWR1Y2UsXG4gICAgICAgICBkZWZhdWx0IGFzIGZvbGRsLFxuICAgICAgICAgZGVmYXVsdCBhcyBpbmplY3QgfSBmcm9tICcuL3JlZHVjZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlZHVjZVJpZ2h0LFxuICAgICAgICAgZGVmYXVsdCBhcyBmb2xkciAgICAgICB9IGZyb20gJy4vcmVkdWNlUmlnaHQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaWx0ZXIsXG4gICAgICAgICBkZWZhdWx0IGFzIHNlbGVjdCB9IGZyb20gJy4vZmlsdGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVqZWN0IH0gZnJvbSAnLi9yZWplY3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBldmVyeSxcbiAgICAgICAgIGRlZmF1bHQgYXMgYWxsICAgfSBmcm9tICcuL2V2ZXJ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc29tZSxcbiAgICAgICAgIGRlZmF1bHQgYXMgYW55ICB9IGZyb20gJy4vc29tZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbnRhaW5zLFxuICAgICAgICAgZGVmYXVsdCBhcyBpbmNsdWRlcyxcbiAgICAgICAgIGRlZmF1bHQgYXMgaW5jbHVkZSAgfSBmcm9tICcuL2NvbnRhaW5zLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW52b2tlIH0gZnJvbSAnLi9pbnZva2UuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwbHVjayB9IGZyb20gJy4vcGx1Y2suanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aGVyZSB9IGZyb20gJy4vd2hlcmUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYXggfSBmcm9tICcuL21heC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1pbiB9IGZyb20gJy4vbWluLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2h1ZmZsZSB9IGZyb20gJy4vc2h1ZmZsZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNhbXBsZSB9IGZyb20gJy4vc2FtcGxlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc29ydEJ5IH0gZnJvbSAnLi9zb3J0QnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBncm91cEJ5IH0gZnJvbSAnLi9ncm91cEJ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5kZXhCeSB9IGZyb20gJy4vaW5kZXhCeS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvdW50QnkgfSBmcm9tICcuL2NvdW50QnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJ0aXRpb24gfSBmcm9tICcuL3BhcnRpdGlvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRvQXJyYXkgfSBmcm9tICcuL3RvQXJyYXkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzaXplIH0gZnJvbSAnLi9zaXplLmpzJztcblxuLy8gYF8ucGlja2AgYW5kIGBfLm9taXRgIGFyZSBhY3R1YWxseSBvYmplY3QgZnVuY3Rpb25zLCBidXQgd2UgcHV0XG4vLyB0aGVtIGhlcmUgaW4gb3JkZXIgdG8gY3JlYXRlIGEgbW9yZSBuYXR1cmFsIHJlYWRpbmcgb3JkZXIgaW4gdGhlXG4vLyBtb25vbGl0aGljIGJ1aWxkIGFzIHRoZXkgZGVwZW5kIG9uIGBfLmNvbnRhaW5zYC5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGljayB9IGZyb20gJy4vcGljay5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9taXQgfSBmcm9tICcuL29taXQuanMnO1xuXG4vLyBBcnJheSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLVxuLy8gRnVuY3Rpb25zIHRoYXQgb3BlcmF0ZSBvbiBhcnJheXMgKGFuZCBhcnJheS1saWtlcykgb25seSwgYmVjYXVzZSB0aGV54oCZcmVcbi8vIGV4cHJlc3NlZCBpbiB0ZXJtcyBvZiBvcGVyYXRpb25zIG9uIGFuIG9yZGVyZWQgbGlzdCBvZiB2YWx1ZXMuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpcnN0LFxuICAgICAgICAgZGVmYXVsdCBhcyBoZWFkLFxuICAgICAgICAgZGVmYXVsdCBhcyB0YWtlICB9IGZyb20gJy4vZmlyc3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbml0aWFsIH0gZnJvbSAnLi9pbml0aWFsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGFzdCB9IGZyb20gJy4vbGFzdC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlc3QsXG4gICAgICAgICBkZWZhdWx0IGFzIHRhaWwsXG4gICAgICAgICBkZWZhdWx0IGFzIGRyb3AgfSBmcm9tICcuL3Jlc3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wYWN0IH0gZnJvbSAnLi9jb21wYWN0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmxhdHRlbiB9IGZyb20gJy4vZmxhdHRlbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhvdXQgfSBmcm9tICcuL3dpdGhvdXQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmlxLFxuICAgICAgICAgZGVmYXVsdCBhcyB1bmlxdWUgfSBmcm9tICcuL3VuaXEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmlvbiB9IGZyb20gJy4vdW5pb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnRlcnNlY3Rpb24gfSBmcm9tICcuL2ludGVyc2VjdGlvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpZmZlcmVuY2UgfSBmcm9tICcuL2RpZmZlcmVuY2UuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnppcCxcbiAgICAgICAgIGRlZmF1bHQgYXMgdHJhbnNwb3NlIH0gZnJvbSAnLi91bnppcC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHppcCB9IGZyb20gJy4vemlwLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgb2JqZWN0IH0gZnJvbSAnLi9vYmplY3QuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByYW5nZSB9IGZyb20gJy4vcmFuZ2UuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjaHVuayB9IGZyb20gJy4vY2h1bmsuanMnO1xuXG4vLyBPT1Bcbi8vIC0tLVxuLy8gVGhlc2UgbW9kdWxlcyBzdXBwb3J0IHRoZSBcIm9iamVjdC1vcmllbnRlZFwiIGNhbGxpbmcgc3R5bGUuIFNlZSBhbHNvXG4vLyBgdW5kZXJzY29yZS5qc2AgYW5kIGBpbmRleC1kZWZhdWx0LmpzYC5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWl4aW4gfSBmcm9tICcuL21peGluLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL3VuZGVyc2NvcmUtYXJyYXktbWV0aG9kcy5qcyc7XG4iLCJpbXBvcnQgZ3JvdXAgZnJvbSAnLi9fZ3JvdXAuanMnO1xuXG4vLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYF8uZ3JvdXBCeWAsIGJ1dCBmb3Jcbi8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbmV4cG9ydCBkZWZhdWx0IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICByZXN1bHRba2V5XSA9IHZhbHVlO1xufSk7XG4iLCJpbXBvcnQgc29ydGVkSW5kZXggZnJvbSAnLi9zb3J0ZWRJbmRleC5qcyc7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gJy4vZmluZEluZGV4LmpzJztcbmltcG9ydCBjcmVhdGVJbmRleEZpbmRlciBmcm9tICcuL19jcmVhdGVJbmRleEZpbmRlci5qcyc7XG5cbi8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbi8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4vLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbi8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVJbmRleEZpbmRlcigxLCBmaW5kSW5kZXgsIHNvcnRlZEluZGV4KTtcbiIsImltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuXG4vLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbi8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4vLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbn1cbiIsImltcG9ydCBnZXRMZW5ndGggZnJvbSAnLi9fZ2V0TGVuZ3RoLmpzJztcbmltcG9ydCBjb250YWlucyBmcm9tICcuL2NvbnRhaW5zLmpzJztcblxuLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuLy8gcGFzc2VkLWluIGFycmF5cy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgaWYgKGNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgIHZhciBqO1xuICAgIGZvciAoaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICghY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW52ZXJ0KG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBfa2V5cyA9IGtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W29ialtfa2V5c1tpXV1dID0gX2tleXNbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCByZXN0QXJndW1lbnRzIGZyb20gJy4vcmVzdEFyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAuanMnO1xuaW1wb3J0IGRlZXBHZXQgZnJvbSAnLi9fZGVlcEdldC5qcyc7XG5cbi8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuZXhwb3J0IGRlZmF1bHQgcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIHBhdGgsIGFyZ3MpIHtcbiAgdmFyIGNvbnRleHRQYXRoLCBmdW5jO1xuICBpZiAoaXNGdW5jdGlvbihwYXRoKSkge1xuICAgIGZ1bmMgPSBwYXRoO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkocGF0aCkpIHtcbiAgICBjb250ZXh0UGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIG1hcChvYmosIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZnVuYztcbiAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgaWYgKGNvbnRleHRQYXRoICYmIGNvbnRleHRQYXRoLmxlbmd0aCkge1xuICAgICAgICBjb250ZXh0ID0gZGVlcEdldChjb250ZXh0LCBjb250ZXh0UGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgbWV0aG9kID0gY29udGV4dFtwYXRoXTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZCA9PSBudWxsID8gbWV0aG9kIDogbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9KTtcbn0pO1xuIiwiaW1wb3J0IHRhZ1Rlc3RlciBmcm9tICcuL190YWdUZXN0ZXIuanMnO1xuaW1wb3J0IGhhcyBmcm9tICcuL19oYXMuanMnO1xuXG52YXIgaXNBcmd1bWVudHMgPSB0YWdUZXN0ZXIoJ0FyZ3VtZW50cycpO1xuXG4vLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4vLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuKGZ1bmN0aW9uKCkge1xuICBpZiAoIWlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBpc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsImltcG9ydCB7IG5hdGl2ZUlzQXJyYXkgfSBmcm9tICcuL19zZXR1cC5qcyc7XG5pbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbi8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4vLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgYEFycmF5LmlzQXJyYXlgLlxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlSXNBcnJheSB8fCB0YWdUZXN0ZXIoJ0FycmF5Jyk7XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignQXJyYXlCdWZmZXInKTtcbiIsImltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuXG4vLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuIiwiaW1wb3J0IHRhZ1Rlc3RlciBmcm9tICcuL190YWdUZXN0ZXIuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB0YWdUZXN0ZXIoJ0RhdGFWaWV3Jyk7XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignRGF0ZScpO1xuIiwiLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICcuL2lzU3RyaW5nLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIC8vIFNraXAgdGhlIG1vcmUgZXhwZW5zaXZlIGB0b1N0cmluZ2AtYmFzZWQgdHlwZSBjaGVja3MgaWYgYG9iamAgaGFzIG5vXG4gIC8vIGAubGVuZ3RoYC5cbiAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKGlzQXJyYXkob2JqKSB8fCBpc1N0cmluZyhvYmopIHx8IGlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgcmV0dXJuIGtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG4iLCJpbXBvcnQgXyBmcm9tICcuL3VuZGVyc2NvcmUuanMnO1xuaW1wb3J0IHsgdG9TdHJpbmcsIFN5bWJvbFByb3RvIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuaW1wb3J0IGdldEJ5dGVMZW5ndGggZnJvbSAnLi9fZ2V0Qnl0ZUxlbmd0aC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuaW1wb3J0IGhhcyBmcm9tICcuL19oYXMuanMnO1xuXG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYF8uaXNFcXVhbGAuXG5mdW5jdGlvbiBlcShhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwczovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjtcbiAgLy8gRXhoYXVzdCBwcmltaXRpdmUgY2hlY2tzXG4gIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBkZWVwRXEoYSwgYiwgYVN0YWNrLCBiU3RhY2spO1xufVxuXG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYF8uaXNFcXVhbGAuXG5mdW5jdGlvbiBkZWVwRXEoYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgLy8gVGhlc2UgdHlwZXMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIGNhc2UgJ1tvYmplY3QgU3ltYm9sXSc6XG4gICAgICByZXR1cm4gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2xQcm90by52YWx1ZU9mLmNhbGwoYik7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nOlxuICAgICAgLy8gQ29lcmNlIHRvIGBEYXRhVmlld2Agc28gd2UgY2FuIGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLlxuICAgICAgcmV0dXJuIGRlZXBFcShuZXcgRGF0YVZpZXcoYSksIG5ldyBEYXRhVmlldyhiKSwgYVN0YWNrLCBiU3RhY2spO1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0YVZpZXddJzpcbiAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0Qnl0ZUxlbmd0aChhKTtcbiAgICAgIGlmIChieXRlTGVuZ3RoICE9PSBnZXRCeXRlTGVuZ3RoKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChieXRlTGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGEuZ2V0VWludDgoYnl0ZUxlbmd0aCkgIT09IGIuZ2V0VWludDgoYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzVHlwZWRBcnJheShhKSkge1xuICAgIC8vIENvZXJjZSB0eXBlZCBhcnJheXMgdG8gYERhdGFWaWV3YC5cbiAgICByZXR1cm4gZGVlcEVxKG5ldyBEYXRhVmlldyhhLmJ1ZmZlciksIG5ldyBEYXRhVmlldyhiLmJ1ZmZlciksIGFTdGFjaywgYlN0YWNrKTtcbiAgfVxuXG4gIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIGlmICghYXJlQXJyYXlzKSB7XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICB9XG5cbiAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBhU3RhY2sucHVzaChhKTtcbiAgYlN0YWNrLnB1c2goYik7XG5cbiAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gIGlmIChhcmVBcnJheXMpIHtcbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgdmFyIF9rZXlzID0ga2V5cyhhKSwga2V5O1xuICAgIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAga2V5ID0gX2tleXNbbGVuZ3RoXTtcbiAgICAgIGlmICghKGhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBhU3RhY2sucG9wKCk7XG4gIGJTdGFjay5wb3AoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBlcShhLCBiKTtcbn1cbiIsImltcG9ydCB0YWdUZXN0ZXIgZnJvbSAnLi9fdGFnVGVzdGVyLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgdGFnVGVzdGVyKCdFcnJvcicpO1xuIiwiaW1wb3J0IHsgX2lzRmluaXRlIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Zpbml0ZShvYmopIHtcbiAgcmV0dXJuICFpc1N5bWJvbChvYmopICYmIF9pc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xufVxuIiwiaW1wb3J0IHRhZ1Rlc3RlciBmcm9tICcuL190YWdUZXN0ZXIuanMnO1xuaW1wb3J0IHsgcm9vdCB9IGZyb20gJy4vX3NldHVwLmpzJztcblxudmFyIGlzRnVuY3Rpb24gPSB0YWdUZXN0ZXIoJ0Z1bmN0aW9uJyk7XG5cbi8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSBgdHlwZW9mYCBidWdzIGluIG9sZFxuLy8gdjgsIElFIDExICgjMTYyMSksIFNhZmFyaSA4ICgjMTkyOSksIGFuZCBQaGFudG9tSlMgKCMyMjM2KS5cbnZhciBub2RlbGlzdCA9IHJvb3QuZG9jdW1lbnQgJiYgcm9vdC5kb2N1bWVudC5jaGlsZE5vZGVzO1xuaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnICYmIHR5cGVvZiBub2RlbGlzdCAhPSAnZnVuY3Rpb24nKSB7XG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHRhZ1Rlc3RlciBmcm9tICcuL190YWdUZXN0ZXIuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB0YWdUZXN0ZXIoJ01hcCcpO1xuIiwiaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgYXR0cnMpIHtcbiAgdmFyIF9rZXlzID0ga2V5cyhhdHRycyksIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IF9rZXlzW2ldO1xuICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgeyBfaXNOYU4gfSBmcm9tICcuL19zZXR1cC5qcyc7XG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnLi9pc051bWJlci5qcyc7XG5cbi8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTmFOKG9iaikge1xuICByZXR1cm4gaXNOdW1iZXIob2JqKSAmJiBfaXNOYU4ob2JqKTtcbn1cbiIsIi8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbn1cbiIsImltcG9ydCB0YWdUZXN0ZXIgZnJvbSAnLi9fdGFnVGVzdGVyLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgdGFnVGVzdGVyKCdOdW1iZXInKTtcbiIsIi8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG59XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignUmVnRXhwJyk7XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignU2V0Jyk7XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignU3RyaW5nJyk7XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignU3ltYm9sJyk7XG4iLCJpbXBvcnQgeyBzdXBwb3J0c0FycmF5QnVmZmVyLCBuYXRpdmVJc1ZpZXcsIHRvU3RyaW5nIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuaW1wb3J0IGlzRGF0YVZpZXcgZnJvbSAnLi9pc0RhdGFWaWV3LmpzJztcbmltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBpc0J1ZmZlckxpa2UgZnJvbSAnLi9faXNCdWZmZXJMaWtlLmpzJztcblxuLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIHR5cGVkIGFycmF5P1xudmFyIHR5cGVkQXJyYXlQYXR0ZXJuID0gL1xcW29iamVjdCAoKEl8VWkpbnQoOHwxNnwzMil8RmxvYXQoMzJ8NjQpfFVpbnQ4Q2xhbXBlZHxCaWcoSXxVaSludDY0KUFycmF5XFxdLztcbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShvYmopIHtcbiAgLy8gYEFycmF5QnVmZmVyLmlzVmlld2AgaXMgdGhlIG1vc3QgZnV0dXJlLXByb29mLCBzbyB1c2UgaXQgd2hlbiBhdmFpbGFibGUuXG4gIC8vIE90aGVyd2lzZSwgZmFsbCBiYWNrIG9uIHRoZSBhYm92ZSByZWd1bGFyIGV4cHJlc3Npb24uXG4gIHJldHVybiBuYXRpdmVJc1ZpZXcgPyAobmF0aXZlSXNWaWV3KG9iaikgJiYgIWlzRGF0YVZpZXcob2JqKSkgOlxuICAgICAgICAgICAgICAgIGlzQnVmZmVyTGlrZShvYmopICYmIHR5cGVkQXJyYXlQYXR0ZXJuLnRlc3QodG9TdHJpbmcuY2FsbChvYmopKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3VwcG9ydHNBcnJheUJ1ZmZlciA/IGlzVHlwZWRBcnJheSA6IGNvbnN0YW50KGZhbHNlKTtcbiIsIi8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMDtcbn1cbiIsImltcG9ydCB0YWdUZXN0ZXIgZnJvbSAnLi9fdGFnVGVzdGVyLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgdGFnVGVzdGVyKCdXZWFrTWFwJyk7XG4iLCJpbXBvcnQgdGFnVGVzdGVyIGZyb20gJy4vX3RhZ1Rlc3Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHRhZ1Rlc3RlcignV2Vha1NldCcpO1xuIiwiaW1wb3J0IF8gZnJvbSAnLi91bmRlcnNjb3JlLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcblxuLy8gRXh0ZXJuYWwgd3JhcHBlciBmb3Igb3VyIGNhbGxiYWNrIGdlbmVyYXRvci4gVXNlcnMgbWF5IGN1c3RvbWl6ZVxuLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuLy8gVGhpcyBhYnN0cmFjdGlvbiBoaWRlcyB0aGUgaW50ZXJuYWwtb25seSBgYXJnQ291bnRgIGFyZ3VtZW50LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXRlcmF0ZWUodmFsdWUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xufVxuXy5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHsgbmF0aXZlS2V5cywgaGFzRW51bUJ1ZyB9IGZyb20gJy4vX3NldHVwLmpzJztcbmltcG9ydCBoYXMgZnJvbSAnLi9faGFzLmpzJztcbmltcG9ydCBjb2xsZWN0Tm9uRW51bVByb3BzIGZyb20gJy4vX2NvbGxlY3ROb25FbnVtUHJvcHMuanMnO1xuXG4vLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4vLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gW107XG4gIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIC8vIEFoZW0sIElFIDwgOS5cbiAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgcmV0dXJuIGtleXM7XG59XG4iLCJpbXBvcnQgcmVzdCBmcm9tICcuL3Jlc3QuanMnO1xuXG4vLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4vLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFzdChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCB8fCBndWFyZCA/IHZvaWQgMCA6IFtdO1xuICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gIHJldHVybiByZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG59XG4iLCJpbXBvcnQgZmluZExhc3RJbmRleCBmcm9tICcuL2ZpbmRMYXN0SW5kZXguanMnO1xuaW1wb3J0IGNyZWF0ZUluZGV4RmluZGVyIGZyb20gJy4vX2NyZWF0ZUluZGV4RmluZGVyLmpzJztcblxuLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4vLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSW5kZXhGaW5kZXIoLTEsIGZpbmRMYXN0SW5kZXgpO1xuIiwiaW1wb3J0IGNiIGZyb20gJy4vX2NiLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1hcChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB2YXIgX2tleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBrZXlzKG9iaiksXG4gICAgICBsZW5ndGggPSAoX2tleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsImltcG9ydCBjYiBmcm9tICcuL19jYi5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggZWxlbWVudCBvZiBgb2JqYC5cbi8vIEluIGNvbnRyYXN0IHRvIGBfLm1hcGAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXBPYmplY3Qob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgdmFyIF9rZXlzID0ga2V5cyhvYmopLFxuICAgICAgbGVuZ3RoID0gX2tleXMubGVuZ3RoLFxuICAgICAgcmVzdWx0cyA9IHt9O1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5c1tpbmRleF07XG4gICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsImltcG9ydCBleHRlbmRPd24gZnJvbSAnLi9leHRlbmRPd24uanMnO1xuaW1wb3J0IGlzTWF0Y2ggZnJvbSAnLi9pc01hdGNoLmpzJztcblxuLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4vLyBga2V5OnZhbHVlYCBwYWlycy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1hdGNoZXIoYXR0cnMpIHtcbiAgYXR0cnMgPSBleHRlbmRPd24oe30sIGF0dHJzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc01hdGNoKG9iaiwgYXR0cnMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vX2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMuanMnO1xuaW1wb3J0IGNiIGZyb20gJy4vX2NiLmpzJztcbmltcG9ydCBlYWNoIGZyb20gJy4vZWFjaC5qcyc7XG5cbi8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogdmFsdWVzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgaGFzIGZyb20gJy4vX2hhcy5qcyc7XG5cbi8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIGhhc2hlcikge1xuICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgaWYgKCFoYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gIH07XG4gIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgcmV0dXJuIG1lbW9pemU7XG59XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICcuL3ZhbHVlcy5qcyc7XG5pbXBvcnQgY2IgZnJvbSAnLi9fY2IuanMnO1xuaW1wb3J0IGVhY2ggZnJvbSAnLi9lYWNoLmpzJztcblxuLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogdmFsdWVzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IF8gZnJvbSAnLi91bmRlcnNjb3JlLmpzJztcbmltcG9ydCBlYWNoIGZyb20gJy4vZWFjaC5qcyc7XG5pbXBvcnQgZnVuY3Rpb25zIGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7IHB1c2ggfSBmcm9tICcuL19zZXR1cC5qcyc7XG5pbXBvcnQgY2hhaW5SZXN1bHQgZnJvbSAnLi9fY2hhaW5SZXN1bHQuanMnO1xuXG4vLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZWFjaChmdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBfO1xufVxuIiwiLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbi4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vb3AoKXt9XG4iLCIvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG5leHBvcnQgZGVmYXVsdCBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcbiIsImltcG9ydCBnZXRMZW5ndGggIGZyb20gJy4vX2dldExlbmd0aC5qcyc7XG5cbi8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbi8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBQYXNzaW5nIGJ5IHBhaXJzIGlzIHRoZSByZXZlcnNlIG9mIGBfLnBhaXJzYC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9iamVjdChsaXN0LCB2YWx1ZXMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgcmVzdEFyZ3VtZW50cyBmcm9tICcuL3Jlc3RBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBuZWdhdGUgZnJvbSAnLi9uZWdhdGUuanMnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcC5qcyc7XG5pbXBvcnQgZmxhdHRlbiBmcm9tICcuL19mbGF0dGVuLmpzJztcbmltcG9ydCBjb250YWlucyBmcm9tICcuL2NvbnRhaW5zLmpzJztcbmltcG9ydCBwaWNrIGZyb20gJy4vcGljay5qcyc7XG5cbi8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBkaXNhbGxvd2VkIHByb3BlcnRpZXMuXG5leHBvcnQgZGVmYXVsdCByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICB2YXIgaXRlcmF0ZWUgPSBrZXlzWzBdLCBjb250ZXh0O1xuICBpZiAoaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICBpdGVyYXRlZSA9IG5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgaWYgKGtleXMubGVuZ3RoID4gMSkgY29udGV4dCA9IGtleXNbMV07XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IG1hcChmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSksIFN0cmluZyk7XG4gICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gIWNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbn0pO1xuIiwiaW1wb3J0IHBhcnRpYWwgZnJvbSAnLi9wYXJ0aWFsLmpzJztcbmltcG9ydCBiZWZvcmUgZnJvbSAnLi9iZWZvcmUuanMnO1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbi8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG5leHBvcnQgZGVmYXVsdCBwYXJ0aWFsKGJlZm9yZSwgMik7XG4iLCJpbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbi8vIFRoZSBvcHBvc2l0ZSBvZiBgXy5vYmplY3RgIHdpdGggb25lIGFyZ3VtZW50LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFpcnMob2JqKSB7XG4gIHZhciBfa2V5cyA9IGtleXMob2JqKTtcbiAgdmFyIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHBhaXJzW2ldID0gW19rZXlzW2ldLCBvYmpbX2tleXNbaV1dXTtcbiAgfVxuICByZXR1cm4gcGFpcnM7XG59XG4iLCJpbXBvcnQgcmVzdEFyZ3VtZW50cyBmcm9tICcuL3Jlc3RBcmd1bWVudHMuanMnO1xuaW1wb3J0IGV4ZWN1dGVCb3VuZCBmcm9tICcuL19leGVjdXRlQm91bmQuanMnO1xuaW1wb3J0IF8gZnJvbSAnLi91bmRlcnNjb3JlLmpzJztcblxuLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIGBfYCBhY3RzXG4vLyBhcyBhIHBsYWNlaG9sZGVyIGJ5IGRlZmF1bHQsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmVcbi8vIHByZS1maWxsZWQuIFNldCBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCBmb3IgYSBjdXN0b20gcGxhY2Vob2xkZXIgYXJndW1lbnQuXG52YXIgcGFydGlhbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgYm91bmRBcmdzKSB7XG4gIHZhciBwbGFjZWhvbGRlciA9IHBhcnRpYWwucGxhY2Vob2xkZXI7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IHBsYWNlaG9sZGVyID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgIH1cbiAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgfTtcbiAgcmV0dXJuIGJvdW5kO1xufSk7XG5cbnBhcnRpYWwucGxhY2Vob2xkZXIgPSBfO1xuZXhwb3J0IGRlZmF1bHQgcGFydGlhbDtcbiIsImltcG9ydCBncm91cCBmcm9tICcuL19ncm91cC5qcyc7XG5cbi8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgcGFzcyB0aGUgZ2l2ZW5cbi8vIHRydXRoIHRlc3QsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBwYXNzIHRoZSB0cnV0aCB0ZXN0LlxuZXhwb3J0IGRlZmF1bHQgZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgcGFzcykge1xuICByZXN1bHRbcGFzcyA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbn0sIHRydWUpO1xuIiwiaW1wb3J0IHJlc3RBcmd1bWVudHMgZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgb3B0aW1pemVDYiBmcm9tICcuL19vcHRpbWl6ZUNiLmpzJztcbmltcG9ydCBhbGxLZXlzIGZyb20gJy4vYWxsS2V5cy5qcyc7XG5pbXBvcnQga2V5SW5PYmogZnJvbSAnLi9fa2V5SW5PYmouanMnO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSAnLi9fZmxhdHRlbi5qcyc7XG5cbi8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIGFsbG93ZWQgcHJvcGVydGllcy5cbmV4cG9ydCBkZWZhdWx0IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gIHZhciByZXN1bHQgPSB7fSwgaXRlcmF0ZWUgPSBrZXlzWzBdO1xuICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gIGlmIChpc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwga2V5c1sxXSk7XG4gICAga2V5cyA9IGFsbEtleXMob2JqKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyYXRlZSA9IGtleUluT2JqO1xuICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgb2JqID0gT2JqZWN0KG9iaik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJpbXBvcnQgbWFwIGZyb20gJy4vbWFwLmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgXy5tYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGx1Y2sob2JqLCBrZXkpIHtcbiAgcmV0dXJuIG1hcChvYmosIHByb3BlcnR5KGtleSkpO1xufVxuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBzaGFsbG93UHJvcGVydHkgZnJvbSAnLi9fc2hhbGxvd1Byb3BlcnR5LmpzJztcbmltcG9ydCBkZWVwR2V0IGZyb20gJy4vX2RlZXBHZXQuanMnO1xuXG4vLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwYXNzZWQgYW4gb2JqZWN0LCB3aWxsIHRyYXZlcnNlIHRoYXQgb2JqZWN04oCZc1xuLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGljZXMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIGlmICghaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBzaGFsbG93UHJvcGVydHkocGF0aCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gIH07XG59XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGRlZXBHZXQgZnJvbSAnLi9fZGVlcEdldC5qcyc7XG5cbi8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpe307XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gIWlzQXJyYXkocGF0aCkgPyBvYmpbcGF0aF0gOiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gIH07XG59XG4iLCIvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbn1cbiIsIi8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2Zcbi8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4vLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmIChzdG9wID09IG51bGwpIHtcbiAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKCFzdGVwKSB7XG4gICAgc3RlcCA9IHN0b3AgPCBzdGFydCA/IC0xIDogMTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn1cbiIsImltcG9ydCBjcmVhdGVSZWR1Y2UgZnJvbSAnLi9fY3JlYXRlUmVkdWNlLmpzJztcblxuLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuLy8gb3IgYGZvbGRsYC5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVJlZHVjZSgxKTtcbiIsImltcG9ydCBjcmVhdGVSZWR1Y2UgZnJvbSAnLi9fY3JlYXRlUmVkdWNlLmpzJztcblxuLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSZWR1Y2UoLTEpO1xuIiwiaW1wb3J0IGZpbHRlciBmcm9tICcuL2ZpbHRlci5qcyc7XG5pbXBvcnQgbmVnYXRlIGZyb20gJy4vbmVnYXRlLmpzJztcbmltcG9ydCBjYiBmcm9tICcuL19jYi5qcyc7XG5cbi8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWplY3Qob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZpbHRlcihvYmosIG5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vX3NldHVwLmpzJztcblxuLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGBhcnJheWAuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4vLyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZVxuLy8gYGFycmF5YC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG59XG4iLCIvLyBTb21lIGZ1bmN0aW9ucyB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBmZXcgZXhwZWN0ZWRcbi8vIGFyZ3VtZW50cyBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIHZhbHVlcyB0byBvcGVyYXRlXG4vLyBvbi4gVGhpcyBoZWxwZXIgYWNjdW11bGF0ZXMgYWxsIHJlbWFpbmluZyBhcmd1bWVudHMgcGFzdCB0aGUgZnVuY3Rpb27igJlzXG4vLyBhcmd1bWVudCBsZW5ndGggKG9yIGFuIGV4cGxpY2l0IGBzdGFydEluZGV4YCksIGludG8gYW4gYXJyYXkgdGhhdCBiZWNvbWVzXG4vLyB0aGUgbGFzdCBhcmd1bWVudC4gU2ltaWxhciB0byBFUzbigJlzIFwicmVzdCBwYXJhbWV0ZXJcIi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc3RBcmd1bWVudHMoZnVuYywgc3RhcnRJbmRleCkge1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXJndW1lbnRzLmxlbmd0aCAtIHN0YXJ0SW5kZXgsIDApLFxuICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydEluZGV4KSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCByZXN0KTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgcmVzdCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gQXJyYXkoc3RhcnRJbmRleCArIDEpO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgYXJnc1tzdGFydEluZGV4XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcblxuLy8gVHJhdmVyc2VzIHRoZSBjaGlsZHJlbiBvZiBgb2JqYCBhbG9uZyBgcGF0aGAuIElmIGEgY2hpbGQgaXMgYSBmdW5jdGlvbiwgaXRcbi8vIGlzIGludm9rZWQgd2l0aCBpdHMgcGFyZW50IGFzIGNvbnRleHQuIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbFxuLy8gY2hpbGQsIG9yIGBmYWxsYmFja2AgaWYgYW55IGNoaWxkIGlzIHVuZGVmaW5lZC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc3VsdChvYmosIHBhdGgsIGZhbGxiYWNrKSB7XG4gIGlmICghaXNBcnJheShwYXRoKSkgcGF0aCA9IFtwYXRoXTtcbiAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrLmNhbGwob2JqKSA6IGZhbGxiYWNrO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW3BhdGhbaV1dO1xuICAgIGlmIChwcm9wID09PSB2b2lkIDApIHtcbiAgICAgIHByb3AgPSBmYWxsYmFjaztcbiAgICAgIGkgPSBsZW5ndGg7IC8vIEVuc3VyZSB3ZSBkb24ndCBjb250aW51ZSBpdGVyYXRpbmcuXG4gICAgfVxuICAgIG9iaiA9IGlzRnVuY3Rpb24ocHJvcCkgPyBwcm9wLmNhbGwob2JqKSA6IHByb3A7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbiIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgY2xvbmUgZnJvbSAnLi9jbG9uZS5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcbmltcG9ydCBnZXRMZW5ndGggZnJvbSAnLi9fZ2V0TGVuZ3RoLmpzJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi9yYW5kb20uanMnO1xuXG4vLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbiB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4vLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbi8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNhbXBsZShvYmosIG4sIGd1YXJkKSB7XG4gIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IHZhbHVlcyhvYmopO1xuICAgIHJldHVybiBvYmpbcmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gIH1cbiAgdmFyIHNhbXBsZSA9IGlzQXJyYXlMaWtlKG9iaikgPyBjbG9uZShvYmopIDogdmFsdWVzKG9iaik7XG4gIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgbiA9IE1hdGgubWF4KE1hdGgubWluKG4sIGxlbmd0aCksIDApO1xuICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgdmFyIHJhbmQgPSByYW5kb20oaW5kZXgsIGxhc3QpO1xuICAgIHZhciB0ZW1wID0gc2FtcGxlW2luZGV4XTtcbiAgICBzYW1wbGVbaW5kZXhdID0gc2FtcGxlW3JhbmRdO1xuICAgIHNhbXBsZVtyYW5kXSA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIHNhbXBsZS5zbGljZSgwLCBuKTtcbn1cbiIsImltcG9ydCBzYW1wbGUgZnJvbSAnLi9zYW1wbGUuanMnO1xuXG4vLyBTaHVmZmxlIGEgY29sbGVjdGlvbi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNodWZmbGUob2JqKSB7XG4gIHJldHVybiBzYW1wbGUob2JqLCBJbmZpbml0eSk7XG59XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBjb2xsZWN0aW9uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2l6ZShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDoga2V5cyhvYmopLmxlbmd0aDtcbn1cbiIsImltcG9ydCBjYiBmcm9tICcuL19jYi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgcGFzc2VzIGEgdHJ1dGggdGVzdC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvbWUob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgdmFyIF9rZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYga2V5cyhvYmopLFxuICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgY2IgZnJvbSAnLi9fY2IuanMnO1xuaW1wb3J0IHBsdWNrIGZyb20gJy4vcGx1Y2suanMnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcC5qcyc7XG5cbi8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnRCeShvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICByZXR1cm4gcGx1Y2sobWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBpbmRleDogaW5kZXgrKyxcbiAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBsaXN0KVxuICAgIH07XG4gIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gIH0pLCAndmFsdWUnKTtcbn1cbiIsImltcG9ydCBjYiBmcm9tICcuL19jYi5qcyc7XG5pbXBvcnQgZ2V0TGVuZ3RoIGZyb20gJy4vX2dldExlbmd0aC5qcyc7XG5cbi8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbi8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG93O1xufVxuIiwiLy8gSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGBvYmpgIGFuZCB0aGVuIHJldHVybnMgYG9iamAuXG4vLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbi8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGFwKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgcmV0dXJuIG9iajtcbn1cbiIsImltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzLmpzJztcbmltcG9ydCBfIGZyb20gJy4vdW5kZXJzY29yZS5qcyc7XG5pbXBvcnQgJy4vdGVtcGxhdGVTZXR0aW5ncy5qcyc7XG5cbi8vIFdoZW4gY3VzdG9taXppbmcgYF8udGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG52YXIgbm9NYXRjaCA9IC8oLileLztcblxuLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbi8vIHN0cmluZyBsaXRlcmFsLlxudmFyIGVzY2FwZXMgPSB7XG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gICdcXHInOiAncicsXG4gICdcXG4nOiAnbicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG52YXIgZXNjYXBlUmVnRXhwID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVDaGFyKG1hdGNoKSB7XG4gIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbn1cblxuLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbi8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbi8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gIHNldHRpbmdzID0gZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVSZWdFeHAsIGVzY2FwZUNoYXIpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgaWYgKGVzY2FwZSkge1xuICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgIH1cblxuICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZnNldC5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICB2YXIgcmVuZGVyO1xuICB0cnkge1xuICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuIiwiaW1wb3J0IF8gZnJvbSAnLi91bmRlcnNjb3JlLmpzJztcblxuLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiBDaGFuZ2UgdGhlXG4vLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG5leHBvcnQgZGVmYXVsdCBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gIGVzY2FwZTogLzwlLShbXFxzXFxTXSs/KSU+L2dcbn07XG4iLCJpbXBvcnQgbm93IGZyb20gJy4vbm93LmpzJztcblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4vLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbi8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbi8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4vLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5vdygpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfbm93ID0gbm93KCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IF9ub3c7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAoX25vdyAtIHByZXZpb3VzKTtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBfbm93O1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgcHJldmlvdXMgPSAwO1xuICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cbiIsImltcG9ydCBvcHRpbWl6ZUNiIGZyb20gJy4vX29wdGltaXplQ2IuanMnO1xuXG4vLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gIHJldHVybiBhY2N1bTtcbn1cbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vX3NldHVwLmpzJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICcuL2lzU3RyaW5nLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwLmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMuanMnO1xuXG4vLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxudmFyIHJlU3RyU3ltYm9sID0gL1teXFx1ZDgwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRmZmZdL2c7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICBpZiAoaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgIC8vIEtlZXAgc3Vycm9nYXRlIHBhaXIgY2hhcmFjdGVycyB0b2dldGhlci5cbiAgICByZXR1cm4gb2JqLm1hdGNoKHJlU3RyU3ltYm9sKTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIG1hcChvYmosIGlkZW50aXR5KTtcbiAgcmV0dXJuIHZhbHVlcyhvYmopO1xufVxuIiwiaW1wb3J0IF8gZnJvbSAnLi91bmRlcnNjb3JlLmpzJztcbmltcG9ydCBlYWNoIGZyb20gJy4vZWFjaC5qcyc7XG5pbXBvcnQgeyBBcnJheVByb3RvIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuaW1wb3J0IGNoYWluUmVzdWx0IGZyb20gJy4vX2NoYWluUmVzdWx0LmpzJztcblxuLy8gQWRkIGFsbCBtdXRhdG9yIGBBcnJheWAgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgb2JqWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgfTtcbn0pO1xuXG4vLyBBZGQgYWxsIGFjY2Vzc29yIGBBcnJheWAgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgaWYgKG9iaiAhPSBudWxsKSBvYmogPSBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBvYmopO1xuICB9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF87XG4iLCJpbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi9fc2V0dXAuanMnO1xuXG4vLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdCBjYW5cbi8vIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCBmdW5jdGlvbnMgYWRkZWRcbi8vIHRocm91Z2ggYF8ubWl4aW5gLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfKG9iaikge1xuICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbn1cblxuXy5WRVJTSU9OID0gVkVSU0lPTjtcblxuLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG5fLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbn07XG5cbi8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94aWVzIGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbl8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFN0cmluZyh0aGlzLl93cmFwcGVkKTtcbn07XG4iLCJpbXBvcnQgY3JlYXRlRXNjYXBlciBmcm9tICcuL19jcmVhdGVFc2NhcGVyLmpzJztcbmltcG9ydCB1bmVzY2FwZU1hcCBmcm9tICcuL191bmVzY2FwZU1hcC5qcyc7XG5cbi8vIEZ1bmN0aW9uIGZvciB1bmVzY2FwaW5nIHN0cmluZ3MgZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcbiIsImltcG9ydCByZXN0QXJndW1lbnRzIGZyb20gJy4vcmVzdEFyZ3VtZW50cy5qcyc7XG5pbXBvcnQgdW5pcSBmcm9tICcuL3VuaXEuanMnO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSAnLi9fZmxhdHRlbi5qcyc7XG5cbi8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG5leHBvcnQgZGVmYXVsdCByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gdW5pcShmbGF0dGVuKGFycmF5cywgdHJ1ZSwgdHJ1ZSkpO1xufSk7XG4iLCJpbXBvcnQgaXNCb29sZWFuIGZyb20gJy4vaXNCb29sZWFuLmpzJztcbmltcG9ydCBjYiBmcm9tICcuL19jYi5qcyc7XG5pbXBvcnQgZ2V0TGVuZ3RoIGZyb20gJy4vX2dldExlbmd0aC5qcyc7XG5pbXBvcnQgY29udGFpbnMgZnJvbSAnLi9jb250YWlucy5qcyc7XG5cbi8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4vLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4vLyBUaGUgZmFzdGVyIGFsZ29yaXRobSB3aWxsIG5vdCB3b3JrIHdpdGggYW4gaXRlcmF0ZWUgaWYgdGhlIGl0ZXJhdGVlXG4vLyBpcyBub3QgYSBvbmUtdG8tb25lIGZ1bmN0aW9uLCBzbyBwcm92aWRpbmcgYW4gaXRlcmF0ZWUgd2lsbCBkaXNhYmxlXG4vLyB0aGUgZmFzdGVyIGFsZ29yaXRobS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICBpZiAoIWlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICB9XG4gIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgc2VlbiA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgaWYgKGlzU29ydGVkICYmICFpdGVyYXRlZSkge1xuICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgaWYgKCFjb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCIvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbnZhciBpZENvdW50ZXIgPSAwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xufVxuIiwiaW1wb3J0IG1heCBmcm9tICcuL21heC5qcyc7XG5pbXBvcnQgZ2V0TGVuZ3RoIGZyb20gJy4vX2dldExlbmd0aC5qcyc7XG5pbXBvcnQgcGx1Y2sgZnJvbSAnLi9wbHVjay5qcyc7XG5cbi8vIENvbXBsZW1lbnQgb2YgemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4vLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgbWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFycmF5LCBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuZ3RoID0gX2tleXMubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhbHVlc1tpXSA9IG9ialtfa2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cbiIsImltcG9ydCBmaWx0ZXIgZnJvbSAnLi9maWx0ZXIuanMnO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSAnLi9tYXRjaGVyLmpzJztcblxuLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgXy5maWx0ZXJgOiBzZWxlY3Rpbmcgb25seVxuLy8gb2JqZWN0cyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2hlcmUob2JqLCBhdHRycykge1xuICByZXR1cm4gZmlsdGVyKG9iaiwgbWF0Y2hlcihhdHRycykpO1xufVxuIiwiaW1wb3J0IHJlc3RBcmd1bWVudHMgZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcbmltcG9ydCBkaWZmZXJlbmNlIGZyb20gJy4vZGlmZmVyZW5jZS5qcyc7XG5cbi8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuZXhwb3J0IGRlZmF1bHQgcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgb3RoZXJBcnJheXMpIHtcbiAgcmV0dXJuIGRpZmZlcmVuY2UoYXJyYXksIG90aGVyQXJyYXlzKTtcbn0pO1xuIiwiaW1wb3J0IHBhcnRpYWwgZnJvbSAnLi9wYXJ0aWFsLmpzJztcblxuLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4vLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4vLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd3JhcChmdW5jLCB3cmFwcGVyKSB7XG4gIHJldHVybiBwYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xufVxuIiwiaW1wb3J0IHJlc3RBcmd1bWVudHMgZnJvbSAnLi9yZXN0QXJndW1lbnRzLmpzJztcbmltcG9ydCB1bnppcCBmcm9tICcuL3VuemlwLmpzJztcblxuLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG5leHBvcnQgZGVmYXVsdCByZXN0QXJndW1lbnRzKHVuemlwKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCIvKlxuICogalF1ZXJ5IElmcmFtZSBUcmFuc3BvcnQgUGx1Z2luIDEuN1xuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvalF1ZXJ5LUZpbGUtVXBsb2FkXG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qanNsaW50IHVucGFyYW06IHRydWUsIG5vbWVuOiB0cnVlICovXG4vKmdsb2JhbCBkZWZpbmUsIHdpbmRvdywgZG9jdW1lbnQgKi9cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIEhlbHBlciB2YXJpYWJsZSB0byBjcmVhdGUgdW5pcXVlIG5hbWVzIGZvciB0aGUgdHJhbnNwb3J0IGlmcmFtZXM6XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgLy8gVGhlIGlmcmFtZSB0cmFuc3BvcnQgYWNjZXB0cyB0aHJlZSBhZGRpdGlvbmFsIG9wdGlvbnM6XG4gICAgLy8gb3B0aW9ucy5maWxlSW5wdXQ6IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgZmlsZSBpbnB1dCBmaWVsZHNcbiAgICAvLyBvcHRpb25zLnBhcmFtTmFtZTogdGhlIHBhcmFtZXRlciBuYW1lIGZvciB0aGUgZmlsZSBmb3JtIGRhdGEsXG4gICAgLy8gIG92ZXJyaWRlcyB0aGUgbmFtZSBwcm9wZXJ0eSBvZiB0aGUgZmlsZSBpbnB1dCBmaWVsZChzKSxcbiAgICAvLyAgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgLy8gb3B0aW9ucy5mb3JtRGF0YTogYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIG5hbWUgYW5kIHZhbHVlIHByb3BlcnRpZXMsXG4gICAgLy8gIGVxdWl2YWxlbnQgdG8gdGhlIHJldHVybiBkYXRhIG9mIC5zZXJpYWxpemVBcnJheSgpLCBlLmcuOlxuICAgIC8vICBbe25hbWU6ICdhJywgdmFsdWU6IDF9LCB7bmFtZTogJ2InLCB2YWx1ZTogMn1dXG4gICAgJC5hamF4VHJhbnNwb3J0KCdpZnJhbWUnLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3luYykge1xuICAgICAgICAgICAgdmFyIGZvcm0sXG4gICAgICAgICAgICAgICAgaWZyYW1lLFxuICAgICAgICAgICAgICAgIGFkZFBhcmFtQ2hhcjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybSA9ICQoJzxmb3JtIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvZm9ybT4nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hdHRyKCdhY2NlcHQtY2hhcnNldCcsIG9wdGlvbnMuZm9ybUFjY2VwdENoYXJzZXQpO1xuICAgICAgICAgICAgICAgICAgICBhZGRQYXJhbUNoYXIgPSAvXFw/Ly50ZXN0KG9wdGlvbnMudXJsKSA/ICcmJyA6ICc/JztcbiAgICAgICAgICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3Qgb25seSBzdXBwb3J0cyBHRVQgYW5kIFBPU1Q6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgYWRkUGFyYW1DaGFyICsgJ19tZXRob2Q9REVMRVRFJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdQVVQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgYWRkUGFyYW1DaGFyICsgJ19tZXRob2Q9UFVUJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdQQVRDSCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBhZGRQYXJhbUNoYXIgKyAnX21ldGhvZD1QQVRDSCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gamF2YXNjcmlwdDpmYWxzZSBhcyBpbml0aWFsIGlmcmFtZSBzcmNcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudHMgd2FybmluZyBwb3B1cHMgb24gSFRUUFMgaW4gSUU2LlxuICAgICAgICAgICAgICAgICAgICAvLyBJRSB2ZXJzaW9ucyBiZWxvdyBJRTggY2Fubm90IHNldCB0aGUgbmFtZSBwcm9wZXJ0eSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBET00sXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIHNldCB0aGUgbmFtZSBhbG9uZyB3aXRoIHRoZSBpZnJhbWUgSFRNTCBtYXJrdXA6XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lID0gJChcbiAgICAgICAgICAgICAgICAgICAgICAgICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6ZmFsc2U7XCIgbmFtZT1cImlmcmFtZS10cmFuc3BvcnQtJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlciArICdcIj48L2lmcmFtZT4nXG4gICAgICAgICAgICAgICAgICAgICkuYmluZCgnbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlSW5wdXRDbG9uZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lcyA9ICQuaXNBcnJheShvcHRpb25zLnBhcmFtTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWUgOiBbb3B0aW9ucy5wYXJhbU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVuYmluZCgnbG9hZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmJpbmQoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCBpbiBhIHRyeS9jYXRjaCBibG9jayB0byBjYXRjaCBleGNlcHRpb25zIHRocm93blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBhY2Nlc3MgY3Jvc3MtZG9tYWluIGlmcmFtZSBjb250ZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gaWZyYW1lLmNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lIGFuZCBGaXJlZm94IGRvIG5vdCB0aHJvdyBhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHdoZW4gY2FsbGluZyBpZnJhbWUuY29udGVudHMoKSBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzbyB3ZSB1bmlmeSB0aGUgcmVzcG9uc2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmxlbmd0aCB8fCAhcmVzcG9uc2VbMF0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29tcGxldGUgY2FsbGJhY2sgcmV0dXJucyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWZyYW1lIGNvbnRlbnQgZG9jdW1lbnQgYXMgcmVzcG9uc2Ugb2JqZWN0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeydpZnJhbWUnOiByZXNwb25zZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGZvciBJRSBlbmRsZXNzIHByb2dyZXNzIGJhciBhY3Rpdml0eSBidWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGhhcHBlbnMgb24gZm9ybSBzdWJtaXRzIHRvIGlmcmFtZSB0YXJnZXRzKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OmZhbHNlO1wiPjwvaWZyYW1lPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoZSBmb3JtIGluIGEgc2V0VGltZW91dCBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd3MgQ2hyb21lJ3MgZGV2ZWxvcGVyIHRvb2xzIHRvIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCd0YXJnZXQnLCBpZnJhbWUucHJvcCgnbmFtZScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdhY3Rpb24nLCBvcHRpb25zLnVybClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnbWV0aG9kJywgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG9wdGlvbnMuZm9ybURhdGEsIGZ1bmN0aW9uIChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIi8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCduYW1lJywgZmllbGQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWwoZmllbGQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWxlSW5wdXQgJiYgb3B0aW9ucy5maWxlSW5wdXQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUlucHV0Q2xvbmVzID0gb3B0aW9ucy5maWxlSW5wdXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYSBjbG9uZSBmb3IgZWFjaCBmaWxlIGlucHV0IGZpZWxkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0LmFmdGVyKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUlucHV0Q2xvbmVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWxlSW5wdXQuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucHJvcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lc1tpbmRleF0gfHwgb3B0aW9ucy5wYXJhbU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmRpbmcgdGhlIGZpbGUgaW5wdXQgZmllbGRzIHRvIHRoZSBoaWRkZW4gZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlbSBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChvcHRpb25zLmZpbGVJbnB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2VuY3R5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY3R5cGUgbXVzdCBiZSBzZXQgYXMgZW5jb2RpbmcgZm9yIElFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnZW5jb2RpbmcnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgZmlsZSBpbnB1dCBmaWVsZHMgYXQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHJlcGxhY2luZyB0aGUgY2xvbmVzIHdpdGggdGhlIG9yaWdpbmFsczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlSW5wdXRDbG9uZXMgJiYgZmlsZUlucHV0Q2xvbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0LmVhY2goZnVuY3Rpb24gKGluZGV4LCBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSAkKGZpbGVJbnB1dENsb25lc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGlucHV0KS5wcm9wKCduYW1lJywgY2xvbmUucHJvcCgnbmFtZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUucmVwbGFjZVdpdGgoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoaWZyYW1lKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGphdmFzY3JpcHQ6ZmFsc2UgYXMgaWZyYW1lIHNyYyBhYm9ydHMgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcmV2ZW50cyB3YXJuaW5nIHBvcHVwcyBvbiBIVFRQUyBpbiBJRTYuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25jYXQgaXMgdXNlZCB0byBhdm9pZCB0aGUgXCJTY3JpcHQgVVJMXCIgSlNMaW50IGVycm9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVuYmluZCgnbG9hZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ3NyYycsICdqYXZhc2NyaXB0Jy5jb25jYXQoJzpmYWxzZTsnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgaWZyYW1lIHRyYW5zcG9ydCByZXR1cm5zIHRoZSBpZnJhbWUgY29udGVudCBkb2N1bWVudCBhcyByZXNwb25zZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGFkZHMgY29udmVydGVycyBmcm9tIGlmcmFtZSB0byB0ZXh0LCBqc29uLCBodG1sLCB4bWxcbiAgICAvLyBhbmQgc2NyaXB0LlxuICAgIC8vIFBsZWFzZSBub3RlIHRoYXQgdGhlIENvbnRlbnQtVHlwZSBmb3IgSlNPTiByZXNwb25zZXMgaGFzIHRvIGJlIHRleHQvcGxhaW5cbiAgICAvLyBvciB0ZXh0L2h0bWwsIGlmIHRoZSBicm93c2VyIGRvZXNuJ3QgaW5jbHVkZSBhcHBsaWNhdGlvbi9qc29uIGluIHRoZVxuICAgIC8vIEFjY2VwdCBoZWFkZXIsIGVsc2UgSUUgd2lsbCBzaG93IGEgZG93bmxvYWQgZGlhbG9nLlxuICAgIC8vIFRoZSBDb250ZW50LVR5cGUgZm9yIFhNTCByZXNwb25zZXMgb24gdGhlIG90aGVyIGhhbmQgaGFzIHRvIGJlIGFsd2F5c1xuICAgIC8vIGFwcGxpY2F0aW9uL3htbCBvciB0ZXh0L3htbCwgc28gSUUgcHJvcGVybHkgcGFyc2VzIHRoZSBYTUwgcmVzcG9uc2UuXG4gICAgLy8gU2VlIGFsc29cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWQvd2lraS9TZXR1cCNjb250ZW50LXR5cGUtbmVnb3RpYXRpb25cbiAgICAkLmFqYXhTZXR1cCh7XG4gICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgICdpZnJhbWUgdGV4dCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lICYmICQoaWZyYW1lWzBdLmJvZHkpLnRleHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWZyYW1lIGpzb24nOiBmdW5jdGlvbiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZSAmJiAkLnBhcnNlSlNPTigkKGlmcmFtZVswXS5ib2R5KS50ZXh0KCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZnJhbWUgaHRtbCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lICYmICQoaWZyYW1lWzBdLmJvZHkpLmh0bWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWZyYW1lIHhtbCc6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeG1sRG9jID0gaWZyYW1lICYmIGlmcmFtZVswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jICYmICQuaXNYTUxEb2MoeG1sRG9jKSA/IHhtbERvYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAkLnBhcnNlWE1MKCh4bWxEb2MuWE1MRG9jdW1lbnQgJiYgeG1sRG9jLlhNTERvY3VtZW50LnhtbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHhtbERvYy5ib2R5KS5odG1sKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZnJhbWUgc2NyaXB0JzogZnVuY3Rpb24gKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWUgJiYgJC5nbG9iYWxFdmFsKCQoaWZyYW1lWzBdLmJvZHkpLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSkpO1xuIiwiLyohXG4gKiBqUXVlcnkgVUkgVG91Y2ggUHVuY2ggMC4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMeKAkzIwMTQsIERhdmUgRnVyZmVyb1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKlxuICogRGVwZW5kczpcbiAqICBqcXVlcnkudWkud2lkZ2V0LmpzXG4gKiAganF1ZXJ5LnVpLm1vdXNlLmpzXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gIC8vIERldGVjdCB0b3VjaCBzdXBwb3J0XG4gICQuc3VwcG9ydC50b3VjaCA9ICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudDtcblxuICAvLyBJZ25vcmUgYnJvd3NlcnMgd2l0aG91dCB0b3VjaCBzdXBwb3J0XG4gIGlmICghJC5zdXBwb3J0LnRvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1vdXNlUHJvdG8gPSAkLnVpLm1vdXNlLnByb3RvdHlwZSxcbiAgICAgIF9tb3VzZUluaXQgPSBtb3VzZVByb3RvLl9tb3VzZUluaXQsXG4gICAgICBfbW91c2VEZXN0cm95ID0gbW91c2VQcm90by5fbW91c2VEZXN0cm95LFxuICAgICAgdG91Y2hIYW5kbGVkO1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIG1vdXNlIGV2ZW50IGJhc2VkIG9uIGEgY29ycmVzcG9uZGluZyB0b3VjaCBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQSB0b3VjaCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2ltdWxhdGVkVHlwZSBUaGUgY29ycmVzcG9uZGluZyBtb3VzZSBldmVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2ltdWxhdGVNb3VzZUV2ZW50IChldmVudCwgc2ltdWxhdGVkVHlwZSkge1xuXG4gICAgLy8gSWdub3JlIG11bHRpLXRvdWNoIGV2ZW50c1xuICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgdG91Y2ggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLFxuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIHNpbXVsYXRlZCBtb3VzZSBldmVudCB1c2luZyB0aGUgdG91Y2ggZXZlbnQncyBjb29yZGluYXRlc1xuICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuICAgICAgc2ltdWxhdGVkVHlwZSwgICAgLy8gdHlwZVxuICAgICAgdHJ1ZSwgICAgICAgICAgICAgLy8gYnViYmxlcyAgICAgICAgICAgICAgICAgICAgXG4gICAgICB0cnVlLCAgICAgICAgICAgICAvLyBjYW5jZWxhYmxlICAgICAgICAgICAgICAgICBcbiAgICAgIHdpbmRvdywgICAgICAgICAgIC8vIHZpZXcgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgMSwgICAgICAgICAgICAgICAgLy8gZGV0YWlsICAgICAgICAgICAgICAgICAgICAgXG4gICAgICB0b3VjaC5zY3JlZW5YLCAgICAvLyBzY3JlZW5YICAgICAgICAgICAgICAgICAgICBcbiAgICAgIHRvdWNoLnNjcmVlblksICAgIC8vIHNjcmVlblkgICAgICAgICAgICAgICAgICAgIFxuICAgICAgdG91Y2guY2xpZW50WCwgICAgLy8gY2xpZW50WCAgICAgICAgICAgICAgICAgICAgXG4gICAgICB0b3VjaC5jbGllbnRZLCAgICAvLyBjbGllbnRZICAgICAgICAgICAgICAgICAgICBcbiAgICAgIGZhbHNlLCAgICAgICAgICAgIC8vIGN0cmxLZXkgICAgICAgICAgICAgICAgICAgIFxuICAgICAgZmFsc2UsICAgICAgICAgICAgLy8gYWx0S2V5ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICBmYWxzZSwgICAgICAgICAgICAvLyBzaGlmdEtleSAgICAgICAgICAgICAgICAgICBcbiAgICAgIGZhbHNlLCAgICAgICAgICAgIC8vIG1ldGFLZXkgICAgICAgICAgICAgICAgICAgIFxuICAgICAgMCwgICAgICAgICAgICAgICAgLy8gYnV0dG9uICAgICAgICAgICAgICAgICAgICAgXG4gICAgICBudWxsICAgICAgICAgICAgICAvLyByZWxhdGVkVGFyZ2V0ICAgICAgICAgICAgICBcbiAgICApO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHNpbXVsYXRlZCBldmVudCB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBldmVudC50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBqUXVlcnkgVUkgd2lkZ2V0J3MgdG91Y2hzdGFydCBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSB3aWRnZXQgZWxlbWVudCdzIHRvdWNoc3RhcnQgZXZlbnRcbiAgICovXG4gIG1vdXNlUHJvdG8uX3RvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgYW5vdGhlciB3aWRnZXQgaXMgYWxyZWFkeSBiZWluZyBoYW5kbGVkXG4gICAgaWYgKHRvdWNoSGFuZGxlZCB8fCAhc2VsZi5fbW91c2VDYXB0dXJlKGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBmbGFnIHRvIHByZXZlbnQgb3RoZXIgd2lkZ2V0cyBmcm9tIGluaGVyaXRpbmcgdGhlIHRvdWNoIGV2ZW50XG4gICAgdG91Y2hIYW5kbGVkID0gdHJ1ZTtcblxuICAgIC8vIFRyYWNrIG1vdmVtZW50IHRvIGRldGVybWluZSBpZiBpbnRlcmFjdGlvbiB3YXMgYSBjbGlja1xuICAgIHNlbGYuX3RvdWNoTW92ZWQgPSBmYWxzZTtcblxuICAgIC8vIFNpbXVsYXRlIHRoZSBtb3VzZW92ZXIgZXZlbnRcbiAgICBzaW11bGF0ZU1vdXNlRXZlbnQoZXZlbnQsICdtb3VzZW92ZXInKTtcblxuICAgIC8vIFNpbXVsYXRlIHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICBzaW11bGF0ZU1vdXNlRXZlbnQoZXZlbnQsICdtb3VzZW1vdmUnKTtcblxuICAgIC8vIFNpbXVsYXRlIHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICBzaW11bGF0ZU1vdXNlRXZlbnQoZXZlbnQsICdtb3VzZWRvd24nKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBqUXVlcnkgVUkgd2lkZ2V0J3MgdG91Y2htb3ZlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGRvY3VtZW50J3MgdG91Y2htb3ZlIGV2ZW50XG4gICAqL1xuICBtb3VzZVByb3RvLl90b3VjaE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgIC8vIElnbm9yZSBldmVudCBpZiBub3QgaGFuZGxlZFxuICAgIGlmICghdG91Y2hIYW5kbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW50ZXJhY3Rpb24gd2FzIG5vdCBhIGNsaWNrXG4gICAgdGhpcy5fdG91Y2hNb3ZlZCA9IHRydWU7XG5cbiAgICAvLyBTaW11bGF0ZSB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgc2ltdWxhdGVNb3VzZUV2ZW50KGV2ZW50LCAnbW91c2Vtb3ZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0aGUgalF1ZXJ5IFVJIHdpZGdldCdzIHRvdWNoZW5kIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGRvY3VtZW50J3MgdG91Y2hlbmQgZXZlbnRcbiAgICovXG4gIG1vdXNlUHJvdG8uX3RvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAvLyBJZ25vcmUgZXZlbnQgaWYgbm90IGhhbmRsZWRcbiAgICBpZiAoIXRvdWNoSGFuZGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNpbXVsYXRlIHRoZSBtb3VzZXVwIGV2ZW50XG4gICAgc2ltdWxhdGVNb3VzZUV2ZW50KGV2ZW50LCAnbW91c2V1cCcpO1xuXG4gICAgLy8gU2ltdWxhdGUgdGhlIG1vdXNlb3V0IGV2ZW50XG4gICAgc2ltdWxhdGVNb3VzZUV2ZW50KGV2ZW50LCAnbW91c2VvdXQnKTtcblxuICAgIC8vIElmIHRoZSB0b3VjaCBpbnRlcmFjdGlvbiBkaWQgbm90IG1vdmUsIGl0IHNob3VsZCB0cmlnZ2VyIGEgY2xpY2tcbiAgICBpZiAoIXRoaXMuX3RvdWNoTW92ZWQpIHtcblxuICAgICAgLy8gU2ltdWxhdGUgdGhlIGNsaWNrIGV2ZW50XG4gICAgICBzaW11bGF0ZU1vdXNlRXZlbnQoZXZlbnQsICdjbGljaycpO1xuICAgIH1cblxuICAgIC8vIFVuc2V0IHRoZSBmbGFnIHRvIGFsbG93IG90aGVyIHdpZGdldHMgdG8gaW5oZXJpdCB0aGUgdG91Y2ggZXZlbnRcbiAgICB0b3VjaEhhbmRsZWQgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBkdWNrIHB1bmNoIG9mIHRoZSAkLnVpLm1vdXNlIF9tb3VzZUluaXQgbWV0aG9kIHRvIHN1cHBvcnQgdG91Y2ggZXZlbnRzLlxuICAgKiBUaGlzIG1ldGhvZCBleHRlbmRzIHRoZSB3aWRnZXQgd2l0aCBib3VuZCB0b3VjaCBldmVudCBoYW5kbGVycyB0aGF0XG4gICAqIHRyYW5zbGF0ZSB0b3VjaCBldmVudHMgdG8gbW91c2UgZXZlbnRzIGFuZCBwYXNzIHRoZW0gdG8gdGhlIHdpZGdldCdzXG4gICAqIG9yaWdpbmFsIG1vdXNlIGV2ZW50IGhhbmRsaW5nIG1ldGhvZHMuXG4gICAqL1xuICBtb3VzZVByb3RvLl9tb3VzZUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gRGVsZWdhdGUgdGhlIHRvdWNoIGhhbmRsZXJzIHRvIHRoZSB3aWRnZXQncyBlbGVtZW50XG4gICAgc2VsZi5lbGVtZW50LmJpbmQoe1xuICAgICAgdG91Y2hzdGFydDogJC5wcm94eShzZWxmLCAnX3RvdWNoU3RhcnQnKSxcbiAgICAgIHRvdWNobW92ZTogJC5wcm94eShzZWxmLCAnX3RvdWNoTW92ZScpLFxuICAgICAgdG91Y2hlbmQ6ICQucHJveHkoc2VsZiwgJ190b3VjaEVuZCcpXG4gICAgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCAkLnVpLm1vdXNlIGluaXQgbWV0aG9kXG4gICAgX21vdXNlSW5pdC5jYWxsKHNlbGYpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvdWNoIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBtb3VzZVByb3RvLl9tb3VzZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gRGVsZWdhdGUgdGhlIHRvdWNoIGhhbmRsZXJzIHRvIHRoZSB3aWRnZXQncyBlbGVtZW50XG4gICAgc2VsZi5lbGVtZW50LnVuYmluZCh7XG4gICAgICB0b3VjaHN0YXJ0OiAkLnByb3h5KHNlbGYsICdfdG91Y2hTdGFydCcpLFxuICAgICAgdG91Y2htb3ZlOiAkLnByb3h5KHNlbGYsICdfdG91Y2hNb3ZlJyksXG4gICAgICB0b3VjaGVuZDogJC5wcm94eShzZWxmLCAnX3RvdWNoRW5kJylcbiAgICB9KTtcblxuICAgIC8vIENhbGwgdGhlIG9yaWdpbmFsICQudWkubW91c2UgZGVzdHJveSBtZXRob2RcbiAgICBfbW91c2VEZXN0cm95LmNhbGwoc2VsZik7XG4gIH07XG5cbn0pKGpRdWVyeSk7IiwiKGZ1bmN0aW9uKCQpe1xubXV0YXRlX2V2ZW50X3N0YWNrID0gW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnd2lkdGgnLFxuXHRcdFx0XHRoYW5kbGVyOiBmdW5jdGlvbiAoZWxlbSl7XG5cdFx0XHRcdFx0biA9IHtlbDplbGVtfVxuXHRcdFx0XHRcdGlmKCEkKG4uZWwpLmRhdGEoJ211dGF0ZS13aWR0aCcpKSQobi5lbCkuZGF0YSgnbXV0YXRlLXdpZHRoJywgJChuLmVsKS53aWR0aCgpKTtcblx0XHRcdFx0XHRpZiAoJChuLmVsKS5kYXRhKCdtdXRhdGUtd2lkdGgnKSYmJChuLmVsKS53aWR0aCgpICE9ICQobi5lbCkuZGF0YSgnbXV0YXRlLXdpZHRoJykgICkge1xuXHRcdFx0XHRcdFx0JChuLmVsKS5kYXRhKCdtdXRhdGUtd2lkdGgnLCAkKG4uZWwpLndpZHRoKCkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTonaGVpZ2h0Jyxcblx0XHRcdFx0aGFuZGxlcjogZnVuY3Rpb24gKG4pe1xuXHRcdFx0XHRcdGVsZW1lbnQgPSBuO1xuXHRcdFx0XHRcdGlmKCEkKGVsZW1lbnQpLmRhdGEoJ211dGF0ZS1oZWlnaHQnKSkkKGVsZW1lbnQpLmRhdGEoJ211dGF0ZS1oZWlnaHQnLCAkKGVsZW1lbnQpLmhlaWdodCgpKTtcblx0XHRcdFx0XHRpZiAoJChlbGVtZW50KS5kYXRhKCdtdXRhdGUtaGVpZ2h0JykmJiQoZWxlbWVudCkuaGVpZ2h0KCkgIT0gJChlbGVtZW50KS5kYXRhKCdtdXRhdGUtaGVpZ2h0JykgICkge1xuXHRcdFx0XHRcdFx0JChlbGVtZW50KS5kYXRhKCdtdXRhdGUtaGVpZ2h0JywgJChlbGVtZW50KS5oZWlnaHQoKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAndG9wJyxcblx0XHRcdFx0aGFuZGxlciBcdDogZnVuY3Rpb24gKG4pe1xuXHRcdFx0XHRcdGlmKCEkKG4pLmRhdGEoJ211dGF0ZS10b3AnKSkkKG4pLmRhdGEoJ211dGF0ZS10b3AnLCAkKG4pLmNzcygndG9wJykpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICgkKG4pLmRhdGEoJ211dGF0ZS10b3AnKSYmJChuKS5jc3MoJ3RvcCcpICE9ICQobikuZGF0YSgnbXV0YXRlLXRvcCcpICApIHtcblx0XHRcdFx0XHRcdCQobikuZGF0YSgnbXV0YXRlLXRvcCcsICQobikuY3NzKCd0b3AnKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAnYm90dG9tJyxcblx0XHRcdFx0aGFuZGxlciBcdDogZnVuY3Rpb24gKG4pe1xuXHRcdFx0XHRcdGlmKCEkKG4pLmRhdGEoJ211dGF0ZS1ib3R0b20nKSkkKG4pLmRhdGEoJ211dGF0ZS1ib3R0b20nLCAkKG4pLmNzcygnYm90dG9tJykpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICgkKG4pLmRhdGEoJ211dGF0ZS1ib3R0b20nKSYmJChuKS5jc3MoJ2JvdHRvbScpICE9ICQobikuZGF0YSgnbXV0YXRlLWJvdHRvbScpICApIHtcblx0XHRcdFx0XHRcdCQobikuZGF0YSgnbXV0YXRlLWJvdHRvbScsICQobikuY3NzKCdib3R0b20nKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAncmlnaHQnLFxuXHRcdFx0XHRoYW5kbGVyIFx0OiBmdW5jdGlvbiAobil7XG5cdFx0XHRcdFx0aWYoISQobikuZGF0YSgnbXV0YXRlLXJpZ2h0JykpJChuKS5kYXRhKCdtdXRhdGUtcmlnaHQnLCAkKG4pLmNzcygncmlnaHQnKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCQobikuZGF0YSgnbXV0YXRlLXJpZ2h0JykmJiQobikuY3NzKCdyaWdodCcpICE9ICQobikuZGF0YSgnbXV0YXRlLXJpZ2h0JykgICkge1xuXHRcdFx0XHRcdFx0JChuKS5kYXRhKCdtdXRhdGUtcmlnaHQnLCAkKG4pLmNzcygncmlnaHQnKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAnbGVmdCcsXG5cdFx0XHRcdGhhbmRsZXIgXHQ6IGZ1bmN0aW9uIChuKXtcblx0XHRcdFx0XHRpZighJChuKS5kYXRhKCdtdXRhdGUtbGVmdCcpKSQobikuZGF0YSgnbXV0YXRlLWxlZnQnLCAkKG4pLmNzcygnbGVmdCcpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoJChuKS5kYXRhKCdtdXRhdGUtbGVmdCcpJiYkKG4pLmNzcygnbGVmdCcpICE9ICQobikuZGF0YSgnbXV0YXRlLWxlZnQnKSAgKSB7XG5cdFx0XHRcdFx0XHQkKG4pLmRhdGEoJ211dGF0ZS1sZWZ0JywgJChuKS5jc3MoJ2xlZnQnKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAnaGlkZScsXG5cdFx0XHRcdGhhbmRsZXIgXHQ6IGZ1bmN0aW9uIChuKXsgaWYgKCQobikuaXMoJzpoaWRkZW4nKSlcdHJldHVybiB0cnVlOyB9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lXHRcdDogJ3Nob3cnLFxuXHRcdFx0XHRoYW5kbGVyIFx0OiBmdW5jdGlvbiAobil7IGlmICgkKG4pLmlzKCc6dmlzaWJsZScpKVx0cmV0dXJuIHRydWU7IH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAnc2Nyb2xsSGVpZ2h0Jyxcblx0XHRcdFx0aGFuZGxlciBcdDogZnVuY3Rpb24gKG4pe1xuXHRcdFx0XHRcdGlmKCEkKG4pLmRhdGEoJ3ByZXYtc2Nyb2xsSGVpZ2h0JykpJChuKS5kYXRhKCdwcmV2LXNjcm9sbEhlaWdodCcsICQobilbMF0uc2Nyb2xsSGVpZ2h0KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoJChuKS5kYXRhKCdwcmV2LXNjcm9sbEhlaWdodCcpJiYkKG4pWzBdLnNjcm9sbEhlaWdodCAhPSAkKG4pLmRhdGEoJ3ByZXYtc2Nyb2xsSGVpZ2h0JykgICkge1xuXHRcdFx0XHRcdFx0JChuKS5kYXRhKCdwcmV2LXNjcm9sbEhlaWdodCcsICQobilbMF0uc2Nyb2xsSGVpZ2h0KTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZVx0XHQ6ICdzY3JvbGxXaWR0aCcsXG5cdFx0XHRcdGhhbmRsZXIgXHQ6IGZ1bmN0aW9uIChuKXtcblx0XHRcdFx0XHRpZighJChuKS5kYXRhKCdwcmV2LXNjcm9sbFdpZHRoJykpJChuKS5kYXRhKCdwcmV2LXNjcm9sbFdpZHRoJywgJChuKVswXS5zY3JvbGxXaWR0aCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCQobikuZGF0YSgncHJldi1zY3JvbGxXaWR0aCcpJiYkKG4pWzBdLnNjcm9sbFdpZHRoICE9ICQobikuZGF0YSgncHJldi1zY3JvbGxXaWR0aCcpICApIHtcblx0XHRcdFx0XHRcdCQobikuZGF0YSgncHJldi1zY3JvbGxXaWR0aCcsICQobilbMF0uc2Nyb2xsV2lkdGgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lXHRcdDogJ3Njcm9sbFRvcCcsXG5cdFx0XHRcdGhhbmRsZXIgXHQ6IGZ1bmN0aW9uIChuKXtcblx0XHRcdFx0XHRpZighJChuKS5kYXRhKCdwcmV2LXNjcm9sbFRvcCcpKSQobikuZGF0YSgncHJldi1zY3JvbGxUb3AnLCAkKG4pWzBdLnNjcm9sbFRvcCgpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoJChuKS5kYXRhKCdwcmV2LXNjcm9sbFRvcCcpJiYkKG4pWzBdLnNjcm9sbFRvcCgpICE9ICQobikuZGF0YSgncHJldi1zY3JvbGxUb3AnKSAgKSB7XG5cdFx0XHRcdFx0XHQkKG4pLmRhdGEoJ3ByZXYtc2Nyb2xsVG9wJywgJChuKVswXS5zY3JvbGxUb3AoKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVcdFx0OiAnc2Nyb2xsTGVmdCcsXG5cdFx0XHRcdGhhbmRsZXIgXHQ6IGZ1bmN0aW9uIChuKXtcblx0XHRcdFx0XHRpZighJChuKS5kYXRhKCdwcmV2LXNjcm9sbExlZnQnKSkkKG4pLmRhdGEoJ3ByZXYtc2Nyb2xsTGVmdCcsICQobilbMF0uc2Nyb2xsTGVmdCgpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoJChuKS5kYXRhKCdwcmV2LXNjcm9sbExlZnQnKSYmJChuKVswXS5zY3JvbGxMZWZ0KCkgIT0gJChuKS5kYXRhKCdwcmV2LXNjcm9sbExlZnQnKSAgKSB7XG5cdFx0XHRcdFx0XHQkKG4pLmRhdGEoJ3ByZXYtc2Nyb2xsTGVmdCcsICQobilbMF0uc2Nyb2xsTGVmdCgpKTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG59KShqUXVlcnkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBqUXVlcnktbXV0YXRlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKiBEYXRlOiAyMDE0LTAyLTA0XG4gKi9cbiA7KGZ1bmN0aW9uKCQpe211dGF0ZT17c3BlZWQ6MSxldmVudF9zdGFjazptdXRhdGVfZXZlbnRfc3RhY2ssc3RhY2s6W10sZXZlbnRzOnt9LGFkZF9ldmVudDpmdW5jdGlvbihldnQpe211dGF0ZS5ldmVudHNbZXZ0Lm5hbWVdPWV2dC5oYW5kbGVyO30sYWRkOmZ1bmN0aW9uKGV2ZW50X25hbWUsc2VsZWN0b3IsY2FsbGJhY2ssZmFsc2VfY2FsbGJhY2spe211dGF0ZS5zdGFja1ttdXRhdGUuc3RhY2subGVuZ3RoXT17ZXZlbnRfbmFtZTpldmVudF9uYW1lLHNlbGVjdG9yOnNlbGVjdG9yLGNhbGxiYWNrOmNhbGxiYWNrLGZhbHNlX2NhbGxiYWNrOmZhbHNlX2NhbGxiYWNrfX19O2Z1bmN0aW9uIHJlc2V0KCl7dmFyIHBhcmVudD1tdXRhdGU7aWYocGFyZW50LmV2ZW50X3N0YWNrIT0ndW5kZWZpbmVkJyYmcGFyZW50LmV2ZW50X3N0YWNrLmxlbmd0aCl7JC5lYWNoKHBhcmVudC5ldmVudF9zdGFjayxmdW5jdGlvbihqLGspe211dGF0ZS5hZGRfZXZlbnQoayk7fSk7fVxucGFyZW50LmV2ZW50X3N0YWNrPVtdOyQuZWFjaChwYXJlbnQuc3RhY2ssZnVuY3Rpb24oaSxuKXskKG4uc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24oYSxiKXtpZihwYXJlbnQuZXZlbnRzW24uZXZlbnRfbmFtZV0oYik9PT10cnVlKXtpZihuWydjYWxsYmFjayddKW4uY2FsbGJhY2soYixuKTt9ZWxzZXtpZihuWydmYWxzZV9jYWxsYmFjayddKW4uZmFsc2VfY2FsbGJhY2soYixuKX19KX0pXG5zZXRUaW1lb3V0KHJlc2V0LG11dGF0ZS5zcGVlZCk7fVxucmVzZXQoKTskLmZuLmV4dGVuZCh7bXV0YXRlOmZ1bmN0aW9uKCl7dmFyIGV2ZW50X25hbWU9ZmFsc2UsY2FsbGJhY2s9YXJndW1lbnRzWzFdLHNlbGVjdG9yPXRoaXMsZmFsc2VfY2FsbGJhY2s9YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpmdW5jdGlvbigpe307aWYoYXJndW1lbnRzWzBdLnRvTG93ZXJDYXNlKCk9PSdleHRlbmQnKXttdXRhdGUuYWRkX2V2ZW50KGNhbGxiYWNrKTtyZXR1cm4gdGhpczt9XG4kLmVhY2goJC50cmltKGFyZ3VtZW50c1swXSkuc3BsaXQoJyAnKSxmdW5jdGlvbihpLG4pe2V2ZW50X25hbWU9bjttdXRhdGUuYWRkKGV2ZW50X25hbWUsc2VsZWN0b3IsY2FsbGJhY2ssZmFsc2VfY2FsbGJhY2spO30pO3JldHVybiB0aGlzO319KTt9KShqUXVlcnkpO1xuIiwiXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmcmFtZXdvcmtzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pbXBvcnQgXCJqcXVlcnktdWlcIlxuaW1wb3J0IFwiLi9mcmFtZXdvcmtzL2pxdWVyeS51aS50b3VjaC1wdW5jaC5qc1wiXG5pbXBvcnQgXCIuL2ZyYW1ld29ya3MvanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQuanNcIlxuaW1wb3J0IFwiYmx1ZWltcC1maWxlLXVwbG9hZFwiXG5pbXBvcnQgXCIuL2ZyYW1ld29ya3MvbXV0YXRlLmV2ZW50cy5qc1wiXG5pbXBvcnQgXCIuL2ZyYW1ld29ya3MvbXV0YXRlLm1pbi5qc1wiXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdyaWQgY3VzdG9tIGphdmFzY3JpcHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmltcG9ydCBcIi4vbGliL0dyaWRWaWV3cy5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9HcmlkQ29udGFpbmVyRWRpdG9yVmlldy5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9HcmlkQm94RWRpdG9yVmlldy5qc1wiXG5cbmltcG9ydCBcIi4vbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvYXV0b2NvbXBsZXRlLmpzXCJcbmltcG9ydCBcIi4vbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvYXV0b2NvbXBsZXRlX3dpdGhfbGlua3MuanNcIlxuaW1wb3J0IFwiLi9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy9jaGVja2JveC5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL2ZpbGUuanNcIlxuaW1wb3J0IFwiLi9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy9oaWRkZW4uanNcIlxuaW1wb3J0IFwiLi9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy9odG1sLmpzXCJcbmltcG9ydCBcIi4vbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvaW5mby5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL2lucHV0LmpzXCJcbmltcG9ydCBcIi4vbGliL3ZpZXdzL0VkaXRvcldpZGdldHMvbGlzdC5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL211bHRpLWF1dG9jb21wbGV0ZS5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL251bWJlci5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL3NlbGVjdC5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL3RleHQuanNcIlxuaW1wb3J0IFwiLi9saWIvdmlld3MvRWRpdG9yV2lkZ2V0cy90ZXh0YXJlYS5qc1wiXG5pbXBvcnQgXCIuL2xpYi92aWV3cy9FZGl0b3JXaWRnZXRzL3dwX21lZGlhc2VsZWN0LmpzXCJcblxuaW1wb3J0IFwiLi9saWIvdmlld3MvR3JpZFJldmlzaW9uc1ZpZXcuanNcIjtcbmltcG9ydCBcIi4vbGliL3ZpZXdzL0dyaWRUb29sYmFyVmlldy5qc1wiO1xuaW1wb3J0IFwiLi9saWIvdmlld3MvR3JpZFRvb2xDb250YWluZXJzVmlldy5qc1wiO1xuaW1wb3J0IFwiLi9saWIvdmlld3MvR3JpZFRvb2xCb3hUeXBlc1ZpZXcuanNcIjtcbmltcG9ydCBcIi4vbGliL3ZpZXdzL0dyaWRUb29sQm94Qmx1ZXByaW50c1ZpZXcuanNcIjtcbmltcG9ydCBcIi4vbGliL3ZpZXdzL0dyaWRTbG90U3R5bGVDaGFuZ2VyVmlldy5qc1wiO1xuaW1wb3J0IFwiLi9saWIvdmlld3MvR3JpZEF1dGhvcnNWaWV3LmpzXCI7XG5pbXBvcnQgXCIuL2xpYi92aWV3cy9HcmlkQXV0aG9yVmlldy5qc1wiO1xuXG5pbXBvcnQgXCIuL2xpYi9HcmlkTW9kZWxzLmpzXCJcbmltcG9ydCBcIi4vbGliL21vZGVscy9HcmlkQm94Qmx1ZXByaW50LmpzXCI7XG5pbXBvcnQgXCIuL2xpYi9tb2RlbHMvR3JpZFJpZ2h0cy5qc1wiO1xuaW1wb3J0IFwiLi9saWIvbW9kZWxzL0dyaWRBdXRob3IuanNcIjtcblxuaW1wb3J0IFwiLi9saWIvR3JpZENvbGxlY3Rpb25zLmpzXCI7XG5pbXBvcnQgXCIuL2xpYi9jb2xsZWN0aW9ucy9HcmlkQm94Qmx1ZXByaW50cy5qc1wiO1xuaW1wb3J0IFwiLi9saWIvY29sbGVjdGlvbnMvR3JpZEF1dGhvcnMuanNcIjtcbmltcG9ydCBcIi4vbGliL0dyaWRTeW5jLmpzXCI7XG5pbXBvcnQgXCIuL2xpYi9HcmlkQXN5bmMuanNcIjtcbmltcG9ydCBcIi4vbGliL0dyaWQuanNcIjtcblxuaW1wb3J0IFwiLi9sYW5ndWFnZS9ncmlkLWVuLmpzXCI7IiwiLy8gRW5nbGlzaFxuXG5kb2N1bWVudC5sYW5nX3ZhbHVlcyA9IHtcblx0Ly8gVGV4dHNcblx0XCJidG4tcHVibGlzaFwiOiBcIlB1Ymxpc2hcIixcblx0XCJidG4tcmV2ZXJ0XCI6IFwiUmV2ZXJ0XCIsXG5cdFwiYnRuLXJldmlzaW9uc1wiOiBcIlJldmlzaW9uc1wiLFxuXHRcImJ0bi1wcmV2aWV3XCI6IFwiUHJldmlld1wiLFxuXHRcImJ0bi10b2dnbGUtYm94ZXNcIjogXCJUb2dnbGUgYm94ZXNcIixcblx0XCJidG4tYWRkLWNvbnRhaW5lclwiOiBcIkFkZCBjb250YWluZXJcIixcblx0XCJidG4tYWRkLWJveFwiOiBcIkFkZCBib3hcIixcblx0XCJidG4tY2FuY2xlXCI6IFwiQ2FuY2VsXCIsXG5cdFwiYnRuLXNhdmVcIjogXCJTYXZlXCIsXG5cdFwiYnRuLW1ha2UtcmV1c2FibGVcIjogXCJNYWtlIHJldXNhYmxlXCIsXG5cdFwiYnRuLXdwLW1lZGlhXCI6IFwiTWVkaWVuZGF0ZWkgZWluZsO8Z2VuXCIsXG5cdFwic3RhdGUtZGlzcGxheVwiOiB7XG5cdFx0XCJwdWJsaXNoZWRcIjogXCJQdWJsaXNoZWQhXCIsXG5cdFx0XCJkcmFmdFwiOiBcIklzIGRyYWZ04oCmXCJcblx0fSxcblx0XCJkZWZhdWx0LXN0eWxlXCI6IFwiRGVmYXVsdCBzdHlsZVwiLFxuXHRcInJldi1ieS1hdXRob3JcIjogXCJieVwiLFxuXG5cdC8vIFBsYWNlaG9sZGVyXG5cdFwicGxhY2Vob2xkZXItc2VhcmNoLWJveFwiOiBcIlNlYXJjaCBib3hlc1wiLFxuXG5cdC8vIFRpdGxlc1xuXHRcInRpdGxlLXRhYi1jb250YWluZXJzXCI6IFwiTmV3IGNvbnRhaW5lclwiLFxuXHRcInRpdGxlLXRhYi1yZXVzZS1jb250YWluZXJcIjogXCJSZXVzYWJsZSBjb250YWluZXJcIixcblx0XCJ0aXRsZS13cC1tZWRpYVwiOiBcIkNob29zZSBhbiBpbWFnZVwiLFxuXG5cdC8vIEVkaXRvciBsYWJlbHNcblx0XCJsYWJlbC10aXRsZVwiOiBcIlRpdGxlOlwiLFxuXHRcImxhYmVsLXRpdGxlLXVybFwiOiBcIlRpdGxlIFVSTCAoZm9yIGludGVybmFscyBsaW5rcyBwbGVhc2UgdXNlIGEgcmVsYXRpdmUgcGF0aCBzdGFydGluZyB3aXRoICcvJyk6XCIsXG5cdFwibGFiZWwtcHJvbG9nXCI6IFwiUHJvbG9nOlwiLFxuXHRcImxhYmVsLWVwaWxvZ1wiOiBcIkVwaWxvZzpcIixcblx0XCJsYWJlbC1yZWFkbW9yZVwiOiBcIlJlYWQgbW9yZSBsaW5rIGxhYmVsOlwiLFxuXHRcImxhYmVsLXJlYWRtb3JlLXVybFwiOiBcIlJlYWQgbW9yZSBsaW5rIFVSTCAoZm9yIGludGVybmFscyBsaW5rcyBwbGVhc2UgdXNlIGEgcmVsYXRpdmUgcGF0aCBzdGFydGluZyB3aXRoICcvJyk6XCIsXG5cdFwibGFiZWwtc3R5bGVcIjogXCJTdHlsZTpcIixcblx0XCJsYWJlbC1iLWJlZm9yZVwiOiBcIlByb2xvZ1wiLFxuXHRcImxhYmVsLWItZHluYW1pY1wiOiBcIkJveCBzcGVjaWZpYyBzZXR0aW5nc1wiLFxuXHRcImxhYmVsLWItYWZ0ZXJcIjogXCJFcGlsb2dcIixcblxuXHQvLyBFcnJvcnM6IFNvbWV0aGluZyB3ZW50IHdyb25nLlxuXHRcImVycl9wdWJsaXNoXCI6IFwiQ291bGQgbm90IHB1Ymxpc2jigKZcIixcblx0XCJlcnJfcmV2ZXJ0XCI6IFwiQ291bGQgbm90IHJldmVydCBHcmlk4oCmXCIsXG5cdFwiZXJyX2NvbnRhaW5lcl9yZXVzZVwiOiBcIkVycm9yIHdoaWxlIHRyeWluZyB0byBtYWtlIGNvbnRhaW5lciByZXVzYWJsZSFcIixcblx0XCJlcnJfY29udGFpbmVyX3NhdmVcIjogXCJDb3VsZCBub3Qgc2F2ZSBjb250YWluZXIuXCIsXG5cdFwiZXJyX2NvbnRhaW5lcl9kZWxldGVcIjogXCJDb3VsZCBub3QgZGVsZXRlIGNvbnRhaW5lci5cIixcblx0XCJlcnJfc2xvdF9zdHlsZVwiOiBcIkNvdWxkIG5vdCBzYXZlIHNsb3Qgc3R5bGUuXCIsXG5cdFwiZXJyX2JveF90cmFzaFwiOiBcIkNvdWxkIG5vdCBkZWxldGUgYm94LlwiLFxuXHRcImVycl9tb3ZlX2NvbnRhaW5lclwiOiBcIkNvdWxkIG5vdCBtb3ZlIGNvbnRhaW5lcnMuIFNpdGUgd2lsbCByZWxvYWQhXCIsXG5cdFwiZXJyLW1vdmUtYm94XCI6IFwiRXJyb3Igd2hpbGUgbW92aW5nIGJveCFcIixcblx0XCJlcnItYm94LXJldXNlXCI6IFwiQ291bGQgbm90IG1ha2UgYm94IHJldXNhYmxlLiBQbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uXCIsXG5cdFwiZXJyLWJveC1zYXZlXCI6IFwiQ291bGQgbm90IHNhdmUgdGhlIGJveC4gUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLlwiLFxuXG5cdC8vIFdhcm5pbmdzOiBOb3RoaW5nIHdlbnQgd3JvbmcsIGJ1dCBwbGVhc2UgZG8gaXQgYW5vdGhlciB3YXkuXG5cdFwid2Fybl9jb250YWluZXJfZWRpdGVkXCI6IFwiUGxlYXNlIGZpbmlzaCBjb250YWluZXIgZWRpdGluZyBmaXJzdC5cIixcblx0XCJ3YXJuX2NvbnRhaW5lcl9yZXVzZV9uZWVkX3RpdGxlXCI6IFwiVGhlIGNvbnRhaW5lciBuZWVkcyBhIHRpdGxlIHRvIGJlIHJldXNhYmxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiLFxuXHRcIndhcm5fdG9nZ2xlX2JveGVzX2NvbnRhaW5lcl9lZGl0ZWRcIjogXCJQbGVhc2UgZmluaXNoIHRoZSBjb250YWluZXIgZWRpdGluZyBmaXJzdC5cIixcblxuXHQvLyBQcm9tcHRcblx0XCJwcm9tX2NvbnRhaW5lcl9yZXVzZV90aXRsZVwiOiBcIk9uY2UgYSBjb250YWluZXIgaXMgcmV1c2FibGUgeW91IGNhbm5vdCBtb2RpZnkgaXQgd2l0aGluIHRoaXMgZ3JpZCBhbnltb3JlLiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0XCJJZiB5b3Ugd2FudCB0byBwcm9jZWVkIGNob29zZSBhIFJldXNlLVRpdGxlIGFuZCBjb25maXJtOlwiLFxuXG5cdC8vIENvbmZpcm1cblx0XCJjb25maXJtLWJveC1yZXVzZVwiOiBcIk9uY2UgYSBib3ggaXMgcmV1c2FibGUgeW91IGNhbm5vdCBtb2RpZnkgaXQgd2l0aGluIHRoaXMgZ3JpZCBhbnltb3JlLlxcblByb2NlZWQ/XCIsXG5cdFwiY29uZmlybS1sZWF2ZS1wYWdlXCI6IFwiRG8geW91IHJlYWxseSB3YW50IHRvIGxlYXZlIEdyaWQ/XCIsXG5cdFwiY29uZmlybS1ncmlkLXJldmVydFwiOiBcIkRlbGV0ZSBhbGwgY2hhbmdlcz9cIixcblxuXHRcImluZm8td3AtaGlkZS1hZG1pbmJhclwiOiBcIllvdSBjYW4gZXhwYW5kIHRoZSBhZG1pbiBtZW51IGhlcmUuIEdyaWQgbmVlZHMgc29tZSBtb3JlIHNwYWNlLCBzbyB0aGUgYWRtaW4gbWVudSBpcyBhdXRvbWF0aWNhbGx5IGNvbGxhcHNlZC5cIlxufTtcbiIsIlxuLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBpY2ggZnJvbSAnaWNhbmhheidcbmltcG9ydCB7R3JpZEFzeW5jfSBmcm9tIFwiLi9HcmlkQXN5bmNcIjtcblxuLyoqXG4qXHRJRSBKUyBjb25zb2xlIGZpeFxuKi9cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgbWV0aG9kO1xuICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAgdmFyIG1ldGhvZHMgPSBbXG4gICAgICAgICdhc3NlcnQnLCAnY2xlYXInLCAnY291bnQnLCAnZGVidWcnLCAnZGlyJywgJ2RpcnhtbCcsICdlcnJvcicsXG4gICAgICAgICdleGNlcHRpb24nLCAnZ3JvdXAnLCAnZ3JvdXBDb2xsYXBzZWQnLCAnZ3JvdXBFbmQnLCAnaW5mbycsICdsb2cnLFxuICAgICAgICAnbWFya1RpbWVsaW5lJywgJ3Byb2ZpbGUnLCAncHJvZmlsZUVuZCcsICd0YWJsZScsICd0aW1lJywgJ3RpbWVFbmQnLFxuICAgICAgICAndGltZVN0YW1wJywgJ3RyYWNlJywgJ3dhcm4nXG4gICAgXTtcbiAgICB2YXIgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGg7XG4gICAgdmFyIGNvbnNvbGUgPSAod2luZG93LmNvbnNvbGUgPSB3aW5kb3cuY29uc29sZSB8fCB7fSk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kc1tsZW5ndGhdO1xuXG4gICAgICAgIC8vIE9ubHkgc3R1YiB1bmRlZmluZWQgbWV0aG9kcy5cbiAgICAgICAgaWYgKCFjb25zb2xlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuXG4vKiogcHVibGljIG9iamVjdCAqL1xud2luZG93LkdSSUQgPSB7fTtcbmNvbnN0IEdSSUQgPSB3aW5kb3cuR1JJRCA9IHtcblx0JGJvZHk6IG51bGwsXG5cdGRvbV9yb290OiBcIiNuZXctZ3JpZC13cmFwcGVyXCIsXG5cdCRyb290OiBudWxsLFxuXHRkb21fcm9vdF9lZGl0b3I6IFwiI25ldy1ncmlkLWVkaXRvci13cmFwcGVyXCIsXG5cdCRyb290X2VkaXRvcjogbnVsbCxcblx0ZG9tX3Jvb3RfYXV0aG9yczogXCIjZ3JpZC1hdXRob3JzLXdyYXBwZXJcIixcblx0JHJvb3RfYXV0aG9yczogbnVsbCxcblx0SUQ6IG51bGwsXG5cdC8vIGVuYWJsZSBvciBkaXNhYmxlIGRlYnVnZ2luZyBvdXRwdXRcblx0REVCVUdHSU5HOiBmYWxzZSxcblx0Ly8gdGhlIHNlcnZlciBVUkxcblx0U0VSVkVSOiBcIi9ncmlkX2FqYXhfZW5kcG9pbnRcIixcblx0Ly8gUGF0dGVybiBmb3IgcHJldmlldyBVUkxcblx0UFJFVklFV19VUkw6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSsnL3ByZXZpZXcnLFxuXHRQUkVWSUVXX1BBVFRFUk46IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSsnL3tSRVZ9L3ByZXZpZXcnLFxuXHQvLyBpbml0aWFsaXplcyB0aGUgZ3JpZFxuXHRncmlkOiBudWxsLFxuXHRncmlkVmlldzogbnVsbCxcblx0dHlwZXNfYm94OiBudWxsLFxuICAgIHR5cGVzX2NvbnRhaW5lcjogbnVsbCxcbiAgICByZXVzYWJsZV9jb250YWluZXJzOiBudWxsLFxuICAgIHN0eWxlc19jb250YWluZXI6IG51bGwsXG4gICAgc3R5bGVzX3Nsb3Q6IG51bGwsXG4gICAgc3R5bGVzX2JveDogbnVsbCxcbiAgICByZXZpc2lvbnM6IG51bGwsXG4gICAgYXN5bmM6IG51bGwsXG4gICAgYXV0aG9yczogbnVsbCxcblx0aW5pdDogZnVuY3Rpb24oKXtcblxuXHRcdC8vIGluaXRpYWxpemUgY29uc3RhbnRzXG5cdFx0dGhpcy5faW5pdENvbnN0YW50cygpO1xuXHRcdGlmKHR5cGVvZiBHUklELklEID09PSBcInVuZGVmaW5lZFwiIHx8IEdSSUQuSUQgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0XHQvKipcblx0XHQgKiBsb2FkaW5nIGluZGljYXRvciBiZWZvcmUgZ3JpZCBpcyByZWFkeVxuXHRcdCAqXG5cdFx0ICovXG5cdFx0R1JJRC4kbG9hZGluZyA9IGljaC50cGxfbG9hZGluZygpO1xuXHRcdHRoaXMuJHJvb3QuYXBwZW5kKEdSSUQuJGxvYWRpbmcpO1xuXHRcdEdSSUQuJGxvYWRpbmcuYWRkQ2xhc3MoXCJncmlkLWluaXQtbG9hZGluZ1wiKTtcblxuXHRcdC8vIGxvYWQgYWxsIG1vZGVsIGNsYXNzZXMgZm9yIGdyaWQgd29ya3Ncblx0XHR0aGlzLmdldEJveFR5cGVzKCkuZmV0Y2goKTtcblx0XHR0aGlzLmdldENvbnRhaW5lclR5cGVzKCkuZmV0Y2goKTtcblx0XHR0aGlzLmdldFJldXNhYmxlQ29udGFpbmVycygpLmZldGNoKCk7XG5cdFx0dGhpcy5nZXRDb250YWluZXJTdHlsZXMoKS5mZXRjaCgpO1xuXHRcdHRoaXMuZ2V0U2xvdFN0eWxlcygpLmZldGNoKCk7XG5cdFx0dGhpcy5nZXRCb3hTdHlsZXMoKS5mZXRjaCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogaW5pdCBhc3luYyB3ZWJzb2NrZXQgbWFnaWNcblx0XHQgKiBAdHlwZSB7R3JpZEFzeW5jfVxuXHRcdCAqL1xuXHRcdHRoaXMuYXN5bmMgPSBuZXcgR3JpZEFzeW5jKCk7XG5cdFx0dGhpcy5hdXRob3JzID0gbmV3IEdyaWRBdXRob3JzKCk7XG5cdFx0dGhpcy5hc3luYy5hZGRPYnNlcnZlcih0aGlzKTtcblx0XHR0aGlzLmFzeW5jLmFkZE9ic2VydmVyKHRoaXMuYXV0aG9ycyk7XG5cblx0XHR0aGlzLmdldFJpZ2h0cygpLmZldGNoKHtcblx0XHRcdHN1Y2Nlc3M6ZnVuY3Rpb24oKXtcblxuXHRcdFx0XHQvLyBsb2FkIHRoZSBncmlkICsgdmlld1xuXHRcdFx0XHRHUklELmdyaWQgPSBuZXcgR3JpZCh7XG5cdFx0XHRcdFx0aWQ6R1JJRC5JRCxcblx0XHRcdFx0XHRTRVJWRVI6IEdSSUQuU0VSVkVSLFxuXHRcdFx0XHRcdFBSRVZJRVdfVVJMOiBHUklELlBSRVZJRVdfVVJMLFxuXHRcdFx0XHRcdERFQlVHR0lORzogR1JJRC5ERUJVR0dJTkcsXG5cdFx0XHRcdFx0Zm5fc3VjY2VzczogR1JJRC5uZXdfZ3JpZF9zdWNjZXNzXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCAkYm9keSA9IHRoaXMuJGJvZHk7XG5cdFx0JGJvZHkub24oXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0YWx0TW9kaWZpY2F0aW9uQ2xhc3MoZS5hbHRLZXkpO1xuXHRcdH0pLm9uKFwia2V5dXBcIiwgZnVuY3Rpb24oZSl7XG5cdFx0XHRhbHRNb2RpZmljYXRpb25DbGFzcyhlLmFsdEtleSk7XG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBhbHRNb2RpZmljYXRpb25DbGFzcyhpc1ByZXNzZWQpIHtcblx0XHRcdGlmKGlzUHJlc3NlZCl7XG5cdFx0XHRcdCRib2R5LmFkZENsYXNzKFwiaXMtYWx0LXByZXNzZWRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkYm9keS5yZW1vdmVDbGFzcyhcImlzLWFsdC1wcmVzc2VkXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRyZWxvYWQ6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5ncmlkLmRlc3Ryb3koKTtcblx0XHR0aGlzLmdyaWQgPSBudWxsO1xuXHRcdHRoaXMuJHJvb3RfYXV0aG9ycy5lbXB0eSgpO1xuXHRcdGlmKHRoaXMuZ3JpZFZpZXcgIT0gbnVsbCl7XG5cdFx0XHR0aGlzLmdyaWRWaWV3LnJlbW92ZSgpO1xuXHRcdH1cblx0XHR0aGlzLm5ld0dyaWQoKTtcblx0fSxcblx0bmV3R3JpZDogZnVuY3Rpb24oKXtcblx0XHQvLyBsb2FkIHRoZSBncmlkICsgdmlld1xuXHRcdHRoaXMuZ3JpZCA9IG5ldyBHcmlkKHtcbiAgICAgICAgXHRpZDpHUklELklELFxuXHRcdFx0U0VSVkVSOiB0aGlzLlNFUlZFUixcblx0XHRcdFBSRVZJRVdfVVJMOiB0aGlzLlBSRVZJRVdfVVJMLFxuXHRcdFx0REVCVUdHSU5HOiB0aGlzLkRFQlVHR0lORyxcblx0XHRcdGZuX3N1Y2Nlc3M6IEdSSUQubmV3X2dyaWRfc3VjY2Vzc1xuICAgICAgICB9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRuZXdfZ3JpZF9zdWNjZXNzOiBmdW5jdGlvbihkYXRhKXtcblx0XHRHUklELiRyb290LmVtcHR5KCk7XG5cdFx0R1JJRC4kcm9vdC5hcHBlbmQoR1JJRC4kbG9hZGluZyk7XG5cblx0XHRHUklELmdyaWR2aWV3ID0gbmV3IEdyaWRWaWV3KHttb2RlbDogR1JJRC5nZXRNb2RlbCgpIH0pO1xuXG5cdFx0Ly8gaGFuZGxlIHJpZ2h0c1xuXHRcdEdSSUQuZ3JpZHZpZXcubGlzdGVuVG8oR1JJRC5nZXRSaWdodHMoKSxcImNoYW5nZVwiLEdSSUQub25SaWdodHMpO1xuXG5cdFx0R1JJRC4kcm9vdC5hcHBlbmQoIEdSSUQuZ2V0VmlldygpLnJlbmRlcigpLmVsICk7XG5cblx0XHRHUklELl9pbml0aWFsaXplQ29udGFpbmVyU29ydGFibGUoKTtcblx0XHRHUklELl9pbml0aWFsaXplQm94U29ydGFibGUoKTtcblx0XHQvLyBsb2FkIHRoZSByZXZpc2lvbnNcblx0XHRHUklELnJldmlzaW9ucyA9IG5ldyBSZXZpc2lvbnMoe2dyaWQ6IEdSSUQuZ2V0TW9kZWwoKSB9KTtcblx0XHRHUklELnJldmlzaW9ucy5mZXRjaCgpO1xuXHRcdC8vIGluaXQgdG9vbGJhclxuXHRcdEdSSUQudG9vbGJhciAgPSBuZXcgR3JpZFRvb2xiYXJWaWV3KHtcblx0XHRcdG1vZGVsOiBHUklELmdldE1vZGVsKClcblx0XHR9KTtcblx0XHRHUklELmFzeW5jLmFkZE9ic2VydmVyKEdSSUQudG9vbGJhcik7XG5cdFx0R1JJRC4kcm9vdC5wcmVwZW5kKEdSSUQudG9vbGJhci5yZW5kZXIoKS5lbCk7XG5cblx0XHRHUklELiRsb2FkaW5nLnJlbW92ZUNsYXNzKFwiZ3JpZC1pbml0LWxvYWRpbmdcIik7XG5cblx0XHQvKipcblx0XHQgKiBpbml0IGFzeW5jIGNvbm5lY3Rpb24gb24gZ3JpZCBsb2FkaW5nIGRvbmVcblx0XHQgKi9cblx0XHRHUklELmFzeW5jLmluaXQoKTtcblxuXHRcdC8qKlxuXHRcdCAqIGxpc3RlbiB0byBjaGFuZ2VzIG9mIHdpbmRvdyBzaXplXG5cdFx0ICovXG5cdFx0alF1ZXJ5KHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCl7IEdSSUQudG9vbGJhci5vblJlc2l6ZSgpIH0pLnRyaWdnZXIoXCJyZXNpemVcIik7XG5cdH0sXG5cblx0Z2V0TW9kZWw6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuZ3JpZDtcblx0fSxcblx0Z2V0VmlldzogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5ncmlkdmlldztcblx0fSxcblx0Ly8gdHlwZSBjb2xsZWN0aW9uc1xuXHRnZXRDb250YWluZXJUeXBlczogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoISh0aGlzLnR5cGVzX2NvbnRhaW5lciBpbnN0YW5jZW9mIENvbnRhaW5lclR5cGVzKSApe1xuICAgICAgICAgICAgdGhpcy50eXBlc19jb250YWluZXIgPSBuZXcgQ29udGFpbmVyVHlwZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlc19jb250YWluZXI7XG4gICAgfSxcbiAgICBnZXRSZXVzYWJsZUNvbnRhaW5lcnM6IGZ1bmN0aW9uKCl7XG4gICAgXHRpZighKHRoaXMucmV1c2FibGVfY29udGFpbmVycyBpbnN0YW5jZW9mIFJldXNhYmxlQ29udGFpbmVycykpe1xuICAgIFx0XHR0aGlzLnJldXNhYmxlX2NvbnRhaW5lcnMgPSBuZXcgUmV1c2FibGVDb250YWluZXJzKCk7XG4gICAgXHR9XG4gICAgXHRyZXR1cm4gdGhpcy5yZXVzYWJsZV9jb250YWluZXJzO1xuICAgIH0sXG4gICAgZ2V0Qm94VHlwZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCEodGhpcy50eXBlc19ib3ggaW5zdGFuY2VvZiBCb3hUeXBlcykgKXtcbiAgICAgICAgICAgIHRoaXMudHlwZXNfYm94ID0gbmV3IEJveFR5cGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNfYm94O1xuICAgIH0sXG4gICAgLy8gc3R5bGUgY29sbGVjdGlvbnNcbiAgICBnZXRDb250YWluZXJTdHlsZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCEodGhpcy5zdHlsZXNfY29udGFpbmVyIGluc3RhbmNlb2YgU3R5bGVzKSApe1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNfY29udGFpbmVyID0gbmV3IFN0eWxlcyh7dHlwZTpcImNvbnRhaW5lclwifSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzX2NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGdldFNsb3RTdHlsZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCEodGhpcy5zdHlsZXNfc2xvdCBpbnN0YW5jZW9mIFN0eWxlcykgKXtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzX3Nsb3QgPSBuZXcgU3R5bGVzKHt0eXBlOlwic2xvdFwifSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzX3Nsb3Q7XG4gICAgfSxcbiAgICBnZXRCb3hTdHlsZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCEodGhpcy5zdHlsZXNfYm94IGluc3RhbmNlb2YgU3R5bGVzKSApe1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNfYm94ID0gbmV3IFN0eWxlcyh7dHlwZTpcImJveFwifSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzX2JveDtcbiAgICB9LFxuICAgIGdldFJpZ2h0czogZnVuY3Rpb24oKXtcbiAgICBcdGlmKCEodGhpcy5yaWdodHMgaW5zdGFuY2VvZiBHcmlkUmlnaHRzKSl7XG4gICAgXHRcdHRoaXMucmlnaHRzID0gbmV3IEdyaWRSaWdodHMoKTtcbiAgICBcdH1cbiAgICBcdHJldHVybiB0aGlzLnJpZ2h0cztcbiAgICB9LFxuICAgIC8vIHJldmlzaW9uc1xuICAgIHNldFRvUmV2aXNpb246IGZ1bmN0aW9uKHJldmlzaW9uKXtcbiAgICBcdGlmKEdSSUQubG9ja2VkKCkpIHJldHVybjtcbiAgICAgICAgR3JpZFJlcXVlc3QuZ3JpZC51cGRhdGUoR1JJRC5ncmlkLCB7YWN0aW9uOiBcInNldFRvUmV2aXNpb25cIiwgcmV2aXNpb246IHJldmlzaW9ufSk7XG4gICAgfSxcbiAgICAvLyBvblJpZ2h0c0NoYW5nZVxuICAgIG9uUmlnaHRzOiBmdW5jdGlvbihyaWdodHMpe1xuICAgIFx0R1JJRC5sb2coW1wib25yaWdodHNcIixyaWdodHNdKTtcbiAgICBcdEdSSUQuZ2V0VmlldygpLnJlbmRlcigpO1xuICAgIFx0R1JJRC50b29sYmFyLnJlbmRlcigpO1xuICAgIH0sXG5cdC8vIGluaXRpYWxpemVzIHRoZSBjb25zdGF0bnNcblx0X2luaXRDb25zdGFudHM6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gcm9vdCBlbGVtZW50c1xuXHRcdHRoaXMuJGJvZHkgPSBqUXVlcnkoXCJib2R5XCIpO1xuXHRcdHRoaXMuJHJvb3QgPSBqUXVlcnkodGhpcy5kb21fcm9vdCk7XG5cdFx0dGhpcy4kcm9vdF9lZGl0b3IgPSBqUXVlcnkodGhpcy5kb21fcm9vdF9lZGl0b3IpO1xuXHRcdHRoaXMuJHJvb3RfYXV0aG9ycyA9IGpRdWVyeSh0aGlzLmRvbV9yb290X2F1dGhvcnMpO1xuXHRcdC8vIGNvbnN0YW50cyBmcm9tIENNU1xuXHRcdHRoaXMubW9kZSA9IGRvY3VtZW50LmdyaWRtb2RlO1xuXHRcdHRoaXMuJHJvb3QuYWRkQ2xhc3MoJ2dyaWRtb2RlLScrdGhpcy5tb2RlKTtcblxuXHRcdHRoaXMuREVCVUdHSU5HID0gZG9jdW1lbnQuZ3JpZF9kZWJ1Z19tb2RlO1xuXHRcdHRoaXMuSUQgPSBkb2N1bWVudC5JRDtcblx0XHR0aGlzLlNFUlZFUiA9IFwiL2dyaWRfYWpheF9lbmRwb2ludFwiO1xuXHRcdGlmKCB0eXBlb2YgZG9jdW1lbnQuZ3JpZGFqYXggIT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0ZG9jdW1lbnQuZ3JpZGFqYXggIT0gbnVsbCAmJlxuXHRcdFx0ZG9jdW1lbnQuZ3JpZGFqYXggIT0gXCJcIil7XG5cdFx0XHR0aGlzLlNFUlZFUiA9IGRvY3VtZW50LmdyaWRhamF4O1xuXHRcdH1cblx0XHR0aGlzLlBSRVZJRVdfVVJMID0gdGhpcy5QUkVWSUVXX1VSTC5yZXBsYWNlKFwiLy9cIixcIi9cIik7XG5cdFx0aWYoIHR5cGVvZiBkb2N1bWVudC5wcmV2aWV3dXJsICE9IHR5cGVvZiB1bmRlZmluZWQgJiZcblx0XHRcdGRvY3VtZW50LnByZXZpZXd1cmwgIT0gbnVsbCAmJlxuXHRcdFx0ZG9jdW1lbnQucHJldmlld3VybCAhPSBcIlwiKXtcblx0XHRcdHRoaXMuUFJFVklFV19VUkwgPSBkb2N1bWVudC5wcmV2aWV3dXJsO1xuXHRcdH1cblx0XHR2YXIgUFJFVklFV19QQVRURVJOID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKycve1JFVn0vcHJldmlldyc7XG5cdFx0aWYoIHR5cGVvZiBkb2N1bWVudC5wcmV2aWV3cGF0dGVybiAhPSB0eXBlb2YgdW5kZWZpbmVkICYmXG5cdFx0XHRkb2N1bWVudC5wcmV2aWV3cGF0dGVybiAhPSBudWxsICYmXG5cdFx0XHRkb2N1bWVudC5wcmV2aWV3cGF0dGVybiAhPSBcIlwiKXtcblx0XHRcdFBSRVZJRVdfUEFUVEVSTiA9IGRvY3VtZW50LnByZXZpZXdwYXR0ZXJuO1xuXHRcdH1cblx0XHR0aGlzLlBSRVZJRVdfUEFUVEVSTj1QUkVWSUVXX1BBVFRFUk47XG5cdH0sXG5cdC8vIHB1Ymxpc2hlcyB0aGUgZ3JpZFxuXHRwdWJsaXNoOiBmdW5jdGlvbigpe1xuXHRcdGlmKCAhR1JJRC5nZXRSaWdodHMoKS5nZXQoXCJwdWJsaXNoXCIpIHx8IEdSSUQubG9ja2VkKCkgKXtcblx0XHRcdGFsZXJ0KFwiU29ycnkgeW91IGhhdmUgbm8gcmlnaHRzIGZvciB0aGF0Li4uXCIpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRuZXcgR3JpZEFqYXgoXCJwdWJsaXNoRHJhZnRcIixbR1JJRC5JRF0pO1xuXHR9LFxuXHQvLyByZXZlcnQgdG8gb2xkIHJldmlzaW9uXG5cdHJldmVydDogZnVuY3Rpb24oKXtcblx0XHRpZihHUklELmxvY2tlZCgpKSByZXR1cm47XG4gICAgICAgIEdyaWRSZXF1ZXN0LmdyaWQudXBkYXRlKEdSSUQuZ3JpZCwge2FjdGlvbjogXCJyZXZlcnREcmFmdFwifSk7XG5cdH0sXG5cdC8vIGNvbnNvbGUgbG9nZ2luZyBqdXN0IHdpdGggREVCVUdHSU5HIGVuYWJsZWRcblx0bG9nOiBmdW5jdGlvbihzdHJpbmcpeyBpZih0aGlzLkRFQlVHR0lORyl7IGNvbnNvbGUubG9nKHN0cmluZyk7IH0gfSxcblx0LyoqXG5cdCAqIGNoYW5nZSB0byBib3ggYW5kIGNvbnRhaW5lciBlZGl0b3Jcblx0ICovXG5cdHNob3dFZGl0b3I6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0R1JJRC4kcm9vdC5hbmltYXRlKFxuXHRcdFx0e1xuXHRcdFx0XHR3aWR0aDowXG5cdFx0XHR9LFxuXHRcdFx0MjIwLFxuXHRcdFx0ZnVuY3Rpb24oKXtcblx0XHRcdFx0R1JJRC4kcm9vdC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRHUklELiRyb290X2VkaXRvci5zaG93KCk7XG5cdFx0XHRHUklELiRyb290X2VkaXRvci5hbmltYXRlKHt3aWR0aDpcIjEwMCVcIn0sMjUwLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9KTtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLDApO1xuXHRcdH0sNTApO1xuXHR9LFxuXHRoaWRlRWRpdG9yOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdEdSSUQuJHJvb3RfZWRpdG9yLmFuaW1hdGUoe3dpZHRoOlwiMCVcIn0sMjIwLCBmdW5jdGlvbigpe0dSSUQuJHJvb3RfZWRpdG9yLmhpZGUoKTt9KTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRHUklELiRyb290LnNob3coKTtcblx0XHRcdEdSSUQuJHJvb3QuYW5pbWF0ZSh7d2lkdGg6XCIxMDAlXCJ9LDIyMCxmdW5jdGlvbigpe1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fSk7XG5cdFx0XHR3aW5kb3cuc2Nyb2xsVG8oMCwwKTtcblx0XHR9LDUwKTtcblx0fSxcblx0LyoqXG5cdCAqIGNoYW5nZSB0byBhdXRob3JzXG5cdCAqL1xuXHR0b2dnbGVBdXRob3JzOiBmdW5jdGlvbigpe1xuXHRcdGlmKEdSSUQuJHJvb3RfYXV0aG9ycy5odG1sKCk9PVwiXCIpe1xuXHRcdFx0R1JJRC4kcm9vdF9hdXRob3JzLmVtcHR5KCk7XG5cdFx0XHR2YXIgYXV0aG9ycyA9IG5ldyBBdXRob3JzKCk7XG5cdFx0XHRHUklELiRyb290X2F1dGhvcnMuYXBwZW5kKGF1dGhvcnMucmVuZGVyKCkuJGVsKTtcblx0XHRcdGF1dGhvcnMubGlzdGVuVG8oIEdSSUQudG9vbGJhciwndG9vbGJhcl9yZXNpemUnLCBhdXRob3JzLm9uUmVzaXplKTtcblx0XHR9XG5cblx0XHRHUklELiRyb290LnRvZ2dsZUNsYXNzKFwiaXMtYWN0aXZlLWF1dGhvcnNcIik7XG5cdFx0R1JJRC4kcm9vdF9hdXRob3JzLnRvZ2dsZUNsYXNzKFwiaXMtYWN0aXZlXCIpO1xuXHRcdEdSSUQudG9vbGJhci5vblJlc2l6ZSgpO1xuXHR9LFxuXHRzaG93QXV0aG9yczogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmhpZGVBdXRob3JzKCk7XG5cdFx0dGhpcy50b2dnbGVBdXRob3JzKCk7XG5cdH0sXG5cdGhpZGVBdXRob3JzOiBmdW5jdGlvbigpe1xuXHRcdEdSSUQuJHJvb3QucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmUtYXV0aG9yc1wiKTtcblx0XHRHUklELiRyb290X2F1dGhvcnMucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG5cdH0sXG5cdGxvY2tlZDogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gIUdSSUQuYXV0aG9ycy5oYXZlTG9jaygpO1xuXHR9LFxuXHRhc3luY19sb2NraW5nX2lzX2xvY2tlZDogZnVuY3Rpb24oKXtcblx0XHRpZihHUklELmxvY2tlZCgpKXtcblx0XHRcdEdSSUQuJHJvb3QuYWRkQ2xhc3MoXCJncmlkLWlzLWxvY2tlZFwiKTtcblx0XHRcdEdSSUQuc2hvd0F1dGhvcnMoKTtcblx0XHR9IGVsc2UgaWYoR1JJRC4kcm9vdC5oYXNDbGFzcyhcImdyaWQtaXMtbG9ja2VkXCIpKXtcblx0XHRcdEdSSUQucmVsb2FkKCk7XG5cdFx0XHRHUklELiRyb290LnJlbW92ZUNsYXNzKFwiZ3JpZC1pcy1sb2NrZWRcIik7XG5cdFx0XHR0aGlzLmhpZGVBdXRob3JzKCk7XG5cdFx0fVxuXHR9LFxuXHRhc3luY19kaXNjb25uZWN0OiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuYXN5bmNfbG9ja2luZ19pc19sb2NrZWQoKTtcblx0fSxcblx0Ly8gaW5pdGlhbGl6ZXMgZnVuY3Rpb24gdG8gc29ydCB0aGUgY29udGFpbmVyc1xuXHRfaW5pdGlhbGl6ZUNvbnRhaW5lclNvcnRhYmxlOiBmdW5jdGlvbigpe1xuXHRcdGlmKCFHUklELmdldFJpZ2h0cygpLmdldChcIm1vdmUtY29udGFpbmVyXCIpIHx8IEdSSUQubG9ja2VkKCkpIHJldHVybiBmYWxzZTtcblx0XHR2YXIgY29udGFpbmVyX2RlbGV0ZWQ7XG5cdFx0Y29udGFpbmVyX2RlbGV0ZWQ9ZmFsc2U7XG5cdFx0dmFyIGNvbnRhaW5lcjtcblx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdGpRdWVyeSh0aGlzLmdldFZpZXcoKS5lbCkuc29ydGFibGUoe1xuICAgICAgICAgICAgaGFuZGxlOiBcIi5ncmlkLWNvbnRhaW5lci1zb3J0aGFuZGxlLCAuZ3JpZC1jb250YWluZXItcmV1c2VkLWxheWVyXCIsXG4gICAgICAgICAgICBpdGVtczpcIi5ncmlkLWNvbnRhaW5lcjpub3QoLmdyaWQtY29udGFpbmVyLXR5cGUtc2MpXCIsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJncmlkLWNvbnRhaW5lci1zb3J0LXBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICBwdWxsUGxhY2Vob2xkZXI6IHRydWUsXG4gICAgICAgICAgICBhcHBlbmRUbzogdGhpcy5nZXRWaWV3KCkuJGVsICxcbiAgICAgICAgICAgIHJlZnJlc2hQb3NpdGlvbnM6IHRydWUsXG4gICAgICAgICAgICBoZWxwZXI6IGZ1bmN0aW9uKGV2ZW50LCBlbGVtZW50KXtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5KFwiPGRpdiBjbGFzcz0nZHJhZ2dlci1oZWxwZXInPjwvZGl2PlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJzb3JBdDogeyBsZWZ0OiAzMCwgYm90dG9tOiAzMCB9LFxuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKXtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhbXCJjb250YWluZXIgc29ydCBTVEFSVFwiXSwgZXZlbnQsIHVpKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkX2NvbnRhaW5lcl9pZD11aS5pdGVtLmRhdGEoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkoXCIuZ3JpZC1lbGVtZW50LXRyYXNoXCIpLmFkZENsYXNzKFwiZ3JpZC1hY3RpdmVcIikuZHJvcHBhYmxlKHtcblx0ICAgICAgICAgICAgICAgIGFjY2VwdDogJy5ncmlkLWNvbnRhaW5lcicsXG5cdCAgICAgICAgICAgICAgICBob3ZlckNsYXNzOiAnZ3JpZC1ob3ZlcicsXG5cdCAgICAgICAgICAgICAgICBkcm9wOmZ1bmN0aW9uKGUsdWkpIHtcblx0ICAgICAgICAgICAgICAgIFx0Y29udGFpbmVyPUdSSUQuZ2V0TW9kZWwoKS5nZXRDb250YWluZXJzKCkuZ2V0KG9sZF9jb250YWluZXJfaWQpO1xuXHQgICAgICAgICAgICAgICAgXHRjb250YWluZXJfZGVsZXRlZD10cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSl7XG4gICAgICAgICAgICBcdGpRdWVyeShcIi5ncmlkLWVsZW1lbnQtdHJhc2hcIikucmVtb3ZlQ2xhc3MoJ2dyaWQtYWN0aXZlJyk7XG4gICAgICAgICAgICBcdGlmKGNvbnRhaW5lcl9kZWxldGVkKVxuICAgICAgICAgICAgXHR7XG4gICAgICAgICAgICBcdFx0Y29udGFpbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIFx0fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApe1xuICAgICAgICAgICAgXHRpZihjb250YWluZXJfZGVsZXRlZClyZXR1cm47XG4gICAgICAgICAgICBcdHZhciBjb250YWluZXJ2aWV3ID0gdWkuaXRlbS5hdHRyKFwiZGF0YS1jaWRcIik7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3SW5kZXggPSB1aS5pdGVtLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lcm1vZGVsID0gR1JJRC5nZXRNb2RlbCgpLmdldENvbnRhaW5lcnMoKS5nZXQoY29udGFpbmVydmlldyk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4ID0gR1JJRC5nZXRNb2RlbCgpLmdldENvbnRhaW5lcnMoKS5pbmRleE9mKGNvbnRhaW5lcm1vZGVsKTtcblxuIFx0XHRcdFx0R1JJRC5nZXRNb2RlbCgpLmdldENvbnRhaW5lcnMoKS5tb3ZlKGNvbnRhaW5lcm1vZGVsLCBuZXdJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXHR9LFxuXHQvLyBpbml0aWFsaXplcyBmdW5jdGlvbiB0byBzb3J0IHRoZSBjb250YWluZXJzXG5cdF9pbml0aWFsaXplQm94U29ydGFibGU6IGZ1bmN0aW9uKCl7XG5cdFx0aWYoIUdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwibW92ZS1ib3hcIikgfHwgR1JJRC5sb2NrZWQoKSApIHJldHVybiBmYWxzZTtcblx0XHR2YXIgb2xkX2JveF9pbmRleCxcblx0XHRvbGRfc2xvdF9pZCxcblx0XHRvbGRfY29udGFpbmVyX2lkLFxuXHRcdG5ld19ib3hfaW5kZXgsXG5cdFx0bmV3X3Nsb3RfaWQsXG5cdFx0bmV3X2NvbnRhaW5lcl9pZCxcblx0XHRib3hfZGVsZXRlZCxcblx0XHRib3hfZHVwbGljYXRlZDtcblx0XHRib3hfZGVsZXRlZD1mYWxzZTtcblx0XHRib3hfZHVwbGljYXRlZD1mYWxzZTtcblx0XHRqUXVlcnkodGhpcy5nZXRWaWV3KCkuZWwpLmZpbmQoXCIuZ3JpZC1jb250YWluZXItdHlwZS1jW2RhdGEtcmV1c2VkPWZhbHNlXSAuZ3JpZC1ib3hlcy13cmFwcGVyLCAuZ3JpZC1jb250YWluZXItdHlwZS1zYyAuZ3JpZC1ib3hlcy13cmFwcGVyXCIpLnNvcnRhYmxlKHtcblx0XHRcdGl0ZW1zOiBcIi5ncmlkLWJveFwiLFxuXHRcdFx0aGFuZGxlOiBcIi5ncmlkLWJveC1jb250cm9sc1wiLFxuXHRcdFx0Ly9jYW5jZWw6IFwiLmdyaWQtYm94LWVkaXQsIC5ncmlkLWJveC1kZWxldGVcIixcblx0XHRcdGNvbm5lY3RXaXRoOiBcIi5ncmlkLWNvbnRhaW5lci10eXBlLWNbZGF0YS1yZXVzZWQ9ZmFsc2VdIC5ncmlkLWJveGVzLXdyYXBwZXIsIC5ncmlkLWVsZW1lbnQtdHJhc2hcIixcblx0XHRcdHBsYWNlaG9sZGVyOiBcImdyaWQtYm94LXNvcnQtcGxhY2Vob2xkZXJcIixcblx0XHRcdGZvcmNlUGxhY2Vob2xkZXJTaXplOiB0cnVlLFxuXHRcdFx0ZGlzdGFuY2U6IDEwLFxuXHRcdFx0cmVmcmVzaFBvc2l0aW9uczogdHJ1ZSxcblx0XHRcdGhlbHBlcjogZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQpe1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5KFwiPGRpdiBjbGFzcz0nZHJhZ2dlci1oZWxwZXInPjwvZGl2PlwiKTtcblx0XHRcdH0sXG5cdFx0XHRjdXJzb3JBdDogeyBsZWZ0OiAzMCwgdG9wOjMwIH0sXG5cdFx0XHRzdGFydDogZnVuY3Rpb24oZSwgdWkpe1xuXHRcdFx0XHRib3hfZHVwbGljYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRib3hfZGVsZXRlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdG9sZF9ib3hfaW5kZXggPSB1aS5pdGVtLmluZGV4KCk7XG5cdFx0XHRcdG9sZF9zbG90X2lkID0gdWkuaXRlbS5wYXJlbnRzKFwiLmdyaWQtc2xvdFwiKS5kYXRhKFwiaWRcIik7XG5cdFx0XHRcdG9sZF9jb250YWluZXJfaWQgPSB1aS5pdGVtLnBhcmVudHMoXCIuZ3JpZC1jb250YWluZXJcIikuZGF0YShcImlkXCIpO1xuXG5cdFx0XHRcdEdSSUQubG9nKFtcIlNUQVJUIEJPWCBTT1JUXCIsIG9sZF9ib3hfaW5kZXgsIG9sZF9zbG90X2lkLCBvbGRfY29udGFpbmVyX2lkXSk7XG5cdFx0XHRcdGpRdWVyeShcIi5ncmlkLWVsZW1lbnQtdHJhc2hcIikuYWRkQ2xhc3MoXCJncmlkLWFjdGl2ZVwiKS5kcm9wcGFibGUoe1xuXHRcdFx0XHRcdGFjY2VwdDogJy5ncmlkLXNsb3QgLmdyaWQtYm94Jyxcblx0XHRcdFx0XHRob3ZlckNsYXNzOiAnZ3JpZC1ob3ZlcicsXG5cdFx0XHRcdFx0b3ZlcjogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGJveF9kZWxldGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG91dDogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGJveF9kZWxldGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRkcm9wOmZ1bmN0aW9uKGUsdWkpIHtcblx0XHRcdFx0XHRcdHZhciBib3ggPSBHUklELmdldE1vZGVsKCkuZ2V0Q29udGFpbmVycygpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgICAuZ2V0KG9sZF9jb250YWluZXJfaWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgICAuZ2V0U2xvdHMoKS5nZXQob2xkX3Nsb3RfaWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgICAuZ2V0Qm94KG9sZF9ib3hfaW5kZXgpO1xuXHRcdFx0XHRcdFx0Ym94LmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdGJveF9kZWxldGVkPXRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRqUXVlcnkoXCIuZ3JpZC1lbGVtZW50LWR1cGxpY2F0ZVwiKS5hZGRDbGFzcyhcImdyaWQtYWN0aXZlXCIpLmRyb3BwYWJsZSh7XG5cdFx0XHRcdFx0YWNjZXB0OiAnLmdyaWQtc2xvdCAuZ3JpZC1ib3gnLFxuXHRcdFx0XHRcdGhvdmVyQ2xhc3M6ICdncmlkLWhvdmVyJyxcblx0XHRcdFx0XHRvdmVyOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Ym94X2R1cGxpY2F0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b3V0OiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Ym94X2R1cGxpY2F0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRyb3A6ZnVuY3Rpb24oZSx1aSkge1xuXHRcdFx0XHRcdFx0Ym94X2R1cGxpY2F0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y29uc3QgYm94ID0gR1JJRC5nZXRNb2RlbCgpLmdldENvbnRhaW5lcnMoKVxuXHRcdFx0XHRcdFx0XHQuZ2V0KG9sZF9jb250YWluZXJfaWQpXG5cdFx0XHRcdFx0XHRcdC5nZXRTbG90cygpXG5cdFx0XHRcdFx0XHRcdC5nZXQob2xkX3Nsb3RfaWQpLmdldEJveChvbGRfYm94X2luZGV4KTtcblx0XHRcdFx0XHRcdEdSSUQuZ2V0TW9kZWwoKS5kdXBsaWNhdGVCb3goYm94LG9sZF9ib3hfaW5kZXgrMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRiZWZvcmVTdG9wOiBmdW5jdGlvbihlLCB1aSl7XG5cdFx0XHRcdGpRdWVyeShcIi5ncmlkLWVsZW1lbnQtdHJhc2hcIikucmVtb3ZlQ2xhc3MoXCJncmlkLWFjdGl2ZVwiKTtcblx0XHRcdFx0alF1ZXJ5KFwiLmdyaWQtZWxlbWVudC1kdXBsaWNhdGVcIikucmVtb3ZlQ2xhc3MoXCJncmlkLWFjdGl2ZVwiKTtcblx0XHRcdFx0aWYoYm94X2RlbGV0ZWQgfHwgYm94X2R1cGxpY2F0ZWQpe1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKGUsIHVpKXtcblx0XHRcdFx0bmV3X2NvbnRhaW5lcl9pZCA9IHVpLml0ZW0ucGFyZW50cyhcIi5ncmlkLWNvbnRhaW5lclwiKS5kYXRhKFwiaWRcIik7XG5cdFx0XHRcdG5ld19zbG90X2lkID0gdWkuaXRlbS5wYXJlbnRzKFwiLmdyaWQtc2xvdFwiKS5kYXRhKFwiaWRcIik7XG5cdFx0XHRcdG5ld19ib3hfaW5kZXggPSB1aS5pdGVtLmluZGV4KCk7XG5cblx0XHRcdFx0R1JJRC5sb2coW1wiU1RPUCBCT1ggU09SVFwiLCBvbGRfYm94X2luZGV4LCBvbGRfc2xvdF9pZCwgb2xkX2NvbnRhaW5lcl9pZCwgbmV3X2JveF9pbmRleCwgbmV3X3Nsb3RfaWQsIG5ld19jb250YWluZXJfaWRdKTtcblxuXG5cdFx0XHRcdGlmKG9sZF9jb250YWluZXJfaWQgPT0gbmV3X2NvbnRhaW5lcl9pZCAmJlxuXHRcdFx0XHRcdG9sZF9zbG90X2lkID09IG5ld19zbG90X2lkICYmXG5cdFx0XHRcdFx0b2xkX2JveF9pbmRleCA9PSBuZXdfYm94X2luZGV4KXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYm94ID0gR1JJRC5nZXRNb2RlbCgpXG5cdFx0XHRcdFx0XHRcdFx0LmdldENvbnRhaW5lcnMoKS5nZXQob2xkX2NvbnRhaW5lcl9pZClcblx0XHRcdFx0XHRcdFx0XHQuZ2V0U2xvdHMoKS5nZXQob2xkX3Nsb3RfaWQpXG5cdFx0XHRcdFx0XHRcdFx0LmdldEJveChvbGRfYm94X2luZGV4KTtcblx0XHRcdFx0dmFyIG5ld19zbG90ID0gR1JJRC5nZXRNb2RlbCgpXG5cdFx0XHRcdFx0XHRcdFx0LmdldENvbnRhaW5lcnMoKS5nZXQobmV3X2NvbnRhaW5lcl9pZClcblx0XHRcdFx0XHRcdFx0XHQuZ2V0U2xvdHMoKS5nZXQobmV3X3Nsb3RfaWQpO1xuXG5cdFx0XHRcdEdSSUQuZ2V0TW9kZWwoKS5tb3ZlQm94KGJveCwgbmV3X3Nsb3QsIG5ld19ib3hfaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRmbGFzaDogZnVuY3Rpb24oKXtcblx0XHRHUklELmdyaWR2aWV3LiRlbC5mYWRlSW4oMTAwKS5mYWRlT3V0KDEwMCkuZmFkZUluKDEwMCk7XG5cdH0sXG5cdHN0YXJ0TG9hZGluZzogZnVuY3Rpb24oKXtcblx0XHRjbGVhclRpbWVvdXQoR1JJRC5sb2FkaW5nX2hpZGVfdGltZW91dCk7XG5cdFx0R1JJRC4kbG9hZGluZy5zaG93KCk7XG5cdFx0R1JJRC4kbG9hZGluZy5hZGRDbGFzcyhcImxvYWRpbmdcIik7XG5cblx0fSxcblx0ZmluaXNoTG9hZGluZzogZnVuY3Rpb24oKXtcblx0XHRHUklELiRsb2FkaW5nLnJlbW92ZUNsYXNzKFwibG9hZGluZ1wiKTtcblx0XHRjbGVhclRpbWVvdXQoR1JJRC5sb2FkaW5nX2hpZGVfdGltZW91dCk7XG5cdFx0R1JJRC5sb2FkaW5nX2hpZGVfdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdEdSSUQuJGxvYWRpbmcuaGlkZSgpO1xuXHRcdH0sMTIwMCk7XG5cdH1cblxufTtcblxualF1ZXJ5KGZ1bmN0aW9uKCl7R1JJRC5pbml0KCk7fSk7XG5cblxuIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSdcbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcblxuZXhwb3J0IGZ1bmN0aW9uIEdyaWRBc3luYygpe1xuXG5cdHZhciBzZWxmID0gdGhpcztcblxuXHR0aGlzLmRvbWFpbiA9IGRvY3VtZW50LmdyaWQuYXN5bmMuZG9tYWluO1xuXHR0aGlzLnBhdGggPSBkb2N1bWVudC5ncmlkLmFzeW5jLnBhdGg7XG5cdHRoaXMuYXV0aG9yID0gZG9jdW1lbnQuZ3JpZC5hc3luYy5hdXRob3I7XG5cdHRoaXMudGltZW91dCA9IGRvY3VtZW50LmdyaWQuYXN5bmMudGltZW91dDtcblx0dGhpcy5vYnNlcnZlcnMgPSBbXTtcblxuXHR0aGlzLmJyb3dzZXJfaWRlbnRpZmllcj13aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJncmlkX2Jyb3dzZXJfaWRlbnRpZmllclwiKTtcblxuXHRpZih0aGlzLmJyb3dzZXJfaWRlbnRpZmllcj09bnVsbCkge1xuXHRcdHRoaXMuYnJvd3Nlcl9pZGVudGlmaWVyPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcblx0XHR3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJncmlkX2Jyb3dzZXJfaWRlbnRpZmllclwiLHRoaXMuYnJvd3Nlcl9pZGVudGlmaWVyKTtcblx0fVxuXG5cdHRoaXMubGFzdF90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cblx0dGhpcy5fb25JZGxlSW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdHZhciBkaWZmID0gKHRpbWUgLSBzZWxmLmxhc3RfdGltZSk7XG5cdFx0aWYoZGlmZj49IHRoaXMudGltZW91dCoxMDAwICYmIEdSSUQuYXV0aG9ycy5sZW5ndGg+MCAmJiBHUklELmF1dGhvcnMuaGF2ZUxvY2soKSkge1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGlkbGVfaW50ZXJ2YWw9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcblx0XHRzZWxmLl9vbklkbGVJbnRlcnZhbCgpO1xuXHR9LDEwMDApO1xuXG5cdHRoaXMuX29uQWN0aXZpdHkgPSBmdW5jdGlvbigpIHtcblx0XHRzZWxmLmxhc3RfdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9O1xuXG5cdGpRdWVyeSgnYm9keScpXG5cdFx0Lm9uKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKCl7XG5cdFx0XHRzZWxmLl9vbkFjdGl2aXR5KCk7XG5cdFx0fSlcblx0XHQub24oJ2tleXByZXNzJyxmdW5jdGlvbigpe1xuXHRcdFx0c2VsZi5fb25BY3Rpdml0eSgpO1xuXHRcdH0pO1xuXG5cdC8qKlxuXHQgKiBpbml0IGZ1bmN0aW9uXG5cdCAqL1xuXHR0aGlzLmluaXQgPSBmdW5jdGlvbigpe1xuXHRcdGlmKGRvY3VtZW50LmdyaWQuYXN5bmMuc2VydmljZSAhPSAnJyl7XG5cdFx0XHR0aGlzLnNvY2tldCA9IGlvKGRvY3VtZW50LmdyaWQuYXN5bmMuc2VydmljZSk7XG5cdFx0XHR0aGlzLmluaXRFdmVudHMoKTtcblx0XHR9XG5cdH07XG5cdHRoaXMuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbihvYnNlcnZlcil7XG5cdFx0dGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG5cdH07XG5cdHRoaXMucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbihvYnNlcnZlcil7XG5cdFx0dGhpcy5vYnNlcnZlcnMgPSBfLndpdGhvdXQodGhpcy5vYnNlcnZlcnMsb2JzZXJ2ZXIpO1xuXHR9O1xuXHR0aGlzLm5vdGlmeUFsbCA9IGZ1bmN0aW9uKF9ldmVudCwgZGF0YSl7XG5cdFx0Xy5lYWNoKHRoaXMub2JzZXJ2ZXJzLCBmdW5jdGlvbihfb2JzZXJ2ZXIsIGluZGV4LCBsaXN0KXtcblx0XHRcdGlmKHR5cGVvZiBfb2JzZXJ2ZXJbXCJhc3luY19cIitfZXZlbnRdID09IFwiZnVuY3Rpb25cIilcblx0XHRcdHtcblx0XHRcdFx0X29ic2VydmVyW1wiYXN5bmNfXCIrX2V2ZW50XShkYXRhKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR3JpZCBBc3luYyBzZXJ2ZXIgZXZlbnRzXG5cdCAqL1xuXHR0aGlzLmluaXRFdmVudHMgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMub24oXCJjb25uZWN0XCIsIFwiY29ubmVjdFwiKTtcblx0XHR0aGlzLm9uKFwiZGlzY29ubmVjdFwiLCBcImRpc2Nvbm5lY3RcIik7XG5cdFx0Ly8gYXV0aG9yc1xuXHRcdHRoaXMub24oXCJhdXRob3JzLmxpc3RcIiwgXCJhdXRob3JzX2xpc3RcIik7XG5cdFx0dGhpcy5vbihcImF1dGhvcnMuam9pbmVkXCIsIFwiYXV0aG9yc19qb2luZWRcIik7XG5cdFx0dGhpcy5vbihcImF1dGhvcnMubGVmdFwiLCBcImF1dGhvcnNfbGVmdFwiKTtcblx0XHR0aGlzLm9uKFwiYXV0aG9ycy5tdWx0aXBsZWhpdHNcIixcImF1dGhvcnNfbXVsdGloaXRcIik7XG5cdFx0Ly8gbG9ja2luZ1xuXHRcdHRoaXMub24oXCJsb2NraW5nLmlzTG9ja2VkXCIsIFwibG9ja2luZ19pc19sb2NrZWRcIik7XG5cdFx0dGhpcy5vbihcImxvY2tpbmcubG9ja1JlcXVlc3RlZFwiLCBcImxvY2tpbmdfbG9ja19yZXF1ZXN0ZWRcIik7XG5cdFx0Ly8gcGluZ1xuXHRcdHRoaXMub24oJ3Bpbmcuc2VuZCcsXCJwaW5nX3NlbmRcIik7XG5cdH07XG5cdHRoaXMub24gPSBmdW5jdGlvbihlLCBmKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5zb2NrZXQub24oZSwgZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRzZWxmW2ZdKGRhdGEpO1xuXHRcdH0pO1xuXHR9O1xuXHR0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbihkYXRhKXtcblx0XHR0aGlzLmF1dGhvcnNfam9pbigpO1xuXHR9O1xuXHR0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihkYXRhKXtcblx0XHR0aGlzLm5vdGlmeUFsbChcImRpc2Nvbm5lY3RcIik7XG5cdFx0dGhpcy5ub3RpZnlBbGwoXCJsb2NraW5nX2lzX2xvY2tlZFwiKTtcblx0fTtcblx0LyoqXG5cdCAqIGF1dGhvcnNcblx0ICovXG5cdHRoaXMuYXV0aG9yc19qb2luID0gZnVuY3Rpb24oKXtcblx0XHR0aGlzLnNvY2tldC5lbWl0KFwiYXV0aG9ycy5qb2luXCIsIHtkb21haW46IHRoaXMuZG9tYWluLCBwYXRoOiB0aGlzLnBhdGgsIGF1dGhvcjogdGhpcy5hdXRob3IsIGlkZW50aXR5OnRoaXMuYnJvd3Nlcl9pZGVudGlmaWVyfSk7XG5cdH07XG5cdC8qKlxuXHQgKiBsb2NraW5nXG5cdCAqL1xuXHR0aGlzLmxvY2tpbmdfcmVxdWVzdF9sb2NrID0gZnVuY3Rpb24oKXtcblx0XHR0aGlzLnNvY2tldC5lbWl0KFwibG9ja2luZy5yZXF1ZXN0TG9ja1wiKTtcblx0fTtcblx0dGhpcy5sb2NraW5nX2hhbmRvdmVyID0gZnVuY3Rpb24oaWRlbnRpZmllcil7XG5cdFx0R1JJRC5hdXRob3JzLmVhY2goZnVuY3Rpb24oYXV0aG9yKXtcblx0XHRcdGF1dGhvci5zZXQoXCJyZXF1ZXN0X2xvY2tcIiwgZmFsc2UpO1xuXHRcdH0pO1xuXHRcdHRoaXMuc29ja2V0LmVtaXQoXCJsb2NraW5nLmhhbmRvdmVyXCIsIGlkZW50aWZpZXIpO1xuXHR9O1xuXHR0aGlzLmxvY2tpbmdfZGVueV9oYW5kb3ZlciA9IGZ1bmN0aW9uKGlkZW50aWZpZXIpe1xuXHRcdHRoaXMuc29ja2V0LmVtaXQoXCJsb2NraW5nLmRlbnlIYW5kb3ZlclwiLCBpZGVudGlmaWVyKTtcblx0fTtcblx0LyoqXG5cdCAqIGF1dGhvcnMgZXZlbnRzXG5cdCAqL1xuXHR0aGlzLmF1dGhvcnNfbGlzdCA9IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHRoaXMubm90aWZ5QWxsKFwiYXV0aG9yc19saXN0XCIsZGF0YSk7XG5cdH07XG5cdHRoaXMuYXV0aG9yc19qb2luZWQgPSBmdW5jdGlvbihkYXRhKXtcblx0XHR0aGlzLm5vdGlmeUFsbChcImF1dGhvcnNfam9pbmVkXCIsZGF0YSk7XG5cdH07XG5cdHRoaXMuYXV0aG9yc19sZWZ0ID0gZnVuY3Rpb24oaWQpe1xuXHRcdHRoaXMubm90aWZ5QWxsKFwiYXV0aG9yc19sZWZ0XCIsaWQpO1xuXHR9O1xuXHR0aGlzLmF1dGhvcnNfbXVsdGloaXQgPSBmdW5jdGlvbihjb3VudCkge1xuXHRcdGFsZXJ0KFwiWW91IGhhdmUgb3BlbmVkIHRoaXMgZ3JpZCBvbiBcIitjb3VudCtcIiBicm93c2VyIHdpbmRvd3MuIEFzIHBhcmFsbGVsIGVkaXRpbmcgaXMgbm90IGFsbG93ZWQgeW91J3JlIGxvY2tlZCBvdXQgaGVyZS5cIik7XG5cdH07XG5cdC8qKlxuXHQgKiBsb2NraW5nIGV2ZW50c1xuXHQgKi9cblx0dGhpcy5sb2NraW5nX2lzX2xvY2tlZCA9IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdEdSSUQuYXV0aG9ycy5yZXNldExvY2soKTtcblx0XHRpZihkYXRhLmlzTG9ja2VkKXtcblx0XHRcdEdSSUQuYXV0aG9ycy5zZXRMb2NrKGRhdGEuaWRlbnRpZmllcik7XG5cdFx0fVxuXHRcdHRoaXMubm90aWZ5QWxsKFwibG9ja2luZ19pc19sb2NrZWRcIik7XG5cdH07XG5cdHRoaXMubG9ja2luZ19sb2NrX3JlcXVlc3RlZCA9IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBhdXRob3IgPSBHUklELmF1dGhvcnMuZ2V0KGRhdGEuaWRlbnRpZmllcik7XG5cdFx0aWYoIGF1dGhvciBpbnN0YW5jZW9mIEdyaWRBdXRob3Ipe1xuXHRcdFx0YXV0aG9yLnNldChcInJlcXVlc3RfbG9ja1wiLHRydWUpO1xuXHRcdH1cblx0XHR0aGlzLm5vdGlmeUFsbChcInJlcXVlc3RfbG9ja1wiKTtcblx0fTtcblx0LyoqXG5cdCAqIHBpbmcgZXZlbnRzXG5cdCAqL1xuXHR2YXIgX3BpbmdfdGltZW91dCA9IG51bGw7XG5cdHRoaXMucGluZ19zZW5kID0gZnVuY3Rpb24oKXtcblx0XHRzZWxmLnNvY2tldC5lbWl0KCdwaW5nLnJlY2VpdmVkJyk7XG5cdH07XG5cbn1cblxuXG5cblxuXG5cbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG53aW5kb3cuUmV2aXNpb25zID0gR3JpZEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblx0bW9kZWw6IFJldmlzaW9uLFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihzcGVjKXtcblx0XHRpZighc3BlYyB8fCAhc3BlYy5ncmlkIHx8IShzcGVjLmdyaWQgaW5zdGFuY2VvZiBHcmlkICkpe1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkQ29uc3RydWN0QXJncyBSZXZpc2lvbnMgbmVlZCBhIEdyaWRcIlxuXHRcdH1cblx0XHR0aGlzLmdyaWQgPSBzcGVjLmdyaWQ7XG5cdH0sXG5cdGdldEdyaWRJRDogZnVuY3Rpb24oKXtcblx0XHRHUklELmxvZyh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcy5ncmlkLmdldEdyaWRJRCgpO1xuXHR9LFxuXHRzeW5jOiBmdW5jdGlvbihtZXRob2QsIGNvbGxlY3Rpb24sIG9wdGlvbnMpe1xuXHRcdEdyaWRSZXF1ZXN0LnJldmlzaW9ucyhjb2xsZWN0aW9uLCBvcHRpb25zKTtcblx0fVxufSk7XG5cbi8vIHR5cGUgY29sbGVjdGlvbnNcbndpbmRvdy5Db250YWluZXJUeXBlcyA9IEdyaWRCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cdG1vZGVsOiBDb250YWluZXJUeXBlLFxuXHRzeW5jOiBmdW5jdGlvbihtZXRob2QsIGNvbGxlY3Rpb24sIG9wdGlvbnMpe1xuXHRcdEdyaWRSZXF1ZXN0LmNvbnRhaW5lcnR5cGVzKGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuXHR9XG59KTtcbndpbmRvdy5SZXVzYWJsZUNvbnRhaW5lcnMgPSBHcmlkQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXHRtb2RlbDogQ29udGFpbmVyVHlwZSxcblx0c3luYzogZnVuY3Rpb24obWV0aG9kLCBjb2xsZWN0aW9uLCBvcHRpb25zKXtcblx0XHRHcmlkUmVxdWVzdC5yZXVzYWJsZWNvbnRhaW5lcnMoY29sbGVjdGlvbiwgb3B0aW9ucyk7XG5cdH1cbn0pO1xud2luZG93LkJveFR5cGVzID0gR3JpZEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblx0bW9kZWw6IEJveFR5cGUsXG5cdHN5bmM6IGZ1bmN0aW9uKG1ldGhvZCwgY29sbGVjdGlvbiwgb3B0aW9ucyl7XG5cdFx0R3JpZFJlcXVlc3QuYm94dHlwZXMoY29sbGVjdGlvbiwgb3B0aW9ucyk7XG5cdH1cbn0pO1xud2luZG93LlN0eWxlcyA9IEdyaWRCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cdG1vZGVsOiBTdHlsZVR5cGUsXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNwZWMpe1xuXHRcdGlmICghc3BlYyB8fCAhc3BlYy50eXBlICkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkQ29uc3RydWN0QXJncyBTdHlsZXNcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBzcGVjLnR5cGU7XG5cdH0sXG5cdHN5bmM6IGZ1bmN0aW9uKG1ldGhvZCwgY29sbGVjdGlvbiwgb3B0aW9ucyl7XG5cdFx0R3JpZFJlcXVlc3Quc3R5bGVzKGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuXHR9XG59KTtcblxuLy8gZWxlbWVudCBjb2xsZWN0aW9uc1xud2luZG93LkNvbnRhaW5lcnMgPSBHcmlkQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXHRtb2RlbDogQ29udGFpbmVyLFxuXHRtb3ZlOiBmdW5jdGlvbihjb250YWluZXIsIHRvX2luZGV4KXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0R3JpZFJlcXVlc3QuY29udGFpbmVyLnVwZGF0ZShjb250YWluZXIse1xuXHRcdFx0YWN0aW9uOiBcIm1vdmVcIixcblx0XHRcdGluZGV4OiB0b19pbmRleCxcblx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRzZWxmLnJlbW92ZShjb250YWluZXIpO1xuXHRcdFx0XHRzZWxmLmFkZChjb250YWluZXIsIHthdDp0b19pbmRleH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcbndpbmRvdy5TbG90cyA9IEdyaWRCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cdG1vZGVsOiBTbG90XG59KTtcbndpbmRvdy5Cb3hlcyA9IEdyaWRCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cdG1vZGVsOiBCb3hcbn0pO1xuXG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHR5cGUgbW9kZWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbndpbmRvdy5Db250YWluZXJUeXBlID0gR3JpZEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gICAgZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIF8uZWFjaCggdGhpcy5nZXQoXCJ0eXBlXCIpLnNwbGl0KFwiLVwiKSwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCl7XG4gICAgICAgICAgICBpZih2YWx1ZSA9PSAwIHx8IGkrKyA9PSAwKSByZXR1cm47XG4gICAgICAgICAgICBkaW1lbnNpb24rPSBcIi1cIit2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24uc3Vic3RyaW5nKDEpO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwidHlwZVwiKS5zcGxpdChcIi1cIilbMF07XG4gICAgfVxufSk7XG53aW5kb3cuQm94VHlwZSA9IEdyaWRCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGRlZmF1bHRzOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIGNyaXRlcmlhOiBudWxsLFxuICAgICAgICAgICAgYmx1ZXByaW50czogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRCbHVlcHJpbnRzOiBmdW5jdGlvbigpe1xuICAgICAgICBpZighKHRoaXMuYmx1ZXByaW50cyBpbnN0YW5jZW9mIEdyaWRCb3hCbHVlcHJpbnRzKSl7XG4gICAgICAgICAgICB0aGlzLmJsdWVwcmludHMgPSBuZXcgR3JpZEJveEJsdWVwcmludHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ibHVlcHJpbnRzO1xuICAgIH0sXG4gICAgc2VhcmNoQm94ZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIEdSSUQubG9nKFtcIkJveFR5cGUtPnNlYXJjaEJveGVzXCIsIHRoaXNdKTtcbiAgICAgICAgdmFyIGJsdWVwcmludHMgPSB0aGlzLmdldEJsdWVwcmludHMoKTtcbiAgICAgICAgYmx1ZXByaW50cy5mZXRjaCh7XG4gICAgICAgICAgICB0eXBlOnRoaXMuZ2V0KFwidHlwZVwiKSxcbiAgICAgICAgICAgIGNyaXRlcmlhOiB0aGlzLmdldChcImNyaXRlcmlhXCIpLFxuICAgICAgICAgICAgc2VhcmNoU3RyaW5nOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldChcImJsdWVwcmludHNcIiwgYmx1ZXByaW50cyk7XG4gICAgICAgIHJldHVybiBibHVlcHJpbnRzO1xuICAgIH0sXG4gICAgc2VhcmNoOmZ1bmN0aW9uKHF1ZXJ5LGNyaXRlcmlhKXtcbiAgICAgICAgdmFyIGJsdWVwcmludHMgPSBuZXcgR3JpZEJveEJsdWVwcmludHMoKTtcbiAgICAgICAgYmx1ZXByaW50cy5mZXRjaCh7XG4gICAgICAgICAgICB0eXBlOnRoaXMuZ2V0KFwidHlwZVwiKSxcbiAgICAgICAgICAgIGNyaXRlcmlhOiBjcml0ZXJpYSxcbiAgICAgICAgICAgIHNlYXJjaFN0cmluZzpxdWVyeVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJsdWVwcmludHM7XG4gICAgfVxufSk7XG53aW5kb3cuU3R5bGVUeXBlID0gR3JpZEJhY2tib25lLk1vZGVsLmV4dGVuZCh7fSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXZpc2lvbnMgbW9kZWxcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG53aW5kb3cuUmV2aXNpb24gPSBHcmlkQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihzcGVjKXtcbiAgICAgICAgdGhpcy5zZXQoXCJpZFwiLHNwZWMucmV2aXNpb24pO1xuICAgIH1cbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBNYWluIG1vZGVsLlxuLy8gdGhpcyBpcyB0aGUgd3JhcHBlciBvZiB0aGUgZ3JpZCBlbGVtZW50c1xuLy9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG53aW5kb3cuR3JpZCA9IEdyaWRCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuXHRkZWZhdWx0czogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICAgIC8vIGVuYWJsZSBvciBkaXNhYmxlIGRlYnVnZ2luZyBvdXRwdXRcbiAgICAgICAgICAgIERFQlVHR0lORzogZmFsc2UsXG4gICAgICAgICAgICAvLyB0aGUgc2VydmVyIFVSTFxuICAgICAgICAgICAgU0VSVkVSOiBcIi9ncmlkX2FqYXhfZW5kcG9pbnRcIixcbiAgICAgICAgICAgIC8vIFBhdHRlcm4gZm9yIHByZXZpZXcgVVJMXG4gICAgICAgICAgICBQUkVWSUVXX1VSTDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKycvcHJldmlldycsXG4gICAgICAgICAgICAvLyAwID09IGZhbHNlID09IHVua25vd24sIDEgcHVibGlzaGVkLCAyIGRyYWZ0XG4gICAgICAgICAgICBpc0RyYWZ0OiB0cnVlLFxuICAgICAgICB9XG4gICAgfSxcblx0Z2V0R3JpZElEOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBHUklELklEO1xuXHR9LFxuXHQvLyBpbnZva2VzIHdoZW4gdGhlIG1vZGVsIGlzIGNyZWF0ZWRcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIFx0Ly8gR3JpZCBvYmplY3QgbmVlZHMgYW4gSURcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmlkICkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkQ29uc3RydWN0QXJnc1wiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICBcdHRoaXMuZmV0Y2goe1xuICAgICAgICAgICAgc3VjY2Vzczogc3BlYy5mbl9zdWNjZXNzXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbih0eXBlLCBpbmRleCwgcmV1c2VkKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcih7dHlwZTp0eXBlLCBwYXJlbnQ6dGhpc30pO1xuICAgICAgICBpZih0eXBlb2YgcmV1c2VkID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXQoXCJyZXVzZWRcIiwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLnNldChcInJldXNlZFwiLCByZXVzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5zYXZlKG51bGwse1xuICAgICAgICAgICAgaW5kZXg6aW5kZXgsXG4gICAgICAgICAgICBhY3Rpb246IFwiY3JlYXRlXCIsXG4gICAgICAgICAgICAvLyByZXNvaW5zZSBpcyBhbHdheXMgdW5kZWZpbmVkLCBiZWNhdXNlIHdlIGFyZSBub3QgdXNpbmcgYmFja2JvbmVzIGFqYXggY2FsbFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oY29udGFpbmVyLCByZXNwb25zZSwgb3B0aW9ucyl7XG4gICAgICAgICAgICAgICAgR1JJRC5sb2coXCJDcmVhdGVDb250YWluZXJTdWNjZXNzOjpcIik7XG4gICAgICAgICAgICAgICAgR1JJRC5sb2coW2NvbnRhaW5lciwgcmVzcG9uc2UsIG9wdGlvbnNdKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZENvbnRhaW5lcihjb250YWluZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oY29udGFpbmVyLCByZXNwb25zZSwgb3B0aW9ucyl7XG4gICAgICAgICAgICAgICAgR1JJRC5sb2coXCJDcmVhdGVDb250YWluZXJyb3I6OlwiKTtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhbY29udGFpbmVyLCByZXNwb25zZSwgb3B0aW9uc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGFkZENvbnRhaW5lcjogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpe1xuICAgIFx0aWYoIShlbGVtZW50IGluc3RhbmNlb2YgQ29udGFpbmVyKSkgdGhyb3cgXCJUcnkgdG8gYWRkIGFuIG5vdCBDb250YWluZXIgT2JqZWN0OiBHcmlkLmFkZENvbnRhaW5lclwiO1xuICAgIFx0dmFyIGFyZ3MgPSB7fTtcbiAgICBcdGlmKCB0eXBlb2YgaW5kZXggPT09IFwibnVtYmVyXCIgKSBhcmdzLmF0ID0gaW5kZXg7XG4gICAgXHRlbGVtZW50LnNldChcInBhcmVudFwiLCB0aGlzKTtcbiAgICBcdHRoaXMuZ2V0Q29udGFpbmVycygpLmFkZChlbGVtZW50LCBhcmdzKTtcbiAgICB9LFxuICAgIGFkZFJldXNlQ29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXJ0eXBlLCBpbmRleCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgR3JpZFJlcXVlc3QuZ3JpZC5hZGRSZXVzZUNvbnRhaW5lcihjb250YWluZXJ0eXBlLCBpbmRleCwgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmFkZENvbnRhaW5lcihuZXcgQ29udGFpbmVyKGRhdGEucmVzdWx0KSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRDb250YWluZXJzOiBmdW5jdGlvbigpe1xuICAgIFx0aWYoIXRoaXMuZ2V0KFwiY29sbGVjdGlvbl9jb250YWluZXJzXCIpICl7XG4gICAgXHRcdHRoaXMuc2V0KFwiY29sbGVjdGlvbl9jb250YWluZXJzXCIsIG5ldyBDb250YWluZXJzKCkpO1xuICAgIFx0fVxuICAgIFx0cmV0dXJuIHRoaXMuZ2V0KFwiY29sbGVjdGlvbl9jb250YWluZXJzXCIpO1xuICAgIH0sXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lcnMoKS5hdChpbmRleCk7XG4gICAgfSxcbiAgICBtb3ZlQm94OiBmdW5jdGlvbihib3gsIG5ld19zbG90LCBuZXdfYm94X2luZGV4KXtcbiAgICAgICAgR3JpZFJlcXVlc3QuZ3JpZC5tb3ZlQm94KGJveCwgbmV3X3Nsb3QsIG5ld19ib3hfaW5kZXgsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGNsb25lID0gYm94LmNsb25lKCk7XG4gICAgICAgICAgICBib3guZ2V0U2xvdCgpLmdldEJveGVzKCkucmVtb3ZlKGJveCk7XG4gICAgICAgICAgICBuZXdfc2xvdC5hZGRCb3goY2xvbmUsIG5ld19ib3hfaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXHRkdXBsaWNhdGVCb3g6IGZ1bmN0aW9uKGJveCwgdG9JbmRleCl7XG5cdFx0Y29uc3QgY2xvbmUgPSBib3guY2xvbmUoKTtcblx0XHRHcmlkUmVxdWVzdC5ib3guY3JlYXRlKGNsb25lLCB7XG5cdFx0XHRpbmRleDogdG9JbmRleCxcblx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGNsb25lLnNldER1cGxpY2F0ZWQoKTtcblx0XHRcdFx0Ym94LmdldFNsb3QoKS5hZGRCb3goY2xvbmUsIHRvSW5kZXgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuICAgIGNoZWNrSXNEcmFmdDogZnVuY3Rpb24oKXtcbiAgICAgICAgR3JpZFJlcXVlc3QuZ3JpZC5yZWFkKHRoaXMsIHthY3Rpb246IFwiY2hlY2tkcmFmdFwifSk7XG4gICAgfSxcbiAgICAvLyBoYW5kbGVzIGFsbCBTZXJ2ZXIgY29tbXVuaWNhdGlvblxuICAgIHN5bmM6IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpe1xuICAgICAgICBpZih0eXBlb2YgR3JpZFJlcXVlc3QuZ3JpZFttZXRob2RdID09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgICAgICBHcmlkUmVxdWVzdC5ncmlkW21ldGhvZF0obW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgR1JJRC5sb2coXCJncmlkIHN5bmMgbWV0b2Qgbm90IGRlZmluZWQgXCIrbWV0aG9kKTtcbiAgICAgICAgfVxuXG4gICAgfVxufSk7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBlbGVtZW50IG1vZGVsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxud2luZG93LkNvbnRhaW5lciA9ICBDb250YWluZXJUeXBlLmV4dGVuZCh7XG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicGFyZW50XCIpO1xuICAgIH0sXG5cdGdldEdyaWRJRDogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5nZXQoXCJwYXJlbnRcIikuZ2V0R3JpZElEKCk7XG5cdH0sXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNwZWMpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXRTbG90cyhzcGVjLnNsb3RzKTtcbiAgICAgICAgdGhpcy5zZXQoXCJsZWZ0X3NwYWNlXCIsIHRoaXMuZ2V0U3BhY2UoXCJsZWZ0XCIpKTtcbiAgICAgICAgdGhpcy5zZXQoXCJyaWdodF9zcGFjZVwiLCB0aGlzLmdldFNwYWNlKFwicmlnaHRcIikpO1xuXHR9LFxuICAgIGdldFNwYWNlOiBmdW5jdGlvbihzaWRlKXtcbiAgICAgICAgaWYodHlwZW9mIHNpZGUgPT09IFwidW5kZWZpbmVkXCIpIHNpZGUgPSBcImxlZnRcIjtcbiAgICAgICAgdmFyIHNwYWNlID0gdGhpcy5nZXQoXCJzcGFjZV90b19cIitzaWRlKTtcbiAgICAgICAgaWYoc3BhY2UgPT0gXCJcIiB8fCB0eXBlb2Ygc3BhY2UgPT09IFwidW5kZWZpbmVkXCIgfHwgc3BhY2UgPT09IG51bGwpIHJldHVybiAwO1xuICAgICAgICB2YXIgc3BhY2VfYXJyID0gIHNwYWNlLnNwbGl0KFwiZFwiKTtcbiAgICAgICAgcmV0dXJuIChzcGFjZV9hcnJbMF0vc3BhY2VfYXJyWzFdKTtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJwYXJlbnRcIikuZ2V0Q29udGFpbmVycygpLmluZGV4T2YodGhpcyk7XG4gICAgfSxcbiAgICBzZXRTbG90czogZnVuY3Rpb24oc2xvdHNfYXJyYXkpe1xuICAgICAgICB0aGlzLmdldFNsb3RzKCkucmVzZXQoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2xvdHNfZGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oKS5zcGxpdChcIi1cIik7XG4gICAgICAgIHZhciBpPTA7XG4gICAgICAgIF8uZWFjaChzbG90c19hcnJheSwgZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICAgICAgc2xvdC5kaW1lbnNpb24gPSBzbG90c19kaW1lbnNpb25baSsrXTtcbiAgICAgICAgICAgIHNlbGYuYWRkU2xvdChuZXcgU2xvdChzbG90KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cdGFkZFNsb3Q6IGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KXtcbiAgICBcdGlmKCEoZWxlbWVudCBpbnN0YW5jZW9mIFNsb3QpKSB0aHJvdyBcIlRyeSB0byBhZGQgYW4gbm90IFNsb3QgT2JqZWN0OiBDb250YWluZXIuYWRkU2xvdFwiO1xuICAgIFx0dmFyIGFyZ3MgPSB7fTtcbiAgICBcdGlmKCB0eXBlb2YgaW5kZXggPT09IFwibnVtYmVyXCIgKSBhcmdzLmF0ID0gaW5kZXg7XG4gICAgXHRlbGVtZW50LnNldChcInBhcmVudFwiLCB0aGlzKTtcbiAgICBcdHRoaXMuZ2V0U2xvdHMoKS5hZGQoZWxlbWVudCwgYXJncyk7XG4gICAgfSxcbiAgICBnZXRTbG90czogZnVuY3Rpb24oKXtcbiAgICBcdGlmKCF0aGlzLmdldChcImNvbGxlY3Rpb25fc2xvdHNcIikgKXtcbiAgICBcdFx0dGhpcy5zZXQoXCJjb2xsZWN0aW9uX3Nsb3RzXCIsIG5ldyBTbG90cygpKTtcbiAgICBcdH1cbiAgICBcdHJldHVybiB0aGlzLmdldChcImNvbGxlY3Rpb25fc2xvdHNcIik7XG4gICAgfSxcbiAgICBnZXRTbG90OiBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNsb3RzKCkuYXQoaW5kZXgpO1xuICAgIH0sXG4gICAgLy8gaGFuZGxlcyBhbGwgU2VydmVyIGNvbW11bmljYXRpb25cbiAgICBzeW5jOiBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKXtcbiAgICBcdEdyaWRSZXF1ZXN0LmNvbnRhaW5lclttZXRob2RdKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9XG59KTtcbndpbmRvdy5TbG90ID0gR3JpZEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicGFyZW50XCIpLmdldEdyaWQoKTtcbiAgICB9LFxuXHRnZXRHcmlkSUQ6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KFwicGFyZW50XCIpLmdldEdyaWRJRCgpO1xuXHR9LFxuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicGFyZW50XCIpO1xuICAgIH0sXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNwZWMpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRHUklELmxvZyhcImluaXQgU2xvdFwiKTtcblx0XHRHUklELmxvZyhzcGVjKTtcblx0XHRfLmVhY2goc3BlYy5ib3hlcywgZnVuY3Rpb24oYm94KXtcblx0XHRcdEdSSUQubG9nKFwiYWRkIEJveFwiKTtcblx0XHRcdHNlbGYuYWRkQm94KG5ldyBCb3goYm94KSk7XG5cdFx0fSk7XG5cdH0sXG4gICAgY3JlYXRlQm94OiBmdW5jdGlvbihibHVlcHJpbnQsIGluZGV4KXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIganNvbiA9IGJsdWVwcmludC50b0pTT04oKTtcbiAgICAgICAganNvbi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgYm94ID0gbmV3IEJveChqc29uKTtcbiAgICAgICAgYm94LnNhdmUobnVsbCx7XG4gICAgICAgICAgICBpbmRleDppbmRleCxcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIGlzIGFsd2F5cyB1bmRlZmluZWQsIGJlY2F1c2Ugd2UgYXJlIG5vdCB1c2luZyBiYWNrYm9uZXMgYWpheCBjYWxsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihib3gsIHJlc3BvbnNlLCBvcHRpb25zKXtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhcIkNyZWF0ZWJveFN1Y2Nlc3M6OlwiKTtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhbYm94LCByZXNwb25zZSwgb3B0aW9uc10pO1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkQm94KGJveCwgaW5kZXgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihib3gsIHJlc3BvbnNlLCBvcHRpb25zKXtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhcIkNyZWF0ZWJveHJyb3I6OlwiKTtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhbYm94LCByZXNwb25zZSwgb3B0aW9uc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXHRhZGRCb3g6IGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KXtcblx0XHRpZighKGVsZW1lbnQgaW5zdGFuY2VvZiBCb3gpKSB0aHJvdyBcIlRyeSB0byBhZGQgYW4gbm90IEJveCBPYmplY3Q6IFNsb3QuYWRkQm94XCI7XG4gICAgXHR2YXIgYXJncyA9IHt9O1xuICAgIFx0aWYoIHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIiApIGFyZ3MuYXQgPSBpbmRleDtcbiAgICBcdGVsZW1lbnQuc2V0KFwicGFyZW50XCIsIHRoaXMpO1xuICAgIFx0dGhpcy5nZXRCb3hlcygpLmFkZChlbGVtZW50LCBhcmdzKTtcbiAgICB9LFxuICAgIGdldEJveGVzOiBmdW5jdGlvbigpe1xuICAgIFx0aWYoIXRoaXMuZ2V0KFwiY29sbGVjdGlvbl9ib3hlc1wiKSApe1xuICAgIFx0XHR0aGlzLnNldChcImNvbGxlY3Rpb25fYm94ZXNcIiwgbmV3IEJveGVzKCkpO1xuICAgIFx0fVxuICAgIFx0cmV0dXJuIHRoaXMuZ2V0KFwiY29sbGVjdGlvbl9ib3hlc1wiKTtcbiAgICB9LFxuICAgIGdldEJveDogZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3hlcygpLmF0KGluZGV4KTtcbiAgICB9LFxuICAgIHN5bmM6IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpe1xuICAgIFx0R3JpZFJlcXVlc3Quc2xvdFttZXRob2RdKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9XG59KTtcbndpbmRvdy5Cb3ggPSBHcmlkQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblx0dW5zZXREdXBsaWNhdGVkOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMudW5zZXQoXCJpc0R1cGxpY2F0ZWRcIik7XG5cdH0sXG5cdHNldER1cGxpY2F0ZWQ6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5zZXQoXCJpc0R1cGxpY2F0ZWRcIiwgdHJ1ZSk7XG5cdH0sXG5cdGlzRHVwbGljYXRlZDogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5nZXQoXCJpc0R1cGxpY2F0ZWRcIikgPT09IHRydWU7XG5cdH0sXG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicGFyZW50XCIpLmdldEdyaWQoKTtcbiAgICB9LFxuXHRnZXRHcmlkSUQ6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KFwicGFyZW50XCIpLmdldEdyaWRJRCgpO1xuXHR9LFxuICAgIGdldFNsb3Q6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInBhcmVudFwiKTtcbiAgICB9LFxuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2xvdCgpLmdldENvbnRhaW5lcigpO1xuICAgIH0sXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNwZWMpe1xuXG5cdH0sXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInBhcmVudFwiKS5nZXRCb3hlcygpLmluZGV4T2YodGhpcyk7XG4gICAgfSxcblx0ZHVwbGljYXRlOiBmdW5jdGlvbigpe1xuICAgIFx0dGhpcy5nZXRHcmlkKCkuZHVwbGljYXRlQm94KHRoaXMsIHRoaXMuZ2V0SW5kZXgoKSsxKTtcblx0fSxcbiAgICAvLyBoYW5kbGVzIGFsbCBTZXJ2ZXIgY29tbXVuaWNhdGlvblxuICAgIHN5bmM6IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpe1xuICAgIFx0R3JpZFJlcXVlc3QuYm94W21ldGhvZF0obW9kZWwsIG9wdGlvbnMpO1xuICAgIH1cbn0pO1xuIiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gYWpheCBPYmplY3Rcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG53aW5kb3cuR3JpZEFqYXggPSBmdW5jdGlvbiBHcmlkQWpheChtZXRob2QsIHBhcmFtc19hcnJheSwgc2V0dGluZ3Mpe1xuXHQvLyB0d28gcmVxdWlyZWQgdmFyaWFibGVzXG5cdHZhciBqc29uPXt9O1xuXHRqc29uW1wibWV0aG9kXCJdID0gbWV0aG9kO1xuXHRqc29uW1wicGFyYW1zXCJdID0gcGFyYW1zX2FycmF5O1xuXHRpZih0eXBlb2Ygc2V0dGluZ3MgIT0gXCJvYmplY3RcIil7IHNldHRpbmdzID0ge307IH1cblx0aWYodHlwZW9mIHNldHRpbmdzLmNoZWNrSXNEcmFmdCA9PT0gXCJ1bmRlZmluZWRcIil7IHNldHRpbmdzLmNoZWNrSXNEcmFmdCA9IHRydWU7IH1cblx0Ly8gZGVmYXVsdCBzZXR0aW5nc1xuXHR0aGlzLnNldHRpbmdzID0ge1xuXHRcdHVybDogR1JJRC5TRVJWRVIsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0dHlwZTogJ1BPU1QnLFxuXHRcdGRhdGFUeXBlOiAnanNvbicsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuXHRcdGVycm9yOiBmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3Ipe1xuXHRcdFx0R1JJRC5maW5pc2hMb2FkaW5nKCk7XG4gICAvLyBcdFx0XHRHUklELmxvZyhcIiEtLS0gZXJyb3IgTWV0aG9kOiBcIittZXRob2QpO1xuXHRcdFx0Ly8gR1JJRC5sb2coanFYSFIpO1xuXHRcdFx0Ly8gR1JJRC5sb2codGV4dFN0YXR1cyk7XG5cdFx0XHQvLyBHUklELmxvZyhlcnJvcik7XG5cdFx0XHQvLyBHUklELmxvZyhqc29uKTtcblx0XHRcdC8vIEdSSUQubG9nKFwiLS0tLS0tLS0hXCIpO1xuXHRcdFx0aWYoR1JJRC5ERUJVR0dJTkcpXG5cdFx0XHR7XG5cdFx0XHRcdEdSSUQubG9nKGpxWEhSLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdGpRdWVyeShcIi5lcnJvci1tZXNzYWdlc1wiKS5odG1sKFwiTWV0aG9kOiBcIittZXRob2QrXCI8YnI+XCIrXG5cdFx0XHRcdFx0XHRcIlN0YXR1czogKFwiK2pxWEhSLnN0YXR1cytcIikgLT4gXCIrdGV4dFN0YXR1cytcIjxicj5cIitcblx0XHRcdFx0XHRcdFwiUmVzcG9uc2VUZXh0OiA8YnI+PHByZT5cIitqcVhIUi5yZXNwb25zZVRleHQrXCI8L3ByZT5cIikuc2hvdygpO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIHNldHRpbmdzLmVycm9yX2ZuID09ICdmdW5jdGlvbicgKXtcblx0XHRcdFx0c2V0dGluZ3MuZXJyb3JfZm4oanFYSFIsIHRleHRTdGF0dXMsIGVycm9yKTtcblx0XHRcdH1cbiAgIFx0XHR9LFxuICAgXHRcdGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKGpxWEhSLCBzZXR0aW5ncyl7XG4gICBcdFx0XHRHUklELnN0YXJ0TG9hZGluZygpO1xuICAgXHRcdH0sXG4gICBcdFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSwgdGV4dFN0YXR1cywganFYSFIpe1xuICAgXHRcdFx0R1JJRC5maW5pc2hMb2FkaW5nKCk7XG4gICAvLyBcdFx0XHRHUklELmxvZyhcIiEtLS0gc3VjY2VzcyBNZXRob2Q6IFwiK21ldGhvZCk7XG5cdFx0XHQvLyBHUklELmxvZyhkYXRhKTtcblx0XHRcdC8vIEdSSUQubG9nKHRleHRTdGF0dXMpO1xuXHRcdFx0Ly8gR1JJRC5sb2coanFYSFIpO1xuXHRcdFx0Ly8gR1JJRC5sb2coanNvbik7XG5cdFx0XHQvLyBHUklELmxvZyhcIi0tLS0tLS0tLSFcIik7XG5cdFx0XHRHUklELmxvZyhbXCJBSkFYIFN1Y2Nlc3NcIixzZXR0aW5nc10pO1xuXHRcdFx0aWYodHlwZW9mIHNldHRpbmdzLnN1Y2Nlc3NfZm4gPT0gJ2Z1bmN0aW9uJyApe1xuXHRcdFx0XHRzZXR0aW5ncy5zdWNjZXNzX2ZuKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKTtcblx0XHRcdH1cblx0XHRcdGlmKHNldHRpbmdzLmNoZWNrSXNEcmFmdCA9PSB0cnVlKXtcblx0XHRcdFx0R1JJRC5nZXRNb2RlbCgpLmNoZWNrSXNEcmFmdCgpO1xuXHRcdFx0XHRHUklELnJldmlzaW9ucy5mZXRjaCgpO1xuXHRcdFx0fVxuICAgXHRcdH0sXG4gICBcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoanNvbiksXG4gICBcdFx0d2FpdDogZmFsc2Vcblx0fTtcblx0Ly8gb3ZlcndyaXRlIHNldHRpbmdzXG5cdGpRdWVyeS5leHRlbmQodHJ1ZSx0aGlzLnNldHRpbmdzLCBzZXR0aW5ncyk7XG5cdC8vIHNlbmRzIHRoZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcblx0dGhpcy5zZW5kID0gZnVuY3Rpb24oKXtcblx0XHRqUXVlcnkuYWpheCh0aGlzLnNldHRpbmdzKTtcblx0fTtcblx0aWYoIXRoaXMuc2V0dGluZ3Mud2FpdCl7IHRoaXMuc2VuZCgpOyB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBNZXRob2QtbWFwIHRoYXQgdXNlcyB0aGUgR3JpZEFqYXggb2JqZWN0IGZvciBzZXJ2ZXIgY29tbXVuaWNhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG53aW5kb3cuR3JpZFJlcXVlc3QgPSB7XG5cdGdyaWQ6IHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpe1xuXHRcdFx0R1JJRC5sb2coXCJSZXF1ZXN0IGdyaWQgY3JlYXRlXCIpO1xuXHRcdH0sXG5cdFx0cmVhZDogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucyl7XG5cdFx0XHRHUklELmxvZyhcIkdyaWQtPnVwZGF0ZSBcIitvcHRpb25zLmFjdGlvbik7XG5cdFx0XHRzd2l0Y2gob3B0aW9ucy5hY3Rpb24pe1xuXHRcdFx0XHRjYXNlIFwiY2hlY2tkcmFmdFwiOlxuXHRcdFx0XHRcdC8vIGdldCBzdGF0dXMgZHJhZnQgb2RlciBwdWJsaXNoZWRcblx0XHRcdCAgIFx0XHRuZXcgR3JpZEFqYXgoXCJjaGVja0RyYWZ0U3RhdHVzXCIsW2dyaWQuZ2V0R3JpZElEKCldLHtcblx0XHRcdCAgIFx0XHRcdHN1Y2Nlc3NfZm46IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0ICAgXHRcdFx0XHRncmlkLnNldChcImlzRHJhZnRcIixkYXRhLnJlc3VsdCk7XG5cdFx0XHQgICBcdFx0XHR9LFxuXHRcdFx0ICAgXHRcdFx0Y2hlY2tJc0RyYWZ0OiBmYWxzZVxuXHRcdFx0ICAgXHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGxvYWQgd2hvbGUgZ3JpZFxuXHRcdFx0XHRcdG5ldyBHcmlkQWpheChcblx0XHRcdFx0XHRcdFwibG9hZEdyaWRcIixcblx0XHRcdFx0XHRcdFtncmlkLmdldEdyaWRJRCgpXSxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpZC5hdHRyaWJ1dGVzID0gXy5leHRlbmQoZ3JpZC5hdHRyaWJ1dGVzLCBkYXRhLnJlc3VsdCk7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpZC5nZXRDb250YWluZXJzKCkucmVzZXQoKTtcblx0XHRcdFx0XHRcdFx0XHRfLmVhY2goZGF0YS5yZXN1bHQuY29udGFpbmVyLCBmdW5jdGlvbihjb250YWluZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdEdSSUQubG9nKFwiQWRkIG5ldyBDb250YWluZXJcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHQgZ3JpZC5hZGRDb250YWluZXIobmV3IENvbnRhaW5lcihjb250YWluZXIpKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnN1Y2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLnJldmVydGVkKXtcblx0XHRcdFx0XHRcdFx0XHRcdEdSSUQuZmxhc2goKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0fSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpe1xuXHRcdFx0R1JJRC5sb2coXCJHcmlkLT51cGRhdGVcIik7XG5cdFx0XHRzd2l0Y2gob3B0aW9ucy5hY3Rpb24pe1xuXHRcdFx0XHRjYXNlIFwicmV2ZXJ0RHJhZnRcIjpcblx0XHRcdFx0XHRuZXcgR3JpZEFqYXgoXCJyZXZlcnREcmFmdFwiLCBbZ3JpZC5nZXRHcmlkSUQoKV0se1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRcdEdSSUQubG9nKFtcInJldmVydERyYWZ0IHN1Y2Nlc3NcIixkYXRhXSk7XG5cdFx0XHRcdFx0XHRcdGdyaWQuZmV0Y2goKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNldFRvUmV2aXNpb25cIjpcblx0XHRcdFx0XHR2YXIgcGFyYW1zID0gW2dyaWQuZ2V0R3JpZElEKCksIG9wdGlvbnMucmV2aXNpb25dO1xuXHRcdFx0XHRcdG5ldyBHcmlkQWpheChcInNldFRvUmV2aXNpb25cIixwYXJhbXMse1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRcdEdSSUQubG9nKFwic2V0VG9SZXZpc2lvbiBzdWNjZXNzXCIpO1xuXHRcdFx0XHRcdFx0XHRHUklELmxvZyhkYXRhKTtcblx0XHRcdFx0XHRcdFx0Z3JpZC5mZXRjaCh7cmV2ZXJ0ZWQ6IHRydWV9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBwdWJsaXNoXG5cdFx0XHRcdFx0bmV3IEdyaWRBamF4KFwicHVibGlzaERyYWZ0XCIsWyBncmlkLmdldEdyaWRJRCgpXSwge1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRcdEdSSUQubG9nKFwicHVibGlzaERyYWZ0IHN1Y2Nlc3NcIik7XG5cdFx0XHRcdFx0XHRcdEdSSUQubG9nKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRncmlkLnNldChcImlzRHJhZnRcIiwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bW92ZUJveDogZnVuY3Rpb24oYm94LCBuZXdfc2xvdCwgbmV3X2JveF9pbmRleCwgc3VjY2Vzcyl7XG5cdFx0XHR2YXIgcGFyYW1zID0gW1xuXHRcdFx0XHRcdFx0Ym94LmdldEdyaWRJRCgpLFxuXHRcdFx0XHRcdFx0Ym94LmdldENvbnRhaW5lcigpLmdldChcImlkXCIpLGJveC5nZXRTbG90KCkuZ2V0KFwiaWRcIiksYm94LmdldEluZGV4KCksXG5cdFx0XHRcdFx0XHRuZXdfc2xvdC5nZXRDb250YWluZXIoKS5nZXQoXCJpZFwiKSxuZXdfc2xvdC5nZXQoXCJpZFwiKSxuZXdfYm94X2luZGV4XG5cdFx0XHRcdFx0XTtcblx0XHRcdG5ldyBHcmlkQWpheChcIm1vdmVCb3hcIiwgcGFyYW1zLHtcblx0XHRcdFx0c3VjY2Vzc19mbjogc3VjY2Vzc1xuXHRcdFx0fSlcblx0XHR9LFxuXHRcdGFkZFJldXNlQ29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXJ0eXBlLCBpbmRleCwgc3VjY2Vzcyl7XG5cdFx0XHR2YXIgcGFyYW1zID0gW0dSSUQuSUQsIGluZGV4LCBjb250YWluZXJ0eXBlLmdldChcImlkXCIpXTtcblx0XHRcdG5ldyBHcmlkQWpheCggXCJhZGRSZXVzZUNvbnRhaW5lclwiLCBwYXJhbXMse1xuXHRcdFx0XHRzdWNjZXNzX2ZuOiBzdWNjZXNzXG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpe1xuXHRcdFx0R1JJRC5sb2coXCJHcmlkLT5kZXN0cm95XCIpO1xuXHRcdFx0Ly8gbm8gbmVlZCB0by4gQ01TIGNyZWF0ZXMgYW5kIGRlbGV0ZXMgZ3JpZHNcblx0XHR9XG5cdH0sXG5cdHJldmlzaW9uczogZnVuY3Rpb24ocmV2aXNpb25zLCBvcHRpb25zKXtcblx0XHRHUklELmxvZyhcInJldmlzaW9ucy0+cmVhZFwiKTtcblx0XHR2YXIgcGFnZSA9ICh0eXBlb2Ygb3B0aW9ucy5wYWdlICE9IHR5cGVvZiB1bmRlZmluZWQpPyBvcHRpb25zLnBhZ2U6IDA7XG5cdFx0cmV2aXNpb25zLm5leHRwYWdlID0gLTE7XG5cdFx0bmV3IEdyaWRBamF4KFxuXHRcdFx0XCJnZXRHcmlkUmV2aXNpb25zXCIsXG5cdFx0XHRbcmV2aXNpb25zLmdldEdyaWRJRCgpLCBwYWdlXSxcblx0XHRcdHtcblx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0R1JJRC5sb2coXCJnZXRHcmlkUmV2aXNpb25zIHN1Y2Nlc1wiKTtcblx0XHRcdFx0XHRpZihkYXRhLnJlc3VsdC5sZW5ndGggPiAwKXtcblx0XHRcdFx0XHRcdHJldmlzaW9ucy5uZXh0cGFnZSA9IHBhZ2UrMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocGFnZSA9PSAwKXtcblx0XHRcdFx0XHRcdHJldmlzaW9ucy5yZXNldCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfLmVhY2goZGF0YS5yZXN1bHQsIGZ1bmN0aW9uKHJldmlzaW9uKXtcblx0XHRcdFx0XHRcdHJldmlzaW9ucy5hZGQoIG5ldyBSZXZpc2lvbihyZXZpc2lvbikgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdCAgIFx0Y2hlY2tJc0RyYWZ0OiBmYWxzZVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cdC8vIHR5cGUgbW9kZWwgY2FsbHNcblx0Y29udGFpbmVydHlwZXM6IGZ1bmN0aW9uKGNvbnRhaW5lcnR5cGVzLCBvcHRpb25zKXtcblx0XHRHUklELmxvZyhcIkNvbnRhaW5lcnR5cGVzLT5yZWFkXCIpO1xuXHRcdG5ldyBHcmlkQWpheChcblx0XHRcdFwiZ2V0Q29udGFpbmVyVHlwZXNcIixcblx0XHRcdFtHUklELklEXSxcblx0XHRcdHtcblx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0R1JJRC5sb2coXCJnZXRDb250YWluZXJUeXBlcyBzdWNjZXNcIik7XG5cdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0Y29udGFpbmVydHlwZXMucmVzZXQoKTtcblx0XHRcdFx0XHRfLmVhY2goZGF0YS5yZXN1bHQsIGZ1bmN0aW9uKGNvbnRhaW5lcnR5cGUpe1xuXHRcdFx0XHRcdFx0Y29udGFpbmVydHlwZXMuYWRkKCBuZXcgQ29udGFpbmVyVHlwZShjb250YWluZXJ0eXBlKSApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0ICAgXHRjaGVja0lzRHJhZnQ6IGZhbHNlXG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblx0cmV1c2FibGVjb250YWluZXJzOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBvcHRpb25zKXtcblx0XHRuZXcgR3JpZEFqYXgoXG5cdFx0XHRcImdldFJldXNhYmxlQ29udGFpbmVyc1wiLCBbR1JJRC5JRF0sXG5cdFx0XHR7XG5cdFx0XHRcdHN1Y2Nlc3NfZm46IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRcdEdSSUQubG9nKFtcInJldXNhYmxlY29udGFpbmVycyBkYXRhXCIsIGRhdGFdKTtcblx0XHRcdFx0XHRfLmVhY2goZGF0YS5yZXN1bHQsIGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0Y29sbGVjdGlvbi5hZGQobmV3IENvbnRhaW5lclR5cGUoY29udGFpbmVyKSApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0ICAgXHRjaGVja0lzRHJhZnQ6IGZhbHNlXG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblx0Ym94dHlwZXM6IGZ1bmN0aW9uKGJveHR5cGVzLCBvcHRpb25zKXtcblx0XHRHUklELmxvZyhcIkJveHR5cGVzLT5yZWFkXCIpO1xuXHRcdG5ldyBHcmlkQWpheChcblx0XHRcdFwiZ2V0TWV0YVR5cGVzQW5kU2VhcmNoQ3JpdGVyaWFcIixcblx0XHRcdFtHUklELklEXSxcblx0XHRcdHtcblx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0R1JJRC5sb2coXCJnZXRNZXRhVHlwZXNBbmRTZWFyY2hDcml0ZXJpYSBzdWNjZXNcIik7XG5cdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0Xy5lYWNoKGRhdGEucmVzdWx0LCBmdW5jdGlvbihib3h0eXBlKXtcblx0XHRcdFx0XHRcdGJveHR5cGVzLmFkZCggbmV3IEJveFR5cGUoYm94dHlwZSkgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdCAgIFx0Y2hlY2tJc0RyYWZ0OiBmYWxzZVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cdGJveGJsdWVwcmludHM6IGZ1bmN0aW9uKGJveGJsdWVwcmludHMsb3B0aW9ucyl7XG5cdFx0dmFyIHBhcmFtcyA9IFtHUklELklELG9wdGlvbnMudHlwZSwgb3B0aW9ucy5zZWFyY2hTdHJpbmcsIG9wdGlvbnMuY3JpdGVyaWFdO1xuXHRcdEdSSUQubG9nKFtcImJsdWVwcmludHNcIiwgYm94Ymx1ZXByaW50cywgb3B0aW9ucywgcGFyYW1zXSk7XG5cdFx0bmV3IEdyaWRBamF4KFwiU2VhcmNoXCIscGFyYW1zLHtcblx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0R1JJRC5sb2coW1wiYmx1ZXByaW50cyBzZWFyY2hcIixkYXRhXSk7XG5cdFx0XHRcdFx0Xy5lYWNoKGRhdGEucmVzdWx0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KXtcblx0XHRcdFx0XHRcdHZhciBibHVlcHJpbnQgPSBuZXcgR3JpZEJveEJsdWVwcmludCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRib3hibHVlcHJpbnRzLmFkZChibHVlcHJpbnQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0ICAgXHRjaGVja0lzRHJhZnQ6IGZhbHNlXG5cdFx0fSk7XG5cdH0sXG5cdHN0eWxlczogZnVuY3Rpb24oc3R5bGVzLCBvcHRpb25zKXtcblx0XHRHUklELmxvZyhzdHlsZXMudHlwZStcIlN0eWxlcy0+cmVhZFwiKTtcblx0XHRuZXcgR3JpZEFqYXgoXG5cdFx0XHRcImdldFwiK3N0eWxlcy50eXBlK1wiU3R5bGVzXCIsXG5cdFx0XHRbXSxcblx0XHRcdHtcblx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0R1JJRC5sb2coXCJnZXRcIitzdHlsZXMudHlwZStcIlN0eWxlcyBzdWNjZXNcIik7XG5cdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0c3R5bGVzLnJlc2V0KCk7XG5cdFx0XHRcdFx0Xy5lYWNoKGRhdGEucmVzdWx0LCBmdW5jdGlvbihzdHlsZSl7XG5cdFx0XHRcdFx0XHRzdHlsZXMuYWRkKCBuZXcgU3R5bGVUeXBlKHN0eWxlKSApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0ICAgXHRjaGVja0lzRHJhZnQ6IGZhbHNlXG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblx0cmlnaHRzOiBmdW5jdGlvbihyaWdodHMsIG9wdGlvbnMpe1xuXHRcdEdSSUQubG9nKFwiUmlnaHRzLT5yZWFkXCIpO1xuXHRcdG5ldyBHcmlkQWpheChcblx0XHRcdFwiUmlnaHRzXCIsXG5cdFx0XHRbXSxcblx0XHRcdHtcblx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0R1JJRC5sb2coW1wicmlnaHRzXCIsZGF0YV0pO1xuXHRcdFx0XHRcdF8uZWFjaChkYXRhLnJlc3VsdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCl7XG5cdFx0XHRcdFx0XHRyaWdodHMuc2V0KHZhbHVlLHRydWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vcmlnaHRzLnNldE5vUmlnaHRzKCk7XG5cdFx0XHRcdFx0aWYodHlwZW9mIG9wdGlvbnMgPT0gdHlwZW9mIHt9ICYmIHR5cGVvZiBvcHRpb25zLnN1Y2Nlc3MgPT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3VjY2VzcyhkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHQgICBcdGNoZWNrSXNEcmFmdDogZmFsc2Vcblx0XHRcdH1cblx0XHQpO1xuXHR9LFxuXHQvLyBlbGVtZW50IG1vZGVsIGNhbGxzXG5cdGNvbnRhaW5lcjoge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oY29udGFpbmVyLCBvcHRpb25zKXtcblx0XHRcdEdSSUQubG9nKFwiQ29udGFpbmVyLT5jcmVhdGVcIik7XG5cdFx0XHR2YXIgcGFyYW1zID0gW2NvbnRhaW5lci5nZXRHcmlkSUQoKSwgY29udGFpbmVyLmdldChcInR5cGVcIiksIG9wdGlvbnMuaW5kZXhdO1xuXHRcdFx0R1JJRC5sb2cocGFyYW1zKTtcblx0XHRcdG5ldyBHcmlkQWpheCggXCJhZGRDb250YWluZXJcIiwgcGFyYW1zLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRHUklELmxvZyhcImFkZENvbnRhaW5lciBzdWNjZXNzXCIpO1xuXHRcdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0XHRjb250YWluZXIuc2V0KFwiaWRcIiwgZGF0YS5yZXN1bHQuaWQpO1xuXHRcdFx0XHRcdFx0Y29udGFpbmVyLnNldChcInNsb3RzXCIsIGRhdGEucmVzdWx0LnNsb3RzKTtcblx0XHRcdFx0XHRcdGNvbnRhaW5lci5zZXQoXCJzdHlsZVwiLGRhdGEucmVzdWx0LnN0eWxlKTtcblx0XHRcdFx0XHRcdGNvbnRhaW5lci5zZXQoXCJzcGFjZV90b19yaWdodFwiLGRhdGEucmVzdWx0LnNwYWNlX3RvX3JpZ2h0KTtcblx0XHRcdFx0XHRcdGNvbnRhaW5lci5zZXQoXCJzcGFjZV90b19sZWZ0XCIsZGF0YS5yZXN1bHQuc3BhY2VfdG9fbGVmdCk7XG5cdFx0XHRcdFx0XHRjb250YWluZXIuc2V0U2xvdHMoZGF0YS5yZXN1bHQuc2xvdHMpO1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdWNjZXNzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0cmVhZDogZnVuY3Rpb24oY29udGFpbmVyLCBvcHRpb25zKXtcblx0XHRcdEdSSUQubG9nKFwiQ29udGFpbmVyLT5yZWFkXCIpO1xuXHRcdFx0Ly8gbm8gbmVlZCB0byBhdCB0aGUgbW9tZW50XG5cdFx0fSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgb3B0aW9ucyl7XG5cdFx0XHRHUklELmxvZyhcIkNvbnRhaW5lci0+dXBkYXRlXCIpO1xuXHRcdFx0c3dpdGNoKG9wdGlvbnMuYWN0aW9uKXtcblx0XHRcdFx0Y2FzZSBcInJldXNlXCI6XG5cdFx0XHRcdFx0dmFyIHBhcmFtcyA9W2NvbnRhaW5lci5nZXRHcmlkSUQoKSxjb250YWluZXIuZ2V0KFwiaWRcIiksb3B0aW9ucy5yZXVzZXRpdGxlXTtcblx0XHRcdFx0XHRuZXcgR3JpZEFqYXgoXCJyZXVzZUNvbnRhaW5lclwiLCBwYXJhbXMse1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5lci5zZXQoXCJyZXVzZWRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3VjY2VzcyhkYXRhKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHQgICBcdFx0XHRjaGVja0lzRHJhZnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJtb3ZlXCI6XG5cdFx0XHRcdFx0dmFyIHBhcmFtcyA9IFtjb250YWluZXIuZ2V0R3JpZElEKCksIGNvbnRhaW5lci5nZXQoXCJpZFwiKSwgb3B0aW9ucy5pbmRleF07XG5cdFx0XHRcdFx0bmV3IEdyaWRBamF4KFwibW92ZUNvbnRhaW5lclwiLCBwYXJhbXMse1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mbjogb3B0aW9ucy5zdWNjZXNzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBfLmNsb25lKGNvbnRhaW5lci5hdHRyaWJ1dGVzKTtcblx0XHRcdFx0XHRkZWxldGUoYXR0cmlidXRlcy5zbG90cyk7XG5cdFx0XHRcdFx0ZGVsZXRlKGF0dHJpYnV0ZXMuY29sbGVjdGlvbl9zbG90cyk7XG5cdFx0XHRcdFx0ZGVsZXRlKGF0dHJpYnV0ZXMuY2xhc3Nlcyk7XG5cdFx0XHRcdFx0ZGVsZXRlKGF0dHJpYnV0ZXMucGFyZW50KTtcblx0XHRcdFx0XHR2YXIgcGFyYW1zID1bY29udGFpbmVyLmdldEdyaWRJRCgpLCBjb250YWluZXIuZ2V0KFwiaWRcIiksYXR0cmlidXRlc107XG5cdFx0XHRcdFx0R1JJRC5sb2cocGFyYW1zKTtcblx0XHRcdFx0XHRuZXcgR3JpZEFqYXgoXCJ1cGRhdGVDb250YWluZXJcIiwgcGFyYW1zLFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdWNjZXNzX2ZuOiBmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnN1Y2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXJyb3JfZm46IG9wdGlvbnMuZXJyb3Jcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWxldGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgb3B0aW9ucyl7XG5cdFx0XHR2YXIgcGFyYW1zID0gW2NvbnRhaW5lci5nZXRHcmlkSUQoKSwgY29udGFpbmVyLmdldChcImlkXCIpXTtcblx0XHRcdEdSSUQubG9nKHBhcmFtcyk7XG5cdFx0XHRuZXcgR3JpZEFqYXgoXCJkZWxldGVDb250YWluZXJcIiwgcGFyYW1zLFxuXHRcdFx0XHR7XG5cdFx0XHRcdHN1Y2Nlc3NfZm46IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRcdEdSSUQuZ2V0TW9kZWwoKS5nZXRDb250YWluZXJzKCkucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0XHRcdFx0b3B0aW9ucy5zdWNjZXNzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblx0c2xvdDoge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oc2xvdCwgb3B0aW9ucyl7XG5cdFx0XHRHUklELmxvZyhcInNsb3QtPmNyZWF0ZVwiKTtcblx0XHRcdC8vIG5vIG5lZWQgdG8sIGJlY2F1c2UgdGhleSBhcmUgaGFyZCBjb25uZWN0ZWQgdG8gdGhlaXIgY29udGFpbmVyXG5cdFx0fSxcblx0XHRyZWFkOiBmdW5jdGlvbihzbG90LCBvcHRpb24pe1xuXHRcdFx0R1JJRC5sb2coXCJzbG90LT5yZWFkXCIpO1xuXHRcdFx0Ly8gbm8gbmVlZCB0byBhdCB0aGUgbW9tZW50XG5cdFx0fSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKHNsb3QsIG9wdGlvbnMpe1xuXHRcdFx0R1JJRC5sb2coXCJzbG90LT51cGRhdGVcIik7XG5cdFx0XHR2YXIgcGFyYW1zID0gW3Nsb3QuZ2V0R3JpZElEKCksIHNsb3QuZ2V0KFwicGFyZW50XCIpLmdldChcImlkXCIpLHNsb3QuZ2V0KFwiaWRcIiksc2xvdC5nZXQoXCJzdHlsZVwiKV07XG5cdFx0XHRHUklELmxvZyhwYXJhbXMpO1xuXHRcdFx0bmV3IEdyaWRBamF4KFwidXBkYXRlU2xvdFN0eWxlXCIscGFyYW1zLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRHUklELmxvZyhcInVwZGF0ZVNsb3RTdHlsZSBzdWNjZXNzXCIpO1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdWNjZXNzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0ZGVsZXRlOiBmdW5jdGlvbihzbG90LCBvcHRpb25zKXtcblx0XHRcdEdSSUQubG9nKFwic2xvdC0+ZGVzdHJveVwiKTtcblx0XHRcdC8vIG5vdCBwb3NzaWJsZVxuXHRcdH1cblx0fSxcblx0Ym94OiB7XG5cdFx0Y3JlYXRlOiBmdW5jdGlvbihib3gsIG9wdGlvbnMpe1xuXHRcdFx0R1JJRC5sb2coXCJib3gtPmNyZWF0ZVwiKTtcblx0XHRcdC8vIGNyZWF0ZSBhIG5ldyBib3hcblx0XHRcdHZhciBwYXJhbXMgPSBbXG5cdFx0XHRcdFx0XHRib3guZ2V0R3JpZElEKCksXG5cdFx0XHRcdFx0XHRib3guZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksXG5cdFx0XHRcdFx0XHRib3guZ2V0U2xvdCgpLmdldChcImlkXCIpLFxuXHRcdFx0XHRcdFx0Ly8gaW5kZXggcG9zaXRpb24gaW4gc2xvdFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5pbmRleCxcblx0XHRcdFx0XHRcdGJveC5nZXQoXCJ0eXBlXCIpLFxuXHRcdFx0XHRcdFx0Ym94LmdldChcImNvbnRlbnRcIildO1xuXHRcdFx0bmV3IEdyaWRBamF4KFwiY3JlYXRlQm94XCIscGFyYW1zLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3VjY2Vzc19mbjogZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRHUklELmxvZyhcImNyZWF0ZUJveCBzdWNjZXNzXCIpO1xuXHRcdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0XHRib3guc2V0KFwiaWRcIiwgZGF0YS5yZXN1bHQuaWQpO1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdWNjZXNzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0cmVhZDogZnVuY3Rpb24oYm94LCBvcHRpb24pe1xuXHRcdFx0R1JJRC5sb2coXCJib3gtPnJlYWRcIik7XG5cdFx0XHR2YXIgcGFyYW1zID0gW2JveC5nZXRHcmlkSUQoKSwgYm94LmdldENvbnRhaW5lcigpLmdldChcImlkXCIpLCBib3guZ2V0U2xvdCgpLmdldChcImlkXCIpLCBib3guZ2V0SW5kZXgoKV07XG5cdFx0XHRHUklELmxvZyhwYXJhbXMpO1xuXHRcdFx0bmV3IEdyaWRBamF4KFwiZmV0Y2hCb3hcIixwYXJhbXMse1xuXHRcdFx0XHRzdWNjZXNzX2ZuOiBmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRHUklELmxvZyhcImZldGNoQm94IHN1Y2Nlc3NcIik7XG5cdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0Ym94LmF0dHJpYnV0ZXMgPSBfLmV4dGVuZChib3guYXR0cmlidXRlcywgZGF0YS5yZXN1bHQpO1xuXHRcdFx0XHRcdGJveC50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0XHRcdFx0fSxcblx0XHRcdCAgIFx0Y2hlY2tJc0RyYWZ0OiBmYWxzZVxuXHRcdFx0fSk7XG5cblx0XHR9LFxuXHRcdHVwZGF0ZTogZnVuY3Rpb24oYm94LCBvcHRpb25zKXtcblx0XHRcdEdSSUQubG9nKFwiYm94LT51cGRhdGUgXCIrb3B0aW9ucy5hY3Rpb24pO1xuXHRcdFx0Ly8gbmVlZHMgYSBzd2l0Y2ggZm9yIGRpZmZlcmVudCBhY3Rpb25zXG5cdFx0XHRzd2l0Y2gob3B0aW9ucy5hY3Rpb24pe1xuXHRcdFx0XHRjYXNlIFwicmV1c2VcIjpcblx0XHRcdFx0XHR2YXIgcGFyYW1zID0gW1xuXHRcdFx0XHRcdFx0Ym94LmdldEdyaWRJRCgpLFxuXHRcdFx0XHRcdFx0Ym94LmdldFNsb3QoKS5nZXRDb250YWluZXIoKS5nZXQoXCJpZFwiKSxcblx0XHRcdFx0XHRcdGJveC5nZXRTbG90KCkuZ2V0KFwiaWRcIiksXG5cdFx0XHRcdFx0XHRib3guZ2V0SW5kZXgoKV07XG5cdFx0XHRcdFx0XHRHUklELmxvZyhwYXJhbXMpO1xuXHRcdFx0XHRcdFx0bmV3IEdyaWRBamF4KFwicmV1c2VCb3hcIixwYXJhbXMse1xuXHRcdFx0XHRcdFx0XHRzdWNjZXNzX2ZuOiBmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRcdFx0XHRib3guYXR0cmlidXRlcz1kYXRhLnJlc3VsdDtcblx0XHRcdFx0XHRcdFx0XHRib3gudHJpZ2dlcignY2hhbmdlJyk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHQgICBcdFx0XHRcdGNoZWNrSXNEcmFmdDogZmFsc2Vcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibW92ZVwiOlxuXHRcdFx0XHRcdC8vIGZvciBtb3ZpbmcgdGhlIGJveCBmcm9tIG9uZSB0byBhbm90aGVyIHBvc2l0aW9uXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly91cGRhdGUgYXR0cmlidXRlc1xuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gXy5jbG9uZShib3guYXR0cmlidXRlcyk7XG5cdFx0XHRcdFx0R1JJRC5sb2coXCJhdHRyaWJ1dGVzXCIpO1xuXHRcdFx0XHRcdEdSSUQubG9nKGF0dHJpYnV0ZXMpO1xuXHRcdFx0XHRcdGRlbGV0ZShhdHRyaWJ1dGVzLmNsYXNzZXMpO1xuXHRcdFx0XHRcdGRlbGV0ZShhdHRyaWJ1dGVzLmNvbnRlbnRzdHJ1Y3R1cmUpO1xuXHRcdFx0XHRcdGRlbGV0ZShhdHRyaWJ1dGVzLnBhcmVudCk7XG5cdFx0XHRcdFx0dmFyIHBhcmFtcyA9IFtcblx0XHRcdFx0XHRcdGJveC5nZXRHcmlkSUQoKSxcblx0XHRcdFx0XHRcdGJveC5nZXRTbG90KCkuZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksXG5cdFx0XHRcdFx0XHRib3guZ2V0U2xvdCgpLmdldChcImlkXCIpLFxuXHRcdFx0XHRcdFx0Ym94LmdldEluZGV4KCksXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRHUklELmxvZyhwYXJhbXMpO1xuXHRcdFx0XHRcdG5ldyBHcmlkQWpheChcIlVwZGF0ZUJveFwiLHBhcmFtcyx7XG5cdFx0XHRcdFx0XHRzdWNjZXNzX2ZuOiBmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRcdFx0R1JJRC5sb2coXCJVcGRhdGVCb3ggc3VjY2Vzc1wiKTtcblx0XHRcdFx0XHRcdFx0R1JJRC5sb2coZGF0YSk7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3VjY2VzcygpO1xuXHRcdFx0XHRcdFx0XHRib3guZmV0Y2goKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlbGV0ZTogZnVuY3Rpb24oYm94LCBvcHRpb25zKXtcblx0XHRcdEdSSUQubG9nKFwiYm94LT5kZXN0cm95XCIpO1xuXHRcdFx0dmFyIHBhcmFtcyA9IFsgYm94LmdldEdyaWRJRCgpLCBib3guZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksIGJveC5nZXRTbG90KCkuZ2V0KFwiaWRcIiksIGJveC5nZXRJbmRleCgpIF07XG5cdFx0XHRHUklELmxvZyhwYXJhbXMpO1xuXHRcdFx0bmV3IEdyaWRBamF4KFwicmVtb3ZlQm94XCIsIHBhcmFtcyxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN1Y2Nlc3NfZm46IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRcdFx0R1JJRC5sb2coXCJyZW1vdmVCb3ggc3VjY2Vzc1wiKTtcblx0XHRcdFx0XHRcdEdSSUQubG9nKGRhdGEpO1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdWNjZXNzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufTtcblxuIiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJ1xuaW1wb3J0IGljaCBmcm9tICdpY2FuaGF6J1xuXG53aW5kb3cuR3JpZFZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgIGNsYXNzTmFtZTogJ2dyaWQtd3JhcHBlcicsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lcnNWaWV3ID0gbmV3IENvbnRhaW5lcnNWaWV3KHtjb2xsZWN0aW9uOiB0aGlzLm1vZGVsLmdldENvbnRhaW5lcnMoKSB9KTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChpY2gudHBsX2dyaWQodGhpcy5tb2RlbC50b0pTT04oKSApKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDb250YWluZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyQ29udGFpbmVyczogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy4kZWwuZmluZChcIi5jb250YWluZXJzLXdyYXBwZXJcIikucmVwbGFjZVdpdGgodGhpcy5fY29udGFpbmVyc1ZpZXcucmVuZGVyKCkuZWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn0pO1xuXG53aW5kb3cuQ29udGFpbmVyc1ZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXHR0YWdOYW1lOiAnZGl2Jyxcblx0Y2xhc3NOYW1lOiAnZ3JpZC1jb250YWluZXJzLXdyYXBwZXIgY29udGFpbmVycy13cmFwcGVyJyxcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdhZGQnLHRoaXMucmVuZGVyKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdyZW1vdmUnLHRoaXMucmVuZGVyKTtcblx0fSxcblx0cmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIFx0dmFyIHNlbGYgPSB0aGlzO1xuICAgIFx0dGhpcy4kZWwuZW1wdHkoKTtcbiAgICBcdHRoaXMuY29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGNvbnRhaW5lcil7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVydmlldyA9IG5ldyBDb250YWluZXJWaWV3KHttb2RlbDogY29udGFpbmVyfSk7XG4gICAgXHRcdHNlbGYuJGVsLmFwcGVuZChjb250YWluZXJ2aWV3LnJlbmRlcigpLmVsKTtcbiAgICBcdH0pO1xuICAgICAgICBHUklELl9pbml0aWFsaXplQm94U29ydGFibGUoKTtcbiAgICBcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxud2luZG93LkNvbnRhaW5lclZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXHRjbGFzc05hbWU6ICdncmlkLWNvbnRhaW5lcicsXG4gICAgZXZlbnRzOntcbiAgICAgICAgXCJjbGljayBbcm9sZT10cmFzaF1cIjogXCJzZWxmZGVzdHJ1Y3RcIixcbiAgICAgICAgXCJjbGljayBbcm9sZT1lZGl0XVwiOiBcIm9uRWRpdFwiLFxuICAgICAgICBcImNsaWNrIFtyb2xlPXJldXNlXVwiOiBcIm9uUmV1c2VcIixcbiAgICAgICAgXCJjbGljayBbcm9sZT10b2dnbGVzbG90c3R5bGVzXVwiOiBcIm9uVG9nZ2xlU2xvdFN0eWxlc1wiXG4gICAgfSxcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbGlzdGVuX3RvID0gW1widGl0bGVcIixcInRpdGxldXJsXCIsXCJwcm9sb2dcIixcImVwaWxvZ1wiLCBcInJlYWRtb3JlXCIsIFwicmVhZG1vcmV1cmxcIiwgXCJzdHlsZVwiLCBcInN0eWxlX2xhYmVsXCJdO1xuICAgICAgICBfLmVhY2gobGlzdGVuX3RvLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KXtcbiAgICAgICAgICAgIHNlbGYubGlzdGVuVG8oc2VsZi5tb2RlbCwnY2hhbmdlOicrdmFsdWUsIHNlbGYucmVuZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Nsb3RzVmlldyA9IG5ldyBTbG90c1ZpZXcoe2NvbGxlY3Rpb246IHRoaXMubW9kZWwuZ2V0U2xvdHMoKSB9KTtcblx0fSxcblx0cmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIganNvbiA9IHRoaXMubW9kZWwudG9KU09OKCk7XG5cbiAgICAgICAgdGhpcy4kZWxcbiAgICAgICAgICAgIC5hdHRyKFwiZGF0YS1pZFwiLCBqc29uLmlkKVxuICAgICAgICAgICAgLmF0dHIoXCJkYXRhLXR5cGVcIiwganNvbi50eXBlKVxuICAgICAgICAgICAgLmF0dHIoXCJkYXRhLXN0eWxlXCIsIGpzb24uc3R5bGUpXG4gICAgICAgICAgICAuYXR0cihcImRhdGEtcmV1c2VkXCIsIGpzb24ucmV1c2VkKVxuICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWNpZFwiLCB0aGlzLm1vZGVsLmNpZClcbiAgICAgICAgICAgIC5hdHRyKFwiZGF0YS1zcGFjZS1sZWZ0XCIsIHRoaXMubW9kZWwuZ2V0U3BhY2UoXCJsZWZ0XCIpKVxuICAgICAgICAgICAgLmF0dHIoXCJkYXRhLXNwYWNlLXJpZ2h0XCIsIHRoaXMubW9kZWwuZ2V0U3BhY2UoXCJyaWdodFwiKSk7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdncmlkLWNvbnRhaW5lci10eXBlLScrdGhpcy5tb2RlbC5nZXRUeXBlKCkpO1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnZ3JpZC1jb250YWluZXItJytqc29uLnR5cGUpO1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnZ3JpZC1jb250YWluZXItbGVmdC1zcGFjZS0nK2pzb24uc3BhY2VfdG9fbGVmdCk7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdncmlkLWNvbnRhaW5lci1yaWdodC1zcGFjZS0nK2pzb24uc3BhY2VfdG9fcmlnaHQpO1xuICAgICAgICAvLyBzaG9ydGVuIHRpdGxlLCBwcm9sb2cgYW5kIGVwaWxvZ1xuICAgICAgICB2YXIgY3V0ID0gNjA7XG4gICAgICAgIGlmKGpzb24udGl0bGUpe1xuICAgICAgICAgICAganNvbi50aXRsZV9zaG9ydCA9ICgganNvbi50aXRsZS5sZW5ndGggPD0gY3V0ID8ganNvbi50aXRsZSA6IGpzb24udGl0bGUuc3Vic3RyaW5nKDAsY3V0KStcIiZoZWxsaXA7XCIgKTtcbiAgICAgICAgfVxuICAgICAgICBpZihqc29uLnByb2xvZyl7XG4gICAgICAgICAgICB2YXIgcHJvbG9nID0galF1ZXJ5KFwiPGRpdj5cIitqc29uLnByb2xvZytcIjwvZGl2PlwiKS50ZXh0KCk7XG4gICAgICAgICAgICBqc29uLnByb2xvZ19zaG9ydCA9IFwiPHA+XCIrKCBwcm9sb2cubGVuZ3RoIDw9IGN1dCA/IHByb2xvZyA6IHByb2xvZy5zdWJzdHJpbmcoMCxjdXQpK1wiJmhlbGxpcDtcIiApK1wiPC9wPlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGpzb24uZXBpbG9nKXtcbiAgICAgICAgICAgIHZhciBlcGlsb2cgPSBqUXVlcnkoXCI8ZGl2PlwiK2pzb24uZXBpbG9nK1wiPC9kaXY+XCIpLnRleHQoKTtcbiAgICAgICAgICAgIGpzb24uZXBpbG9nX3Nob3J0ID0gXCI8cD5cIisoIGVwaWxvZy5sZW5ndGggPD0gY3V0ID8gZXBpbG9nIDogZXBpbG9nLnN1YnN0cmluZygwLGN1dCkrXCImaGVsbGlwO1wiICkrXCI8L3A+XCI7XG4gICAgICAgIH1cblxuICAgICAgICBqc29uLnJpZ2h0X2VkaXQgPSBHUklELmdldFJpZ2h0cygpLmdldChcImVkaXQtY29udGFpbmVyXCIpO1xuICAgICAgICBqc29uLnJpZ2h0X2RlbGV0ZSA9IEdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwiZGVsZXRlLWNvbnRhaW5lclwiKTtcblxuICAgICAgICBqc29uLnJpZ2h0X29wdGlvbnMgPSB0cnVlO1xuICAgICAgICBpZighanNvbi5yaWdodF9kZWxldGUgJiYgKCFqc29uLnJpZ2h0X2VkaXQgfHwganNvbi5yZXVzZWQpKXtcbiAgICAgICAgICAgIGpzb24ucmlnaHRfb3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAganNvbi5yaWdodF9tb3ZlID0gR1JJRC5nZXRSaWdodHMoKS5nZXQoXCJtb3ZlLWNvbnRhaW5lclwiKTtcblxuICAgICAgICBqc29uLmlzU2lkZWJhciA9IGpzb24udHlwZS5zdGFydHNXaXRoKFwic1wiKTtcblxuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgIFx0dGhpcy4kZWwuYXBwZW5kKGljaC50cGxfY29udGFpbmVyKCBqc29uKSk7XG5cbiAgICAgICAgdGhpcy4kc2xvdHNfd3JhcHBlciA9IHRoaXMuJGVsLmZpbmQoXCIuZ3JpZC1zbG90cy13cmFwcGVyXCIpO1xuICAgICAgICB0aGlzLiRzbG90c193cmFwcGVyLnJlcGxhY2VXaXRoKHRoaXMuX3Nsb3RzVmlldy5yZW5kZXIoKS5lbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXHR9LFxuICAgIG9uRWRpdDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGVkaXRvcj1uZXcgR3JpZENvbnRhaW5lckVkaXRvcih7bW9kZWw6dGhpcy5tb2RlbH0pO1xuICAgICAgICBHUklELnNob3dFZGl0b3IoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIEdSSUQuJHJvb3RfZWRpdG9yLmh0bWwoZWRpdG9yLnJlbmRlcigpLmVsKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzYXZlRWRpdG9yOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJDb250YWluZXJWaWV3IHNhdmVFZGl0b3JcIiwgc2VsZik7XG4gICAgICAgIGpRdWVyeS5lYWNoKHRoaXMuJGVsLmZpbmQoXCIuZm9ybS12YWxcIiksIGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIHZhciAkdGhpcyA9IGpRdWVyeShlbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBzY29wZSA9ICR0aGlzLmF0dHIoXCJzY29wZVwiKTtcbiAgICAgICAgICAgIHNlbGYubW9kZWwuc2V0KHNjb3BlLCAkdGhpcy52YWwoKSApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zYXZlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgIH0sXG4gICAgb25SZXVzZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJldXNldGl0bGUgPSBwcm9tcHQoXCJCaXR0ZSBnaWIgZWluZW4gVGl0ZWwgZsO8ciBkZW4gQ29udGFpbmVyIGVpblwiKTtcbiAgICAgICAgaWYocmV1c2V0aXRsZSA9PSBcIlwiIHx8IHJldXNldGl0bGUgPT0gZmFsc2UgfHwgcmV1c2V0aXRsZSA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMubW9kZWwuc2F2ZShudWxsLHtcbiAgICAgICAgICAgIHJldXNldGl0bGU6IHJldXNldGl0bGUsXG4gICAgICAgICAgICBhY3Rpb246IFwicmV1c2VcIixcbiAgICAgICAgICAgIHN1Y2Nlc3M6ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25Ub2dnbGVTbG90U3R5bGVzOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnZ3JpZC1jb250YWluZXItc2hvdy1zbG90LXN0eWxlcycpO1xuICAgIH0sXG4gICAgc2VsZmRlc3RydWN0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm1vZGVsLmRlc3Ryb3koe3dhaXQ6dHJ1ZX0pO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuXG53aW5kb3cuU2xvdHNWaWV3ID0gR3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICBjbGFzc05hbWU6ICdncmlkLXNsb3RzLXdyYXBwZXIgc2xvdHMtd3JhcHBlcicsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uLmJpbmQoJ2FkZCcsdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24uYmluZCgncmVtb3ZlJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKHNsb3Qpe1xuICAgICAgICAgICAgdmFyIHNsb3R2aWV3ID0gbmV3IFNsb3RWaWV3KHttb2RlbDogc2xvdH0pO1xuICAgICAgICAgICAgc2xvdHZpZXcuX3BhcmVudFZpZXcgPSBzZWxmO1xuICAgICAgICAgICAgc2VsZi4kZWwuYXBwZW5kKHNsb3R2aWV3LnJlbmRlcigpLmVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG53aW5kb3cuU2xvdFZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgIGNsYXNzTmFtZTogJ2dyaWQtc2xvdCcsXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2JveGVzVmlldyA9IG5ldyBCb3hlc1ZpZXcoe2NvbGxlY3Rpb246IHRoaXMubW9kZWwuZ2V0Qm94ZXMoKSB9KTtcbiAgICAgICAgaWYoR1JJRC5tb2RlICE9IFwiYm94XCIpe1xuICAgICAgICAgICAgdGhpcy5fc2xvdFN0eWxlQ2hhbmdlclZpZXcgPSBuZXcgR3JpZFNsb3RTdHlsZUNoYW5nZXJWaWV3KHttb2RlbDp0aGlzLm1vZGVsfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuXHR9LFxuXHRyZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBqc29uID0gdGhpcy5tb2RlbC50b0pTT04oKTtcbiAgICAgICAgdGhpcy4kZWwuYXR0cihcImRhdGEtc3R5bGVcIiwganNvbi5zdHlsZSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtaWRcIixqc29uLmlkKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZGF0YS1kaW1lbnNpb25cIixqc29uLmRpbWVuc2lvbik7XG5cbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2dyaWQtc2xvdC0nK2pzb24uZGltZW5zaW9uKTtcblxuICAgICAgICB0aGlzLiRlbC5odG1sKGljaC50cGxfc2xvdCggdGhpcy5tb2RlbC50b0pTT04oKSApKTtcbiAgICAgICAgaWYoR1JJRC5tb2RlICE9IFwiYm94XCIpe1xuICAgICAgICAgICAgdGhpcy4kZWwuZmluZChcIi5zdHlsZS1jaGFuZ2VyXCIpLnJlcGxhY2VXaXRoKHRoaXMuX3Nsb3RTdHlsZUNoYW5nZXJWaWV3LnJlbmRlcigpLmVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RTdHlsZUNoYW5nZXJWaWV3LmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm94ZXNWaWV3LnJlbmRlcigpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmJveGVzLXdyYXBwZXJcIikucmVwbGFjZVdpdGgodGhpcy5fYm94ZXNWaWV3LiRlbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxud2luZG93LkJveGVzVmlldyA9IEdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogJ2RpdicsXG4gICAgY2xhc3NOYW1lOiAnZ3JpZC1ib3hlcy13cmFwcGVyIGJveGVzLXdyYXBwZXInLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbi5iaW5kKCdhZGQnLHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgdmFyIGJveHZpZXcgPSBuZXcgQm94Vmlldyh7bW9kZWw6IGJveH0pO1xuICAgICAgICAgICAgYm94dmlldy5fcGFyZW50VmlldyA9IHNlbGY7XG4gICAgICAgICAgICBzZWxmLiRlbC5hcHBlbmQoYm94dmlldy5yZW5kZXIoKS5lbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxud2luZG93LkJveFZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWJveCBib3hcIixcbiAgICBldmVudHM6IHtcbiAgICAgICAgJ2NsaWNrIC5ncmlkLWJveC1lZGl0JyA6ICdlZGl0JyxcbiAgICAgICAgJ2NsaWNrIC5ncmlkLWJveC1kZWxldGUnIDogJ2RlbGV0ZUJveCcsXG4gICAgICAgICdjbGljayAuZ3JpZC1ib3gtZHVwbGljYXRlJyA6ICdkdXBsaWNhdGVCb3gnXG4gICAgfSxcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2Rlc3Ryb3knLCB0aGlzLnNlbGZkZXN0cnVjdCk7XG5cdH0sXG5cdHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGpzb24gPSB0aGlzLm1vZGVsLnRvSlNPTigpO1xuXG4gICAgICAgIHRoaXMuJGVsXG4gICAgICAgIC5hdHRyKFwiZGF0YS1pZFwiLGpzb24uaWQpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10eXBlXCIsanNvbi50eXBlKVxuICAgICAgICAuYXR0cihcImRhdGEtc3R5bGVcIiwganNvbi5zdHlsZSk7XG5cbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoXCJncmlkLWJveC1cIitqc29uLnR5cGUpO1xuXG4gICAgICAgIGlmKGpzb24udHlwZSA9PSBcInJlZmVyZW5jZVwiKXtcbiAgICAgICAgICAgIGpzb24ucmVmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpzb24ucmlnaHRfbW92ZSA9IEdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwibW92ZS1ib3hcIik7XG4gICAgICAgIGpzb24ucmlnaHRfZWRpdCA9IEdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwiZWRpdC1ib3hcIik7XG4gICAgICAgIGpzb24ucmlnaHRfY3JlYXRlID0gR1JJRC5nZXRSaWdodHMoKS5nZXQoXCJjcmVhdGUtYm94XCIpO1xuICAgICAgICBqc29uLnJpZ2h0X2RlbGV0ZSA9IEdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwiZGVsZXRlLWJveFwiKTtcblxuICAgICAgICBqc29uLnJpZ2h0X25vbmUgPSBmYWxzZTtcbiAgICAgICAgaWYoIShqc29uLnJpZ2h0X21vdmUgfHwganNvbi5yaWdodF9lZGl0IHx8IGpzb24ucmlnaHRfZGVsZXRlKSl7XG4gICAgICAgICAgICBqc29uLnJpZ2h0X25vbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIEdSSUQubG9nKFtcInJlbmRlciBib3hcIiwganNvbl0pO1xuXG4gICAgICAgIHZhciBTQ1JJUFRfUkVHRVggPSAvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naTtcblx0XHR3aGlsZSAoU0NSSVBUX1JFR0VYLnRlc3QoanNvbi5odG1sKSkge1xuICAgICAgICAgICAganNvbi5odG1sID0ganNvbi5odG1sLnJlcGxhY2UoU0NSSVBUX1JFR0VYLCBcIlwiKTtcblx0XHR9XG5cdFx0d2hpbGUoU0NSSVBUX1JFR0VYLnRlc3QoanNvbi5lcGlsb2cpKXtcblx0ICAgICAgICBqc29uLmVwaWxvZyA9IGpzb24uZXBpbG9nLnJlcGxhY2UoU0NSSVBUX1JFR0VYLCBcIlwiKTtcblx0XHR9XG5cdFx0d2hpbGUoU0NSSVBUX1JFR0VYLnRlc3QoanNvbi5wcm9sb2cpKXtcblx0XHRcdGpzb24ucHJvbG9nID0ganNvbi5wcm9sb2cucmVwbGFjZShTQ1JJUFRfUkVHRVgsIFwiXCIpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMubW9kZWwuaXNEdXBsaWNhdGVkKCkpe1xuXHRcdCAgICB0aGlzLm1vZGVsLnVuc2V0RHVwbGljYXRlZCgpO1xuXHRcdCAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImlzLWR1cGxpY2F0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbC5odG1sKGljaC50cGxfYm94KCBqc29uICkpO1xuICAgICAgICByZXR1cm4gdGhpcztcblx0fSxcbiAgICBlZGl0OmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBlZGl0b3I9bmV3IEJveEVkaXRvcih7bW9kZWw6dGhpcy5tb2RlbH0pO1xuICAgICAgICBHUklELnNob3dFZGl0b3IoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIEdSSUQuJHJvb3RfZWRpdG9yLmh0bWwoZWRpdG9yLnJlbmRlcigpLmVsKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWxldGVCb3g6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubW9kZWwuZGVzdHJveSgpO1xuICAgIH0sXG4gICAgZHVwbGljYXRlQm94OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm1vZGVsLmR1cGxpY2F0ZSgpO1xuICAgIH0sXG4gICAgc2VsZmRlc3RydWN0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuXG53aW5kb3cuQm94RWRpdG9yID0gR3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBldmVudHM6IHtcbiAgICAgICAgJ2NsaWNrIC5idG4tY2FuY2VsJyA6ICdvbkNhbmNlbCcsXG4gICAgICAgICdjbGljayAuZ3JpZC1lZGl0b3ItbGVnZW5kJyA6ICdvblRvZ2dsZScsXG4gICAgICAgICdjbGljayAuYnRuLXNhdmUnIDogJ29uU2F2ZScsXG4gICAgICAgICdjbGljayAuYnRuLW1ha2UtcmV1c2FibGUnIDogJ29uTWFrZVJldXNhYmxlJ1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgICAgR1JJRC5sb2codGhpcy5tb2RlbC50b0pTT04oKSk7XG4gICAgICAgIHZhciBzdHlsZXM9R1JJRC5nZXRCb3hTdHlsZXMoKS50b0pTT04oKTtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcbiAgICAgICAgXy5lYWNoKHN0eWxlcyxmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGlmKGVsZW0uc2x1Zz09c2VsZi5tb2RlbC5nZXQoXCJzdHlsZVwiKSlcbiAgICAgICAgICAgICAgICBlbGVtLnNlbGVjdGVkPVwic2VsZWN0ZWRcIjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbGVtLnNlbGVjdGVkPVwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRlbC5odG1sKGljaC50cGxfYm94ZWRpdG9yKHtcbiAgICAgICAgICAgICdsYW5nX3ZhbHVlcyc6ZG9jdW1lbnQubGFuZ192YWx1ZXMsXG4gICAgICAgICAgICAnYm94Jzp0aGlzLm1vZGVsLnRvSlNPTigpLFxuICAgICAgICAgICAgJ2JfaW5kZXgnOnRoaXMubW9kZWwuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICdjX2lkJzp0aGlzLm1vZGVsLmdldENvbnRhaW5lcigpLmdldChcImlkXCIpLFxuICAgICAgICAgICAgJ3NfaWQnOnRoaXMubW9kZWwuZ2V0U2xvdCgpLmdldChcImlkXCIpLFxuICAgICAgICAgICAgJ3N0eWxlcyc6c3R5bGVzXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGNvbnRlbnRzdHJ1Y3R1cmU9dGhpcy5tb2RlbC5nZXQoXCJjb250ZW50c3RydWN0dXJlXCIpO1xuICAgICAgICB2YXIgZmllbGRjb250YWluZXI9alF1ZXJ5KHRoaXMuJGVsKS5maW5kKFwiLmR5bmFtaWMtZmllbGRzIC5maWVsZC13cmFwcGVyXCIpO1xuICAgICAgICB2YXIgdmlld3M9W107XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIF8uZWFjaChjb250ZW50c3RydWN0dXJlLGZ1bmN0aW9uKGVsZW0pe1xuICAgICAgICAgICAgdmFyIHR5cGU9ZWxlbS50eXBlO1xuICAgICAgICAgICAgdmFyIHZpZXc9bmV3IGJveEVkaXRvckNvbnRyb2xzW3R5cGVdKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1vZGVsOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RydWN0dXJlOmVsZW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjpzZWxmLm1vZGVsLmdldChcImNvbnRlbnRcIiksXG4gICAgICAgICAgICAgICAgICAgIGJveDpzZWxmLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRwYXRoOlwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICBmaWVsZGNvbnRhaW5lci5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXdzPXZpZXdzO1xuICAgICAgICBqUXVlcnkuZWFjaChqUXVlcnkodGhpcy4kZWwpLmZpbmQoXCIuZm9ybS1odG1sXCIpLCBmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgQ0tFRElUT1IucmVwbGFjZShcbiAgICAgICAgICAgICAgICBlbGVtZW50LHtcbiAgICAgICAgICAgICAgICBjdXN0b21Db25maWcgOiBkb2N1bWVudC5QYXRoVG9Db25maWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZihHUklELmdldEJveFN0eWxlcygpLmxlbmd0aDwxKVxuICAgICAgICB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMuJGVsKS5maW5kKFwiLmJveC1zdHlsZXMtd3JhcHBlclwiKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbkNhbmNlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgR1JJRC5oaWRlQm94RWRpdG9yKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBqUXVlcnkoXCJkaXYjbmV3LWdyaWQtYm94ZWRpdG9yXCIpLmh0bWwoXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvblRvZ2dsZTpmdW5jdGlvbihlKVxuICAgIHtcbiAgICAgICAgalF1ZXJ5KGUudGFyZ2V0KS5zaWJsaW5ncyhcIi5maWVsZC13cmFwcGVyXCIpLnNsaWRlVG9nZ2xlKDMwMCk7XG4gICAgfSxcblxuICAgIG9uTWFrZVJldXNhYmxlOmZ1bmN0aW9uKGUpXG4gICAge1xuICAgICAgICBpZighY29uZmlybShkb2N1bWVudC5sYW5nX3ZhbHVlc1tcImNvbmZpcm0tYm94LXJldXNlXCJdKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLm1vZGVsLnNhdmUobnVsbCx7YWN0aW9uOlwicmV1c2VcIn0pO1xuICAgICAgICBHUklELmhpZGVCb3hFZGl0b3IoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGpRdWVyeShcImRpdiNuZXctZ3JpZC1ib3hlZGl0b3JcIikuaHRtbChcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uU2F2ZTpmdW5jdGlvbihlKVxuICAgIHtcbiAgICAgICAgdmFyIG9iaj17fTtcbiAgICAgICAgXy5lYWNoKHRoaXMudmlld3MsZnVuY3Rpb24odmlldyl7XG4gICAgICAgICAgICBvYmpbdmlldy5tb2RlbC5zdHJ1Y3R1cmUua2V5XT12aWV3LmZldGNoVmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0KCdjb250ZW50JyxvYmopO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgndGl0bGUnLGpRdWVyeSh0aGlzLiRlbCkuZmluZChcIi5mLWItdGl0bGVcIikudmFsKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgndGl0bGV1cmwnLGpRdWVyeSh0aGlzLiRlbCkuZmluZChcIi5mLWItdGl0bGV1cmxcIikudmFsKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgncHJvbG9nJyxDS0VESVRPUi5pbnN0YW5jZXNbXCJmLWItcHJvbG9nXCJdLmdldERhdGEoKSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0KCdlcGlsb2cnLENLRURJVE9SLmluc3RhbmNlc1snZi1iLWVwaWxvZyddLmdldERhdGEoKSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0KCdyZWFkbW9yZScsalF1ZXJ5KHRoaXMuJGVsKS5maW5kKCcuZi1iLXJlYWRtb3JlJykudmFsKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgncmVhZG1vcmV1cmwnLGpRdWVyeSh0aGlzLiRlbCkuZmluZCgnLmYtYi1yZWFkbW9yZXVybCcpLnZhbCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3N0eWxlJyxqUXVlcnkodGhpcy4kZWwpLmZpbmQoXCIuYm94LXN0eWxlcy13cmFwcGVyIHNlbGVjdFwiKS52YWwoKSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2F2ZSgpO1xuICAgICAgICBHUklELmhpZGVCb3hFZGl0b3IoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGpRdWVyeShcImRpdiNuZXctZ3JpZC1ib3hlZGl0b3JcIikuaHRtbChcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbndpbmRvdy5ib3hFZGl0b3JDb250cm9scz17fTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSdcblxud2luZG93LkdyaWRBdXRob3JzID0gR3JpZEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgICBtb2RlbDogR3JpZEF1dGhvcixcbiAgICBhc3luY19hdXRob3JzX2xpc3Q6IGZ1bmN0aW9uKGRhdGEpe1xuICAgIFx0dmFyIHNlbGYgPSB0aGlzO1xuICAgIFx0Xy5lYWNoKGRhdGEsIGZ1bmN0aW9uKGl0ZW0pe1xuICAgIFx0XHRzZWxmLmFkZCh7aWQ6IGl0ZW0uaWRlbnRpZmllciwgbmFtZTogaXRlbS5hdXRob3J9KTtcbiAgICBcdH0pO1xuICAgIH0sXG4gICAgcmVzZXRMb2NrOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oYXV0aG9yKXtcbiAgICAgICAgICAgIGF1dGhvci5zZXQoXCJoYXNfbG9ja1wiLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0TG9jazogZnVuY3Rpb24oaWQpe1xuICAgICAgICB0aGlzLmdldChpZCkuc2V0KFwiaGFzX2xvY2tcIiwgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXZlTG9jazogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy5maW5kV2hlcmUoe2hhc19sb2NrOnRydWV9KSA9PT0gXCJ1bmRlZmluZWRcIik7XG4gICAgfSxcbiAgICBnZXRDb3VudDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gKzEgaXMgdXMgc2VsZlxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgrMTtcbiAgICB9LFxuICAgIGFzeW5jX2F1dGhvcnNfam9pbmVkOiBmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgdGhpcy5hZGQoe2lkOmRhdGEuaWRlbnRpZmllciwgbmFtZTogZGF0YS5hdXRob3J9KTtcbiAgICB9LFxuICAgIGFzeW5jX2F1dGhvcnNfbGVmdDogZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIHRoaXMucmVtb3ZlKHRoaXMuZ2V0KGRhdGEpKTtcbiAgICB9LFxuICAgIGFzeW5jX2Rpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5yZXNldExvY2soKTtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG53aW5kb3cuR3JpZEJveEJsdWVwcmludHMgPSBHcmlkQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXHRtb2RlbDogR3JpZEJveEJsdWVwcmludCxcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oc3BlYyl7XG5cdH0sXG5cdHN5bmM6IGZ1bmN0aW9uKG1ldGhvZCwgY29sbGVjdGlvbiwgb3B0aW9ucyl7XG5cdFx0R3JpZFJlcXVlc3QuYm94Ymx1ZXByaW50cyhjb2xsZWN0aW9uLCBvcHRpb25zKTtcblx0fVxufSk7IiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5cbndpbmRvdy5HcmlkQXV0aG9yID0gR3JpZEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG5cdGRlZmF1bHRzOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB7XG5cdFx0XHRoYXNfbG9jazogZmFsc2UsXG5cdFx0XHRyZXF1ZXN0X2xvY2s6IGZhbHNlXG5cdFx0fVxuXHR9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHNwZWMpe1xuICAgIFx0aWYoICFzcGVjICkgdGhyb3cgXCJObyBwYXJhbWV0ZXJzIGluIGNvbnN0cnVjdG9yIG9mIGF1dGhvclwiO1xuICAgIFx0aWYoICFzcGVjLmlkICkgdGhyb3cgXCJJbnZhbGlkQ29uc3RydWN0QXJncyBHcmlkQXV0aG9yIG5lZWRzIGlkXCI7XG4gICAgXHRpZighc3BlYy5uYW1lICkgdGhyb3cgXCJJbnZhbGlkQ29uc3RydWN0QXJncyBHcmlkQXV0aG9yIG5lZWRzIG5hbWVcIjtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG53aW5kb3cuR3JpZEJveEJsdWVwcmludCA9IEdyaWRCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHNwZWMpe1xuICAgIFx0aWYoIXNwZWMgfHwgIXNwZWMudHlwZSB8fCBzcGVjLnR5cGUgPT0gXCJcIikgdGhyb3cgXCJJbnZhbGlkQ29uc3RydWN0QXJncyBHcmlkQm94Qmx1ZXByaW50OiBuZWVkcyB0eXBlXCI7XG4gICAgXHRpZighc3BlYy5jb250ZW50IHx8IHR5cGVvZiBzcGVjLmNvbnRlbnQgIT0gXCJvYmplY3RcIiApIHRocm93IFwiSW52YWxpZENvbnN0cnVjdEFyZ3MgR3JpZEJveEJsdWVwcmludDogbmVlZHMgY29udGVudFwiO1xuICAgIH1cbn0pOyIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSdcblxud2luZG93LkdyaWRSaWdodHMgPSBHcmlkQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihzcGVjKXtcblxuICAgIH0sXG4gICAgc2V0Tm9SaWdodHM6IGZ1bmN0aW9uKCl7XG4gICAgXHR2YXIgc2VsZiA9IHRoaXM7XG4gICAgXHRfLmVhY2godGhpcy5hdHRyaWJ1dGVzLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KXtcbiAgICBcdFx0c2VsZi5zZXQoa2V5LCBmYWxzZSk7XG4gICAgXHR9KTtcbiAgICB9LFxuICAgIGxvZ1JpZ2h0czogZnVuY3Rpb24oKXtcbiAgICBcdF8uZWFjaCh0aGlzLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3Qpe1xuICAgIFx0XHRHUklELmxvZyhrZXkrXCIgXCIrdmFsdWUpOyAgICBcdFxuICAgIFx0fSk7XG4gICAgfSxcblx0c3luYzogZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucyl7XG5cdFx0R3JpZFJlcXVlc3QucmlnaHRzKG1vZGVsLCBvcHRpb25zKTtcblx0fVxufSk7IiwiZXhwb3J0IGNvbnN0IGhhc0hUTUxFZGl0b3IgPSAoZWxlbWVudCkgPT57XG4gICAgcmV0dXJuIGdldEhUTUxFZGl0b3IoZWxlbWVudClcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhUTUxFZGl0b3IgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBqUXVlcnkoZWxlbWVudCkuZGF0YShcImNrZWRpdG9yXCIpO1xufVxuXG5leHBvcnQgY29uc3QgaW5pdEhUTUxFZGl0b3IgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PntcbiAgICAgICAgaWYoaGFzSFRNTEVkaXRvcihlbGVtZW50KSkge1xuICAgICAgICAgICAgcmVzb2x2ZShnZXRIVE1MRWRpdG9yKGVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZyb20gQ0ROIGluIC90ZW1wbGF0ZXMvZWRpdG9yL2dyaWQudHBsXG4gICAgICAgIHJlc29sdmUoQ0tFRElUT1IucmVwbGFjZShlbGVtZW50LHtcbiAgICAgICAgICAgIGN1c3RvbUNvbmZpZzogZG9jdW1lbnQuUGF0aFRvQ29uZmlnXG4gICAgICAgIH0pKVxuICAgIH0pXG59XG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnXG5cbmJveEVkaXRvckNvbnRyb2xzWydhdXRvY29tcGxldGUnXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3Itd2lkZ2V0LWF1dG9jb21wbGV0ZVwiLFxuICAgIGV2ZW50czp7XG4gICAgICAgIFwia2V5dXAgLmktYXV0b2NvbXBsZXRlXCI6XCJrZXl1cFwiLFxuICAgICAgICBcImNsaWNrIC5zdWdnZXN0aW9uLWxpc3QgbGlcIjpcImxpc3RJdGVtU2VsZWN0ZWRcIixcbiAgICAgICAgXCJjbGljayAuY2FuY2VsXCI6XCJjYW5jZWxTZWxlY3Rpb25cIlxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTpmdW5jdGlvbigpe1xuXG4gICAgfSxcbiAgICByZW5kZXI6ZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGh0bWw9XCI8bGFiZWw+XCIrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwrXCI8L2xhYmVsPlwiO1xuICAgICAgICBsZXQgY2xhc3Nlcz1cImF1dG9jb21wbGV0ZS13cmFwcGVyIGZvcm0tYXV0b2NvbXBsZXRlIGR5bmFtaWMtdmFsdWVcIjtcbiAgICAgICAgbGV0IHJlYWRvbmx5PVwiXCI7XG4gICAgICAgIGxldCBmZXRjaD1mYWxzZTtcblx0ICAgIGNvbnN0IGtleV92YWx1ZSA9IHRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV07XG5cblx0ICAgIGlmKHR5cGVvZiBrZXlfdmFsdWUgIT09IHR5cGVvZiB1bmRlZmluZWQgJiYga2V5X3ZhbHVlICE9PSAnJylcblx0ICAgIHtcbiAgICAgICAgICAgIGNsYXNzZXMrPVwiIGxvY2tlZFwiO1xuICAgICAgICAgICAgcmVhZG9ubHk9XCJyZWFkb25seT1yZWFkb25seVwiO1xuICAgICAgICAgICAgZmV0Y2g9dHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBodG1sKz1cIjxkaXYgY2xhc3M9J1wiK2NsYXNzZXMrXCInPjxpbnB1dCB0eXBlPXRleHQgY2xhc3M9J2Zvcm0tdGV4dCBhdXRvY29tcGxldGUgaS1hdXRvY29tcGxldGUnIFwiK3JlYWRvbmx5K1wiLz5cIjtcbiAgICAgICAgaHRtbCs9XCI8ZGl2IGNsYXNzPSdsb2FkaW5nJz48L2Rpdj5cIjtcbiAgICAgICAgaHRtbCs9XCI8ZGl2IGNsYXNzPSdjYW5jZWwgaWNvbi1jYW5jZWwnPjwvZGl2PlwiO1xuICAgICAgICBodG1sKz1cIjx1bCBjbGFzcz0nc3VnZ2VzdGlvbi1saXN0Jz48L3VsPlwiO1xuICAgICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICAgICAgICBpZihmZXRjaClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy4kZWwuZmluZChcIi5sb2FkaW5nXCIpLmFkZENsYXNzKFwiZ29cIik7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIikuZGF0YShcImtleVwiLGtleV92YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBib3g9dGhpcy5tb2RlbC5ib3g7XG4gICAgICAgICAgICBjb25zdCBzZWxmPXRoaXM7XG4gICAgICAgICAgICBuZXcgR3JpZEFqYXgoXCJ0eXBlQWhlYWRHZXRUZXh0XCIsW2JveC5nZXRHcmlkKCkuZ2V0R3JpZElEKCksYm94LmdldENvbnRhaW5lcigpLmdldChcImlkXCIpLGJveC5nZXRTbG90KCkuZ2V0KFwiaWRcIiksYm94LmdldEluZGV4KCksdGhpcy5tb2RlbC5wYXJlbnRwYXRoK3RoaXMubW9kZWwuc3RydWN0dXJlLmtleSxrZXlfdmFsdWVdLHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzX2ZuOmZ1bmN0aW9uKGRhdGEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiRlbC5maW5kKFwiLmxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJnb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcImlucHV0LmktYXV0b2NvbXBsZXRlXCIpLnZhbChkYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmZXRjaFZhbHVlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIikuZGF0YShcImtleVwiKTtcbiAgICB9LFxuICAgIGtleXVwOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoZS53aGljaD09MTMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbSh0aGlzLiRlbC5maW5kKFwiLnN1Z2dlc3Rpb24tbGlzdCBsaVwiKS5maXJzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaD10aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIikudmFsKCk7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmxvYWRpbmdcIikuYWRkQ2xhc3MoXCJnb1wiKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNlYXJjaGluZyk7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHNlbGYuZG9TZWFyY2goc2VhcmNoKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRvU2VhcmNoOiBmdW5jdGlvbihzZWFyY2gpe1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgYm94PXRoaXMubW9kZWwuYm94O1xuICAgICAgICBuZXcgR3JpZEFqYXgoXCJ0eXBlQWhlYWRTZWFyY2hcIixbYm94LmdldEdyaWQoKS5nZXRHcmlkSUQoKSxib3guZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksYm94LmdldFNsb3QoKS5nZXQoXCJpZFwiKSxib3guZ2V0SW5kZXgoKSx0aGlzLm1vZGVsLnBhcmVudHBhdGgrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5LHNlYXJjaF0se1xuICAgICAgICAgICAgc3VjY2Vzc19mbjpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgICAgICBzZWxmLiRlbC5maW5kKFwiLnN1Z2dlc3Rpb24tbGlzdFwiKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhLnJlc3VsdCxmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcIi5zdWdnZXN0aW9uLWxpc3RcIikuYXBwZW5kKGpRdWVyeShcIjxsaS8+XCIpLnRleHQoZWxlbS52YWx1ZSkuYXR0cihcImRhdGEta2V5XCIsZWxlbS5rZXkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLiRlbC5maW5kKFwiLmxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJnb1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZWxlY3RJdGVtOmZ1bmN0aW9uKCRpdGVtKXtcbiAgICAgICAgY29uc3Qga2V5X3ZhbHVlPSRpdGVtLmRhdGEoXCJrZXlcIik7XG4gICAgICAgIGNvbnN0IG5hbWU9JGl0ZW0udGV4dCgpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmF1dG9jb21wbGV0ZS13cmFwcGVyXCIpLmFkZENsYXNzKFwibG9ja2VkXCIpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIilcbiAgICAgICAgICAgIC52YWwobmFtZSlcbiAgICAgICAgICAgIC5hdHRyKFwicmVhZG9ubHlcIixcInJlYWRvbmx5XCIpXG4gICAgICAgICAgICAuZGF0YShcImtleVwiLGtleV92YWx1ZSk7XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuc3VnZ2VzdGlvbi1saXN0XCIpLmVtcHR5KCk7XG4gICAgfSxcbiAgICBsaXN0SXRlbVNlbGVjdGVkOmZ1bmN0aW9uKGUpe1xuICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oalF1ZXJ5KGUudGFyZ2V0KSk7XG4gICAgfSxcbiAgICBjYW5jZWxTZWxlY3Rpb246ZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuYXV0b2NvbXBsZXRlLXdyYXBwZXJcIikucmVtb3ZlQ2xhc3MoXCJsb2NrZWRcIik7XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCJpbnB1dC5pLWF1dG9jb21wbGV0ZVwiKVxuICAgICAgICAgICAgLmRhdGEoXCJrZXlcIixcIlwiKVxuICAgICAgICAgICAgLnJlbW92ZUF0dHIoXCJyZWFkb25seVwiKVxuICAgICAgICAgICAgLnZhbChcIlwiKTtcbiAgICAgICAgdGhpcy5vbGRfc2VhcmNoX3N0cmluZz1cIlwiO1xuICAgIH1cbn0pO1xuIiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJ1xuXG5ib3hFZGl0b3JDb250cm9sc1snYXV0b2NvbXBsZXRlLXdpdGgtbGlua3MnXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3ItYXV0b2NvbXBsZXRlLXdpdGgtbGlua3NcIixcbiAgICBldmVudHM6e1xuICAgICAgICBcImtleXVwIC5pLWF1dG9jb21wbGV0ZVwiOlwia2V5dXBcIixcbiAgICAgICAgXCJjbGljayAuc3VnZ2VzdGlvbi1saXN0IGxpXCI6XCJsaXN0SXRlbVNlbGVjdGVkXCIsXG4gICAgICAgIFwiY2xpY2sgLmNhbmNlbFwiOlwiY2FuY2VsU2VsZWN0aW9uXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBodG1sPVwiPGxhYmVsPlwiK3RoaXMubW9kZWwuc3RydWN0dXJlLmxhYmVsK1wiPC9sYWJlbD5cIjtcbiAgICAgICAgbGV0IGNsYXNzZXM9XCJhdXRvY29tcGxldGUtd3JhcHBlciBmb3JtLWF1dG9jb21wbGV0ZSBkeW5hbWljLXZhbHVlXCI7XG4gICAgICAgIGxldCByZWFkb25seT1cIlwiO1xuICAgICAgICBsZXQgZmV0Y2g9ZmFsc2U7XG5cdCAgICBjb25zdCBrZXlfdmFsdWUgPSB0aGlzLm1vZGVsLmNvbnRhaW5lclt0aGlzLm1vZGVsLnN0cnVjdHVyZS5rZXldO1xuXHQgICAgaWYodHlwZW9mIGtleV92YWx1ZSAhPT0gdHlwZW9mIHVuZGVmaW5lZCAmJiBrZXlfdmFsdWUgIT09ICcnKVxuXHQgICAge1xuICAgICAgICAgICAgY2xhc3Nlcys9XCIgbG9ja2VkXCI7XG4gICAgICAgICAgICByZWFkb25seT1cInJlYWRvbmx5XCI7XG4gICAgICAgICAgICBmZXRjaD10cnVlO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwrPVwiPGRpdiBjbGFzcz0nXCIrY2xhc3NlcytcIic+XCI7XG4gICAgICAgIGh0bWwrPVwiPGlucHV0IHR5cGU9dGV4dCBjbGFzcz0nZm9ybS10ZXh0IGF1dG9jb21wbGV0ZSBpLWF1dG9jb21wbGV0ZScgXCIrcmVhZG9ubHkrXCIvPlwiO1xuICAgICAgICBodG1sKz1cIjxkaXYgY2xhc3M9J2NhbmNlbCc+PHNwYW4gY2xhc3M9J2ljb24tY2FuY2VsJz48L3NwYW4+PC9kaXY+XCI7XG4gICAgICAgIGh0bWwrPVwiPHVsIGNsYXNzPSdzdWdnZXN0aW9uLWxpc3QnPjwvdWw+XCI7XG5cblx0XHRodG1sKz0nPHAgY2xhc3M9XCJsaW5rc1wiPic7XG4gICAgICAgIGh0bWwrPSAgJzxhIGNsYXNzPVwiZW1wdHlcIiBkYXRhLXJhdz1cIicrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUuZW1wdHl1cmwrJ1wiIGhyZWY9XCInK3RoaXMubW9kZWwuc3RydWN0dXJlLmVtcHR5dXJsKydcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nK3RoaXMubW9kZWwuc3RydWN0dXJlLmVtcHR5bGlua3RleHQrJzwvYT4nO1xuXHRcdGh0bWwrPVx0JzxhIGNsYXNzPVwiZnVsbFwiIGRhdGEtcmF3PVwiJyt0aGlzLm1vZGVsLnN0cnVjdHVyZS51cmwrJ1wiIGhyZWY9XCJcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nK3RoaXMubW9kZWwuc3RydWN0dXJlLmxpbmt0ZXh0Kyc8L2E+Jztcblx0XHRodG1sKz0nPC9wPic7XG4gICAgICAgIGh0bWwrPSBcIjwvZGl2PlwiO1xuXG4gICAgICAgIGpRdWVyeSh0aGlzLiRlbCkuaHRtbChodG1sKTtcbiAgICAgICAgaWYoZmV0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCJpbnB1dC5pLWF1dG9jb21wbGV0ZVwiKS5kYXRhKFwia2V5XCIsa2V5X3ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGJveD10aGlzLm1vZGVsLmJveDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGY9dGhpcztcbiAgICAgICAgICAgIG5ldyBHcmlkQWpheChcInR5cGVBaGVhZEdldFRleHRcIixbYm94LmdldEdyaWQoKS5nZXRHcmlkSUQoKSxib3guZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksYm94LmdldFNsb3QoKS5nZXQoXCJpZFwiKSxib3guZ2V0SW5kZXgoKSx0aGlzLm1vZGVsLnBhcmVudHBhdGgrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5LGtleV92YWx1ZV0se1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NfZm46ZnVuY3Rpb24oZGF0YSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGVsLmZpbmQoXCJpbnB1dC5pLWF1dG9jb21wbGV0ZVwiKS52YWwoZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIGNvbnN0ICRsaW5rVXJsPXRoaXMuJGVsLmZpbmQoXCJhLmZ1bGxcIik7XG5cdCAgICAgICAgJGxpbmtVcmwuYXR0cignaHJlZicsJGxpbmtVcmwuZGF0YSgncmF3JykucmVwbGFjZSgnJScsa2V5X3ZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmZXRjaFZhbHVlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIikuZGF0YShcImtleVwiKTtcbiAgICB9LFxuXG4gICAga2V5dXA6ZnVuY3Rpb24oZSkge1xuICAgICAgICBjb25zdCAkaW5wdXQgPSB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIik7XG4gICAgICAgIGlmKHR5cGVvZiAkaW5wdXQuYXR0cigncmVhZG9ubHknKSAhPT0gJ3VuZGVmaW5lZCcgfHwgJGlucHV0LmF0dHIoJ3JlYWRvbmx5JykgPT09IGZhbHNlICkgcmV0dXJuO1xuICAgICAgICBpZihlLndoaWNoPT09MTMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbSh0aGlzLiRlbC5maW5kKFwiLnN1Z2dlc3Rpb24tbGlzdCBsaVwiKS5maXJzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaD10aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIikudmFsKCk7XG4gICAgICAgICAgICBpZihzZWFyY2g9PXRoaXMub2xkX3NlYXJjaF9zdHJpbmcpcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2VsZj10aGlzO1xuXG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmxvYWRpbmdcIikuc2hvdygpO1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zZWFyY2hpbmcpO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgc2VsZi5kb1NlYXJjaChzZWFyY2gpO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG5cblxuICAgICAgICB9XG4gICAgfSxcbiAgICBkb1NlYXJjaDogZnVuY3Rpb24oc2VhcmNoKXtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJveD10aGlzLm1vZGVsLmJveDtcbiAgICAgICAgbmV3IEdyaWRBamF4KFwidHlwZUFoZWFkU2VhcmNoXCIsW2JveC5nZXRHcmlkKCkuZ2V0R3JpZElEKCksYm94LmdldENvbnRhaW5lcigpLmdldChcImlkXCIpLGJveC5nZXRTbG90KCkuZ2V0KFwiaWRcIiksYm94LmdldEluZGV4KCksdGhpcy5tb2RlbC5wYXJlbnRwYXRoK3RoaXMubW9kZWwuc3RydWN0dXJlLmtleSxzZWFyY2hdLHtcbiAgICAgICAgICAgIHN1Y2Nlc3NfZm46ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgc2VsZi5vbGRfc2VhcmNoX3N0cmluZz1zZWFyY2g7XG4gICAgICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcIi5zdWdnZXN0aW9uLWxpc3RcIikuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBfLmVhY2goZGF0YS5yZXN1bHQsZnVuY3Rpb24oZWxlbSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGVsLmZpbmQoXCIuc3VnZ2VzdGlvbi1saXN0XCIpLmFwcGVuZChqUXVlcnkoXCI8bGkvPlwiKS50ZXh0KGVsZW0udmFsdWUpLmF0dHIoXCJkYXRhLWtleVwiLGVsZW0ua2V5KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcIi5sb2FkaW5nXCIpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZWxlY3RJdGVtOmZ1bmN0aW9uKCRpdGVtKXtcbiAgICAgICAgY29uc3Qga2V5X3ZhbHVlPSRpdGVtLmRhdGEoXCJrZXlcIik7XG4gICAgICAgIGNvbnN0IG5hbWU9JGl0ZW0udGV4dCgpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmF1dG9jb21wbGV0ZS13cmFwcGVyXCIpLmFkZENsYXNzKFwibG9ja2VkXCIpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIilcbiAgICAgICAgICAgIC52YWwobmFtZSlcbiAgICAgICAgICAgIC5hdHRyKFwicmVhZG9ubHlcIixcInJlYWRvbmx5XCIpXG4gICAgICAgICAgICAuZGF0YShcImtleVwiLGtleV92YWx1ZSk7XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuc3VnZ2VzdGlvbi1saXN0XCIpLmVtcHR5KCk7XG4gICAgICAgIGNvbnN0ICRsaW5rVXJsPXRoaXMuJGVsLmZpbmQoXCJhLmZ1bGxcIik7XG4gICAgICAgICRsaW5rVXJsLmF0dHIoJ2hyZWYnLCRsaW5rVXJsLmRhdGEoJ3JhdycpLnJlcGxhY2UoJyUnLGtleV92YWx1ZSkpO1xuICAgIH0sXG4gICAgbGlzdEl0ZW1TZWxlY3RlZDpmdW5jdGlvbihlKXtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGpRdWVyeShlLnRhcmdldCkpO1xuICAgIH0sXG4gICAgY2FuY2VsU2VsZWN0aW9uOmZ1bmN0aW9uKGUpe1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmF1dG9jb21wbGV0ZS13cmFwcGVyXCIpLnJlbW92ZUNsYXNzKFwibG9ja2VkXCIpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIilcbiAgICAgICAgICAgIC5kYXRhKFwia2V5XCIsXCJcIilcbiAgICAgICAgICAgIC5yZW1vdmVBdHRyKFwicmVhZG9ubHlcIilcbiAgICAgICAgICAgIC52YWwoXCJcIik7XG4gICAgICAgIHRoaXMub2xkX3NlYXJjaF9zdHJpbmc9XCJcIjtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG5ib3hFZGl0b3JDb250cm9sc1snY2hlY2tib3gnXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3Itd2lkZ2V0LWNoZWNrYm94XCIsXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnN0IHZhbHVlPXRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV07XG4gICAgICAgIGxldCBjaGVja2VkPSAodmFsdWUpID8gJ2NoZWNrZWQ9Y2hlY2tlZCcgOiAnJztcbiAgICAgICAgY29uc3QgaHRtbD1cIjxsYWJlbD48aW5wdXQgdHlwZT0nY2hlY2tib3gnIFwiK2NoZWNrZWQrXCIgLz4gXCIrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwrXCI8L2xhYmVsPlwiO1xuICAgICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZldGNoVmFsdWU6ZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoXCJpbnB1dFt0eXBlPWNoZWNrYm94XVwiKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgIH1cbn0pOyIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcblxuYm94RWRpdG9yQ29udHJvbHNbJ2ZpbGUnXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXHRjbGFzc05hbWU6IFwiZ3JpZC1lZGl0b3Itd2lkZ2V0IGdyaWQtZWRpdG9yLXdpZGdldC1maWxlXCIsXG4gICAgaW5pdGlhbGl6ZTpmdW5jdGlvbigpe1xuXG4gICAgfSxcbiAgICByZW5kZXI6ZnVuY3Rpb24oKXtcbiAgICBcdHZhciAkID0galF1ZXJ5O1xuICAgIFx0dmFyIHZhbCA9IHRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV07XG4gICAgXHR2YXIgJHVwbG9hZF9mb3JtX2l0ZW0gPSBqUXVlcnkoXCI8ZGl2IGNsYXNzPSdmb3JtLWl0ZW0gZmlsZS11cGxvYWQnPlwiKTtcblx0XHQkdXBsb2FkX2Zvcm1faXRlbS5hcHBlbmQoXCI8bGFiZWw+XCIrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwrXCI8L2xhYmVsPlwiKTtcblxuXHRcdHRoaXMuJHByZXZpZXcgPSBqUXVlcnkoXCI8ZGl2PjwvZGl2PlwiKS5hZGRDbGFzcyhcImZpbGUtdXBsb2FkLXByZXZpZXdcIik7XG5cdFx0JHVwbG9hZF9mb3JtX2l0ZW0uYXBwZW5kKHRoaXMuJHByZXZpZXcpO1xuXG5cdFx0dmFyICRmaWxlX2lucHV0ID0galF1ZXJ5KFwiPGlucHV0IHR5cGU9J2ZpbGUnIGRhdGEtcGF0aD0nXCIrdGhpcy5tb2RlbC5wYXJlbnRwYXRoK3RoaXMubW9kZWwuc3RydWN0dXJlLmtleStcIicgY2xhc3M9J2Zvcm0tZmlsZScgLz5cIik7XG5cdFx0JHVwbG9hZF9mb3JtX2l0ZW0uYXBwZW5kKCRmaWxlX2lucHV0KTtcblxuXHRcdHZhciBmaWQgPSB0aGlzLm1vZGVsLmNvbnRhaW5lclt0aGlzLm1vZGVsLnN0cnVjdHVyZS5rZXldO1xuXG5cdFx0dGhpcy4ka2V5X2ZpZWxkID0galF1ZXJ5KFwiPGlucHV0IHR5cGU9J2hpZGRlbicgZGF0YS1rZXk9J1wiK3RoaXMubW9kZWwuc3RydWN0dXJlLmtleStcIicgXCIrXG5cdFx0XHRcInZhbHVlPSdcIisoKHR5cGVvZiBmaWQgIT09IHR5cGVvZiB1bmRlZmluZWQpPyBmaWQ6ICcnKStcIicgY2xhc3M9J2R5bmFtaWMtdmFsdWUnIC8+XCIpO1xuXHRcdCR1cGxvYWRfZm9ybV9pdGVtLmFwcGVuZCh0aGlzLiRrZXlfZmllbGQpO1xuXG5cblx0XHR0aGlzLiRwcm9ncmVzc19kaXNwbGF5ID0galF1ZXJ5KFwiPHA+XCIpLmFkZENsYXNzKFwicHJvZ3Jlc3NcIik7XG5cdFx0dGhpcy4kcHJvZ3Jlc3NfYmFyX3dyYXBwZXIgPSBqUXVlcnkoXCI8ZGl2IGNsYXNzPSdwcm9ncmVzcy1iYXItd3JhcHBlcic+PGRpdiBjbGFzcz0nYmFyJz48L2Rpdj5cIik7XG5cdFx0dGhpcy4kcHJvZ3Jlc3NfYmFyX3N0YXR1cyA9IHRoaXMuJHByb2dyZXNzX2Jhcl93cmFwcGVyLmNoaWxkcmVuKFwiLmJhclwiKTtcblx0XHRpZih0aGlzLm1vZGVsLmNvbnRhaW5lclt0aGlzLm1vZGVsLnN0cnVjdHVyZS5rZXldID09PSBcIlwiIHx8IHRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV0gPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLiRwcm9ncmVzc19kaXNwbGF5LnRleHQodGhpcy5nZXRGaWxlQ2hvb3NlSGVscCgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kcHJvZ3Jlc3NfZGlzcGxheS50ZXh0KHRoaXMuZ2V0RmlsZVJlcGxhY2VIZWxwKCkpO1xuXHRcdFx0dGhpcy4kcHJvZ3Jlc3NfYmFyX3N0YXR1cy5hZGRDbGFzcyhcImRvbmVcIik7XG5cdFx0fVxuXHRcdCR1cGxvYWRfZm9ybV9pdGVtLmFwcGVuZCh0aGlzLiRwcm9ncmVzc19kaXNwbGF5KS5hcHBlbmQodGhpcy4kcHJvZ3Jlc3NfYmFyX3dyYXBwZXIpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdCRmaWxlX2lucHV0LmZpbGV1cGxvYWQoe1xuXHQgICAgICAgIHVybDogdGhpcy5tb2RlbC5zdHJ1Y3R1cmUudXBsb2FkcGF0aCxcblx0ICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuXHQgICAgICAgIHBhcmFtTmFtZTogXCJmaWxlXCIsXG5cdCAgICAgICAgZG9uZTogZnVuY3Rpb24oZSwgZGF0YSl7XG5cdCAgICAgICAgXHRzZWxmLnVwbG9hZERvbmUoZSwgZGF0YSk7XG5cdCAgICAgICAgXHRzZWxmLmxvYWRQcmV2aWV3KCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwcm9ncmVzc2FsbDogZnVuY3Rpb24oZSwgZGF0YSl7XG5cdCAgICAgICAgXHRzZWxmLnByb2dyZXNzYWxsKGUsIGRhdGEpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgYWx3YXlzOiBmdW5jdGlvbihlLCBkYXRhKXtcblx0ICAgICAgICBcdEdSSUQubG9nKGUsIGRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pLmJpbmQoJ2ZpbGV1cGxvYWRzdWJtaXQnLCB7IHNlbGY6IHNlbGYgfSwgdGhpcy5nZXRGb3JtRGF0YSk7XG5cblx0XHR0aGlzLiRlbC5hcHBlbmQoJHVwbG9hZF9mb3JtX2l0ZW0pO1xuXG5cdFx0dGhpcy5sb2FkUHJldmlldygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXHRsb2FkUHJldmlldzogZnVuY3Rpb24oKXtcblxuXHRcdHRoaXMuJHByZXZpZXcuZW1wdHkoKTtcblxuICAgIFx0dmFyIGZpbGVpZCA9IHRoaXMuJGtleV9maWVsZC52YWwoKTtcbiAgICBcdHZhciBwYXRoID0gdGhpcy5tb2RlbC5wYXJlbnRwYXRoK3RoaXMubW9kZWwuc3RydWN0dXJlLmtleTtcblx0XHRpZih0eXBlb2YgZmlsZWlkID09PSB0eXBlb2YgdW5kZWZpbmVkIHx8IGZpbGVpZCA9PT0gXCJcIikgcmV0dXJuO1xuXG5cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgYm94PXRoaXMubW9kZWwuYm94O1xuXHRcdHZhciBwYXJhbXMgPSBbYm94LmdldEdyaWQoKS5nZXRHcmlkSUQoKSxib3guZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksYm94LmdldFNsb3QoKS5nZXQoXCJpZFwiKSxib3guZ2V0SW5kZXgoKSxwYXRoLGZpbGVpZF07XG5cdFx0bmV3IEdyaWRBamF4KFwiZ2V0RmlsZUluZm9cIixwYXJhbXMse1xuXHRcdFx0c3VjY2Vzc19mbjpmdW5jdGlvbihkYXRhKVxuXHRcdFx0e1xuXHRcdFx0XHRzZWxmLiRwcmV2aWV3LmFwcGVuZChcblx0XHRcdFx0XHRqUXVlcnkoXCI8aW1nPlwiKVxuXHRcdFx0XHRcdC5jc3MoJ21heC13aWR0aCcsICcyMDBweCcpXG5cdFx0XHRcdFx0XHQuYXR0cihcInNyY1wiLCBkYXRhLnJlc3VsdC5zcmMpXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcbiAgICBnZXRGb3JtRGF0YTogZnVuY3Rpb24oZSwgZGF0YSl7XG5cdCAgICB2YXIgc2VsZiA9IGUuZGF0YS5zZWxmO1xuXHQgICAgdmFyIGVsZW1lbnRfa2V5ID0gc2VsZi5tb2RlbC5wYXJlbnRwYXRoK3NlbGYubW9kZWwuc3RydWN0dXJlLmtleTtcblx0ICAgIHZhciBib3ggPSBzZWxmLm1vZGVsLmJveDtcblx0ICAgIGRhdGEuZm9ybURhdGEgPSB7XG5cdCAgICBcdFx0Z3JpZGlkIDogR1JJRC5JRCxcblx0ICAgIFx0XHRjb250YWluZXI6IGJveC5nZXRDb250YWluZXIoKS5nZXQoXCJpZFwiKSxcblx0ICAgIFx0XHRzbG90IDogYm94LmdldFNsb3QoKS5nZXQoXCJpZFwiKSxcblx0ICAgIFx0XHRib3ggOiBib3guZ2V0SW5kZXgoKSxcblx0ICAgIFx0XHRrZXk6IGVsZW1lbnRfa2V5XG5cdCAgICBcdH07XG5cdCAgICBzZWxmLiRwcm9ncmVzc19iYXJfc3RhdHVzLnJlbW92ZUNsYXNzKFwiZG9uZVwiKTtcbiAgICB9LFxuICAgIHByb2dyZXNzYWxsOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgIFx0dmFyIHBlcmNlbnQgPSAoZGF0YS5sb2FkZWQvZGF0YS50b3RhbCkqMTAwO1xuICAgIFx0dGhpcy4kcHJvZ3Jlc3NfZGlzcGxheS50ZXh0KE1hdGgucm91bmQocGVyY2VudCkrXCIlXCIpO1xuICAgIFx0dGhpcy4kcHJvZ3Jlc3NfYmFyX3N0YXR1cy5jc3MoXCJ3aWR0aFwiLCBwZXJjZW50K1wiJVwiKTtcbiAgICB9LFxuICAgIHVwbG9hZERvbmU6IGZ1bmN0aW9uKGUsIGRhdGEpe1xuICAgIFx0dmFyIHJlc3VsdCA9IGRhdGEucmVzdWx0O1xuICAgIFx0dGhpcy4ka2V5X2ZpZWxkLnZhbChyZXN1bHQucmVzdWx0KTtcbiAgICAgICAgdGhpcy4kcHJvZ3Jlc3NfZGlzcGxheS50ZXh0KFwiT0shXCIpO1xuICAgICAgICB0aGlzLiRwcm9ncmVzc19iYXJfc3RhdHVzLmFkZENsYXNzKFwiZG9uZVwiKTtcbiAgICB9LFxuICAgIGZldGNoVmFsdWU6ZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGtleV9maWVsZC52YWwoKTtcbiAgICB9LFxuICAgIGdldEZpbGVSZXBsYWNlSGVscCgpe1xuICAgICAgICB2YXIgdGV4dDtcbiAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5tb2RlbC5zdHJ1Y3R1cmUuZmlsZVJlcGxhY2VtZW50SGVscCkgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLm1vZGVsLnN0cnVjdHVyZS5maWxlUmVwbGFjZW1lbnRIZWxwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IFwiQ2hvb3NlIGFub3RoZXIgcGljdHVyZSB0byBvdmVycmlkZSB0aGUgb2xkIG9uZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9LFxuICAgIGdldEZpbGVDaG9vc2VIZWxwKCl7XG4gICAgICAgIHZhciB0ZXh0O1xuICAgICAgICBpZiAodHlwZW9mICh0aGlzLm1vZGVsLnN0cnVjdHVyZS5maWxlQ2hvb3NlSGVscCkgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLm1vZGVsLnN0cnVjdHVyZS5maWxlQ2hvb3NlSGVscDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBcIlBsZWFzZSBjaG9vc2UgYSBwaWN0dXJlLi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufSk7XG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcblxuYm94RWRpdG9yQ29udHJvbHNbJ2hpZGRlbiddPUdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cdGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3Itd2lkZ2V0LWhpZGRlblwiLFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZmV0Y2hWYWx1ZTpmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250YWluZXJbdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5XTtcbiAgICB9XG59KTsiLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcbmltcG9ydCB7aW5pdEhUTUxFZGl0b3J9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuXG5ib3hFZGl0b3JDb250cm9sc1snaHRtbCddPUdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiBcImdyaWQtZWRpdG9yLXdpZGdldCBncmlkLWVkaXRvci13aWRnZXQtaHRtbFwiLFxuICAgIHJlbmRlcjpmdW5jdGlvbigpe1xuICAgICAgICBjb25zdCB0ZXh0PXRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV0gfHwgXCJcIjtcbiAgICAgICAgdGhpcy4kZWwuaHRtbChcbiAgICAgICAgICAgIFwiPGxhYmVsPlwiK3RoaXMubW9kZWwuc3RydWN0dXJlLmxhYmVsK1wiPC9sYWJlbD5cIitcbiAgICAgICAgICAgIFwiPHRleHRhcmVhIG5hbWU9J1wiK3RoaXMuY2lkK1wiJyBjbGFzcz0nZHluYW1pYy12YWx1ZSBmb3JtLWh0bWwnPlwiK3RleHQucmVwbGFjZSgvXFwnL2csIFwiJiMzOTtcIikrXCI8L3RleHRhcmVhPlwiXG4gICAgICAgICk7XG4gICAgICAgIGluaXRIVE1MRWRpdG9yKHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5mb3JtLWh0bWxcIikpLnRoZW4oZWRpdG9yPT57XG4gICAgICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZldGNoVmFsdWU6ZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldERhdGEoKTtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG5ib3hFZGl0b3JDb250cm9sc1snaW5mbyddPUdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiBcImdyaWQtZWRpdG9yLXdpZGdldCBncmlkLWVkaXRvci13aWRnZXQtaW5mb1wiLFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICggbnVsbCAhPSB0aGlzLm1vZGVsLnN0cnVjdHVyZS5sYWJlbCApe1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMuZWwpLmh0bWwoXCI8bGFiZWw+XCIrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwrXCI8L2xhYmVsPjxwIGNsYXNzPSdpbmZvJz5cIit0aGlzLm1vZGVsLnN0cnVjdHVyZS50ZXh0K1wiPC9wPlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMuZWwpLmh0bWwoXCI8cCBjbGFzcz0naW5mbyc+XCIrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUudGV4dCtcIjwvcD5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmZXRjaFZhbHVlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG5ib3hFZGl0b3JDb250cm9sc1snaW5wdXQnXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3Itd2lkZ2V0LWlucHV0XCIsXG4gICAgaW5pdGlhbGl6ZTpmdW5jdGlvbigpe1xuXG4gICAgfSxcbiAgICByZW5kZXI6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5tb2RlbC5jb250YWluZXJbdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5XTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoalF1ZXJ5KFwiPGxhYmVsIC8+XCIpLnRleHQodGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwpKTtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKFxuICAgICAgICAgICAgalF1ZXJ5KFwiPGlucHV0IC8+XCIpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZHluYW1pYy12YWx1ZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHlwZVwiLCB0aGlzLm1vZGVsLnN0cnVjdHVyZS5pbnB1dFR5cGUpXG4gICAgICAgICAgICAgICAgLnZhbCgodHlwZW9mIHZhbCA9PT0gdHlwZW9mIHVuZGVmaW5lZCk/IFwiXCI6IHZhbClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoXCJncmlkLWVkaXRvci13aWRnZXQtaW5wdXRfX1wiK3RoaXMubW9kZWwuc3RydWN0dXJlLmlucHV0VHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZmV0Y2hWYWx1ZTpmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4galF1ZXJ5KHRoaXMuJGVsKS5maW5kKFwiaW5wdXRcIikudmFsKCk7XG4gICAgfVxufSk7IiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJ1xuXG5ib3hFZGl0b3JDb250cm9sc1snbGlzdCddPUdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiBcImdyaWQtZWRpdG9yLXdpZGdldCBncmlkLWVkaXRvci13aWRnZXQtbGlzdFwiLFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIGpRdWVyeShcIjxsYWJlbD48L2xhYmVsPlwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMubW9kZWwuc3RydWN0dXJlLmxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy4kZWwpO1xuXG4gICAgICAgIHRoaXMuJGxpc3QgPSBqUXVlcnkoXCI8ZGl2PjwvZGl2PlwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2dyaWQtZWRpdG9yLXdpZGdldC1saXN0LWl0ZW1zJyk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLiRsaXN0KTtcblxuICAgICAgICB2YXIgbGlzdD10aGlzLm1vZGVsLmNvbnRhaW5lclt0aGlzLm1vZGVsLnN0cnVjdHVyZS5rZXldO1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgdmlld3M9W107XG5cbiAgICAgICAgalF1ZXJ5KFwiPGJ1dHRvbj48c3BhbiBjbGFzcz0naWNvbi1wbHVzJz48L3NwYW4+QWRkIGl0ZW08L2J1dHRvbj5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2dyaWQtZWRpdG9yLXdpZGdldC1saXN0LWFkZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLiRlbCkub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25BZGQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICBfLmVhY2gobGlzdCxmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIHZhciB2aWV3PW5ldyBib3hFZGl0b3JDb250cm9sc1snbGlzdGl0ZW0nXSh7XG4gICAgICAgICAgICAgICAgbW9kZWw6e1xuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3R1cmU6c2VsZi5tb2RlbC5zdHJ1Y3R1cmUuY29udGVudHN0cnVjdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOmVsZW0sXG4gICAgICAgICAgICAgICAgICAgIGJveDpzZWxmLm1vZGVsLmJveCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cGF0aDpzZWxmLm1vZGVsLnBhcmVudHBhdGgrc2VsZi5tb2RlbC5zdHJ1Y3R1cmUua2V5K1wiLlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgc2VsZi4kbGlzdC5hcHBlbmQodmlldy5yZW5kZXIoKS4kZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3cz12aWV3cztcblxuICAgICAgICB0aGlzLiRsaXN0Lm9uKFwiY2xpY2tcIiwgXCIud2lkZ2V0LWxpc3Qtc29ydC1idXR0b25cIiwge3NlbGY6IHRoaXN9LCB0aGlzLnNvcnRJdGVtKTtcbiAgICAgICAgdGhpcy4kbGlzdC5vbihcImNsaWNrXCIsIFwiLndpZGdldC1saXN0LXJlbW92ZS1pdGVtLWJ1dHRvblwiLCB7c2VsZjogdGhpc30sIHRoaXMub25SZW1vdmUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc29ydEl0ZW06IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgc2VsZiA9IGUuZGF0YS5zZWxmO1xuICAgICAgICB2YXIgJGJ1dHRvbj0galF1ZXJ5KGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgIHZhciAkdGhpcyA9ICRidXR0b24uY2xvc2VzdChcIi5ncmlkLWVkaXRvci13aWRnZXQtbGlzdGl0ZW1cIik7XG4gICAgICAgIHZhciBpbmRleCA9ICR0aGlzLmluZGV4KCk7XG4gICAgICAgIHZhciB2aWV3cyA9IHNlbGYudmlld3M7XG4gICAgICAgIHZhciB2aWV3ID0gdmlld3NbaW5kZXhdO1xuICAgICAgICB2YXIgbmV3UG9zID0gaW5kZXg7XG4gICAgICAgIHN3aXRjaCgkYnV0dG9uLmF0dHIoXCJkYXRhLWRpclwiKSl7XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBpbmRleC0xO1xuICAgICAgICAgICAgICAgIGlmKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IDA7XG4gICAgICAgICAgICAgICAgJHRoaXMuaW5zZXJ0QmVmb3JlKCR0aGlzLnByZXYoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IGluZGV4KzE7XG4gICAgICAgICAgICAgICAgJHRoaXMuaW5zZXJ0QWZ0ZXIoJHRoaXMubmV4dCgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2aWV3cy5zcGxpY2UoaW5kZXgsMSk7XG4gICAgICAgIHZpZXdzLnNwbGljZShuZXdQb3MsMCx2aWV3KTtcblxuICAgIH0sXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgIHZhciBzZWxmID0gZS5kYXRhLnNlbGY7XG4gICAgICAgIHZhciBpbmRleCA9IGpRdWVyeShlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXCIuZ3JpZC1lZGl0b3Itd2lkZ2V0LWxpc3RpdGVtXCIpLmluZGV4KCk7XG4gICAgICAgIHZhciBsaXN0ID0gc2VsZi5tb2RlbC5jb250YWluZXJbc2VsZi5tb2RlbC5zdHJ1Y3R1cmUua2V5XTtcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsMSk7XG4gICAgICAgIHNlbGYudmlld3NbaW5kZXhdLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLnZpZXdzW2luZGV4XS5yZW1vdmUoKTtcbiAgICAgICAgc2VsZi52aWV3cy5zcGxpY2UoaW5kZXgsMSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFtcInJlbW92ZVwiLGUsIHNlbGZdKTtcblxuICAgIH0sXG4gICAgb25BZGQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IGJveEVkaXRvckNvbnRyb2xzWydsaXN0aXRlbSddKHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgc3RydWN0dXJlOiB0aGlzLm1vZGVsLnN0cnVjdHVyZS5jb250ZW50c3RydWN0dXJlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjp7fSxcbiAgICAgICAgICAgICAgICBib3g6IHRoaXMubW9kZWwuYm94LFxuICAgICAgICAgICAgICAgIHBhcmVudHBhdGg6IHRoaXMubW9kZWwucGFyZW50cGF0aCt0aGlzLm1vZGVsLnN0cnVjdHVyZS5rZXkrXCIuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgdGhpcy4kbGlzdC5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG5cbiAgICAgICAgLy8galF1ZXJ5LmVhY2godmlldy4kZWwuZmluZChcIi5mb3JtLWh0bWxcIiksIGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIC8vICAgICBDS0VESVRPUi5yZXBsYWNlKFxuICAgICAgICAvLyAgICAgICAgIGVsZW1lbnQse1xuICAgICAgICAvLyAgICAgICAgIGN1c3RvbUNvbmZpZyA6IGRvY3VtZW50LlBhdGhUb0NvbmZpZ1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vIH0pO1xuICAgIH0sXG4gICAgZmV0Y2hWYWx1ZTpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgY29udGVudD1bXTtcbiAgICAgICAgXy5lYWNoKHRoaXMudmlld3MsZnVuY3Rpb24odmlldyl7XG4gICAgICAgICAgICBpZih2aWV3LnJlbW92ZWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh2aWV3LmZldGNoVmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG59KTtcblxuYm94RWRpdG9yQ29udHJvbHNbJ2xpc3RpdGVtJ109R3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1lZGl0b3Itd2lkZ2V0LWxpc3RpdGVtXCIsXG4gICAgcmVtb3ZlZDogZmFsc2UsXG4gICAgaW5pdGlhbGl6ZTpmdW5jdGlvbigpe1xuXG4gICAgfSxcbiAgICByZW5kZXI6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHZpZXdzPVtdO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIF8uZWFjaCh0aGlzLm1vZGVsLnN0cnVjdHVyZSxmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIHZhciB0eXBlPWVsZW0udHlwZTtcbiAgICAgICAgICAgIHZhciB2aWV3PW5ldyBib3hFZGl0b3JDb250cm9sc1t0eXBlXShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtb2RlbDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdHVyZTplbGVtLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6c2VsZi5tb2RlbC5jb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIGJveDpzZWxmLm1vZGVsLmJveCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cGF0aDpzZWxmLm1vZGVsLnBhcmVudHBhdGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICBzZWxmLiRlbC5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBqUXVlcnkoXCI8YnV0dG9uIGNsYXNzPSd3aWRnZXQtbGlzdC1yZW1vdmUtaXRlbS1idXR0b24nPjxzcGFuIGNsYXNzPSdpY29uLW1pbnVzJz48L3NwYW4+UmVtb3ZlIGl0ZW08L2J1dHRvbj5cIilcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGVsKTtcbiAgICAgICAgalF1ZXJ5KFwiPGJ1dHRvbiBjbGFzcz0nd2lkZ2V0LWxpc3QtbW92ZS11cC1pdGVtLWJ1dHRvbiB3aWRnZXQtbGlzdC1zb3J0LWJ1dHRvbicgZGF0YS1kaXI9J3VwJz48c3BhbiBjbGFzcz0naWNvbi1kaXItdXAnPjwvc3Bhbj48L2J1dHRvbj5cIilcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGVsKTtcbiAgICAgICAgalF1ZXJ5KFwiPGJ1dHRvbiBjbGFzcz0nd2lkZ2V0LWxpc3QtbW92ZS1kb3duLWl0ZW0tYnV0dG9uIHdpZGdldC1saXN0LXNvcnQtYnV0dG9uJyBkYXRhLWRpcj0nZG93bic+PHNwYW4gY2xhc3M9J2ljb24tZGlyLWRvd24nPjwvc3Bhbj48L2J1dHRvbj5cIilcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGVsKTtcbiAgICAgICAgdGhpcy52aWV3cz12aWV3cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmZXRjaFZhbHVlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvYmo9e307XG4gICAgICAgIF8uZWFjaCh0aGlzLnZpZXdzLGZ1bmN0aW9uKHZpZXcpe1xuICAgICAgICAgICAgb2JqW3ZpZXcubW9kZWwuc3RydWN0dXJlLmtleV09dmlldy5mZXRjaFZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn0pO1xuIiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJ1xuXG5ib3hFZGl0b3JDb250cm9sc1snbXVsdGktYXV0b2NvbXBsZXRlJ109R3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1lZGl0b3Itd2lkZ2V0IGdyaWQtZWRpdG9yLXdpZGdldC1tdWx0aS1hdXRvY29tcGxldGVcIixcbiAgICBldmVudHM6e1xuICAgICAgICBcImtleXVwIC5pLWF1dG9jb21wbGV0ZVwiOlwia2V5dXBcIixcbiAgICAgICAgXCJjbGljayAuc3VnZ2VzdGlvbi1saXN0IGxpXCI6XCJsaXN0SXRlbVNlbGVjdGVkXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBodG1sPVwiPGxhYmVsPlwiK3RoaXMubW9kZWwuc3RydWN0dXJlLmxhYmVsK1wiPC9sYWJlbD5cIjtcbiAgICAgICAgdmFyIGNsYXNzZXM9XCJhdXRvY29tcGxldGUtd3JhcHBlciBmb3JtLWF1dG9jb21wbGV0ZSBkeW5hbWljLXZhbHVlXCI7XG4gICAgICAgIHZhciBmZXRjaD1mYWxzZTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC5jb250YWluZXJbdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5XSE9JycgfHxcbiAgICAgICAgICAgIHRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV09PT0wKVxuICAgICAgICB7XG4gICAgICAgICAgICBmZXRjaD10cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBodG1sKz1cIjxkaXYgY2xhc3M9J1wiK2NsYXNzZXMrXCInPjxpbnB1dCB0eXBlPXRleHQgY2xhc3M9J2Zvcm0tdGV4dCBhdXRvY29tcGxldGUgaS1hdXRvY29tcGxldGUnIC8+XCI7XG5cdCAgICBodG1sKz1cIjxkaXYgY2xhc3M9J2xvYWRpbmcnPjwvZGl2PlwiO1xuICAgICAgICBodG1sKz1cIjx1bCBjbGFzcz0nc3VnZ2VzdGlvbi1saXN0Jz48L3VsPlwiO1xuICAgICAgICBcblxuICAgICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICAgIFxuICAgICAgICB0aGlzLiRlbC5vbihcImNsaWNrXCIsIFwiLmljb24tY2FuY2VsXCIsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBqUXVlcnkodGhpcykucGFyZW50KCk7XG4gICAgICAgICAgICBpdGVtLmVtcHR5KCk7XG4gICAgICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9KTtcblxuICAgICAgICBpZihmZXRjaClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNlbGY9dGhpcztcbiAgICAgICAgICAgIHZhciBib3g9dGhpcy5tb2RlbC5ib3g7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSB0eXBlb2YgdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW107XG4gICAgICAgICAgICB9IGVsc2UgaWYoIHR5cGVvZiBjb250ZW50ICE9PSB0eXBlb2YgW10pe1xuICAgICAgICAgICAgICAgIC8vIGxlZ2FjeTogYmVmb3JlIG11bHRpIGF1dG9zZWxlY3Qgc3VwcG9ydFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbY29udGVudF07XG4gICAgICAgICAgICB9XG5cdCAgICAgICAgXG4gICAgICAgICAgICBqUXVlcnkuZWFjaChjb250ZW50LCBmdW5jdGlvbihpbmRleCwga2V5KXtcblx0ICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcIi5sb2FkaW5nXCIpLmFkZENsYXNzKFwiZ29cIik7XG4gICAgICAgICAgICAgICAgbmV3IEdyaWRBamF4KFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVBaGVhZEdldFRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94LmdldEdyaWQoKS5nZXRHcmlkSUQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveC5nZXRDb250YWluZXIoKS5nZXQoXCJpZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveC5nZXRTbG90KCkuZ2V0KFwiaWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3guZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kZWwucGFyZW50cGF0aCtzZWxmLm1vZGVsLnN0cnVjdHVyZS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc19mbjpmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuJGVsLmZpbmQoXCIubG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImdvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuJGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKFwiLmF1dG9jb21wbGV0ZS13cmFwcGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCI8ZGl2IGNsYXNzPSdhdXRvY29tcGxldGUtbXVsdGlzZWxlY3QtaXRlbScgZGF0YS1rZXk9J1wiK2tleStcIic+XCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzcGFuPlwiK2RhdGEucmVzdWx0K1wiPC9zcGFuPlwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0naWNvbiBpY29uLWNhbmNlbCc+PC9zcGFuPlwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZldGNoVmFsdWU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmF1dG9jb21wbGV0ZS1tdWx0aXNlbGVjdC1pdGVtXCIpLmVhY2goZnVuY3Rpb24oaW5kZXgsZWxlbWVudCl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChqUXVlcnkoZWxlbWVudCkuZGF0YShcImtleVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBrZXl1cDpmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmKGUud2hpY2g9PTEzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0odGhpcy4kZWwuZmluZChcIi5zdWdnZXN0aW9uLWxpc3QgbGlcIikuZmlyc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICAgICAgdmFyIHNlYXJjaD10aGlzLiRlbC5maW5kKFwiaW5wdXQuaS1hdXRvY29tcGxldGVcIikudmFsKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZG9udCBleGVjdXRlIHNhbWUgcXVlcnkgdHdpY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoIHRoaXMuJGVsLmZpbmQoXCJpbnB1dC5pLWF1dG9jb21wbGV0ZVwiKS52YWwoKSA9PSB0aGlzLm9sZF9zZWFyY2hfc3RyaW5nICkgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5vbGRfc2VhcmNoX3N0cmluZz1zZWFyY2g7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYW5pbWF0ZSBsb2FkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCIubG9hZGluZ1wiKS5hZGRDbGFzcyhcImdvXCIpO1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzdGFydCBzZWFyY2ggdGltZW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zZWFyY2hpbmcpO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgc2VsZi5kb1NlYXJjaChzZWFyY2gpO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZG9TZWFyY2g6IGZ1bmN0aW9uKHNlYXJjaCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGJveD10aGlzLm1vZGVsLmJveDtcbiAgICAgICAgXG4gICAgICAgIG5ldyBHcmlkQWpheChcbiAgICAgICAgICAgIFwidHlwZUFoZWFkU2VhcmNoXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgYm94LmdldEdyaWQoKS5nZXRHcmlkSUQoKSxcbiAgICAgICAgICAgICAgICBib3guZ2V0Q29udGFpbmVyKCkuZ2V0KFwiaWRcIiksXG4gICAgICAgICAgICAgICAgYm94LmdldFNsb3QoKS5nZXQoXCJpZFwiKSxcbiAgICAgICAgICAgICAgICBib3guZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBhcmVudHBhdGgrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5LFxuICAgICAgICAgICAgICAgIHNlYXJjaFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NfZm46ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcIi5zdWdnZXN0aW9uLWxpc3RcIikuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBfLmVhY2goZGF0YS5yZXN1bHQsZnVuY3Rpb24oZWxlbSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGVsLmZpbmQoXCIuc3VnZ2VzdGlvbi1saXN0XCIpLmFwcGVuZChqUXVlcnkoXCI8bGkvPlwiKS50ZXh0KGVsZW0udmFsdWUpLmF0dHIoXCJkYXRhLWtleVwiLGVsZW0ua2V5KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi4kZWwuZmluZChcIi5sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwiZ29cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICB9LFxuICAgIHNlbGVjdEl0ZW06ZnVuY3Rpb24oJGl0ZW0pe1xuICAgICAgICB2YXIga2V5PSRpdGVtLmRhdGEoXCJrZXlcIik7XG4gICAgICAgIHZhciB2YWx1ZT0kaXRlbS50ZXh0KCk7XG4gICAgICAgIGlmKGpRdWVyeShcIi5hdXRvY29tcGxldGUtbXVsdGlzZWxlY3QtaXRlbVtkYXRhLWtleT0nXCIra2V5K1wiJ11cIikubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuZmluZChcIi5zdWdnZXN0aW9uLWxpc3RcIikuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuZmluZChcImlucHV0LmktYXV0b2NvbXBsZXRlXCIpLnJlbW92ZUF0dHIoJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuYXV0b2NvbXBsZXRlLXdyYXBwZXJcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj48L2Rpdj5cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiYXV0b2NvbXBsZXRlLW11bHRpc2VsZWN0LWl0ZW1cIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1rZXlcIjoga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXCI8c3Bhbj48L3NwYW4+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiaWNvbiBpY29uLWNhbmNlbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGpRdWVyeSh0aGlzKS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgIFxuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuc3VnZ2VzdGlvbi1saXN0XCIpLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCJpbnB1dC5pLWF1dG9jb21wbGV0ZVwiKS52YWwoXCJcIik7XG4gICAgICAgIFxuICAgIH0sXG4gICAgbGlzdEl0ZW1TZWxlY3RlZDpmdW5jdGlvbihlKXtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGpRdWVyeShlLnRhcmdldCkpO1xuICAgIH1cbn0pOyIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuXG5cbmJveEVkaXRvckNvbnRyb2xzWydudW1iZXInXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3Itd2lkZ2V0LW51bWJlclwiLFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB0ZXh0PXRoaXMubW9kZWwuY29udGFpbmVyW3RoaXMubW9kZWwuc3RydWN0dXJlLmtleV07XG4gICAgICAgIGlmKCF0ZXh0KXRleHQ9XCJcIjtcbiAgICAgICAgdGhpcy4kZWwuaHRtbChcIjxsYWJlbD5cIit0aGlzLm1vZGVsLnN0cnVjdHVyZS5sYWJlbCtcIjwvbGFiZWw+PGlucHV0IHR5cGU9bnVtYmVyIGNsYXNzPSdkeW5hbWljLXZhbHVlJyB2YWx1ZT0nXCIrdGV4dCtcIicvPlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmZXRjaFZhbHVlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBqUXVlcnkodGhpcy4kZWwpLmZpbmQoXCJpbnB1dFwiKS52YWwoKTtcbiAgICB9XG59KTsiLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnXG5cbmJveEVkaXRvckNvbnRyb2xzWydzZWxlY3QnXT1HcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWVkaXRvci13aWRnZXQgZ3JpZC1lZGl0b3Itd2lkZ2V0LXNlbGVjdFwiLFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblxuICAgIH0sXG4gICAgcmVuZGVyOmZ1bmN0aW9uKCl7XG5cbiAgICAgICAgY29uc3Qgc3RydWN0dXJlID0gdGhpcy5tb2RlbC5zdHJ1Y3R1cmU7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMubW9kZWwuY29udGFpbmVyO1xuXG4gICAgICAgIGNvbnNvbGUuZGVidWcoc3RydWN0dXJlLCBjb250YWluZXIpXG5cbiAgICAgICAgY29uc3QgaXNNdWx0aXBsZSA9ICh0eXBlb2Ygc3RydWN0dXJlLm11bHRpcGxlICE9PSB0eXBlb2YgdW5kZWZpbmVkICYmIHN0cnVjdHVyZS5tdWx0aXBsZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGNvbnRhaW5lcltzdHJ1Y3R1cmUua2V5XTtcbiAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVWYWx1ZXMgPSAodHlwZW9mIHZhbHVlcyA9PT0gdHlwZW9mIFtdKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IHN0cnVjdHVyZS5zZWxlY3Rpb25zO1xuXG4gICAgICAgIGNvbnN0IG11bHRpcGxlID0gKGlzTXVsdGlwbGUpPyBcIm11bHRpcGxlPSdtdWx0aXBsZSdcIjogXCJcIjtcbiAgICAgICAgY29uc3Qgc2l6ZSA9ICghaXNNdWx0aXBsZSB8fCBzZWxlY3Rpb25zLnNpemUgPCA4KT8gXCJcIjogKHNlbGVjdGlvbnMubGVuZ3RoIDwgMTIpPyBcInNpemU9JzYnXCI6IFwic2l6ZT0nOCdcIjtcblxuICAgICAgICBsZXQgaHRtbD1cIjxsYWJlbD5cIit0aGlzLm1vZGVsLnN0cnVjdHVyZS5sYWJlbCtcIjwvbGFiZWw+PHNlbGVjdCBcIittdWx0aXBsZStcIiBcIitzaXplK1wiPlwiO1xuICAgICAgICBfLmVhY2goc2VsZWN0aW9ucyxmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZD1cIlwiO1xuICAgICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICAgKCFoYXNNdWx0aXBsZVZhbHVlcyAmJiBgJHt2YWx1ZXN9YCA9PT0gYCR7ZWxlbS5rZXl9YClcbiAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIChoYXNNdWx0aXBsZVZhbHVlcyAmJiBfLmluZGV4T2YodmFsdWVzLCBlbGVtLmtleSkgPiAtMSlcbiAgICAgICAgICAgICkgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiO1xuXG4gICAgICAgICAgICBodG1sKz1cIjxvcHRpb24gXCIrc2VsZWN0ZWQrXCIgdmFsdWU9J1wiK2VsZW0ua2V5K1wiJz5cIitlbGVtLnRleHQrXCI8L29wdGlvbj5cIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0bWw9aHRtbCtcIjwvc2VsZWN0PlwiO1xuICAgICAgICBqUXVlcnkodGhpcy5lbCkuaHRtbChodG1sKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmZXRjaFZhbHVlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBqUXVlcnkodGhpcy4kZWwpLmZpbmQoXCJzZWxlY3RcIikudmFsKCk7XG4gICAgfVxufSk7IiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5cbmJveEVkaXRvckNvbnRyb2xzWyd0ZXh0J109R3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1lZGl0b3Itd2lkZ2V0IGdyaWQtZWRpdG9yLXdpZGdldC10ZXh0XCIsXG4gICAgaW5pdGlhbGl6ZTpmdW5jdGlvbigpe1xuXG4gICAgfSxcbiAgICByZW5kZXI6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoIGpRdWVyeShcIjxsYWJlbC8+XCIpLnRleHQodGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwpICk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChcbiAgICAgICAgICAgIGpRdWVyeShcIjxpbnB1dCB0eXBlPXRleHQgY2xhc3M9J2R5bmFtaWMtdmFsdWUnLz5cIilcbiAgICAgICAgICAgIC52YWwodGhpcy5tb2RlbC5jb250YWluZXJbdGhpcy5tb2RlbC5zdHJ1Y3R1cmUua2V5XSB8fCBcIlwiKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZmV0Y2hWYWx1ZTpmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4galF1ZXJ5KHRoaXMuJGVsKS5maW5kKFwiaW5wdXRcIikudmFsKCk7XG4gICAgfVxufSk7IiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5cbmJveEVkaXRvckNvbnRyb2xzWyd0ZXh0YXJlYSddPUdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiBcImdyaWQtZWRpdG9yLXdpZGdldCBncmlkLWVkaXRvci13aWRnZXQtdGV4dGFyZWFcIixcbiAgICBpbml0aWFsaXplOmZ1bmN0aW9uKCl7XG5cbiAgICB9LFxuICAgIHJlbmRlcjpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdGV4dD10aGlzLm1vZGVsLmNvbnRhaW5lclt0aGlzLm1vZGVsLnN0cnVjdHVyZS5rZXldO1xuICAgICAgICBpZighdGV4dCl0ZXh0PVwiXCI7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwoXCI8bGFiZWw+XCIrdGhpcy5tb2RlbC5zdHJ1Y3R1cmUubGFiZWwrXCI8L2xhYmVsPjx0ZXh0YXJlYSBjbGFzcz0nZHluYW1pYy12YWx1ZSBmb3JtLXRleHRhcmVhJz5cIit0ZXh0K1wiPC90ZXh0YXJlYT5cIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZmV0Y2hWYWx1ZTpmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4galF1ZXJ5KHRoaXMuJGVsKS5maW5kKFwidGV4dGFyZWFcIikudmFsKCk7XG4gICAgfVxufSk7XG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcblxuYm94RWRpdG9yQ29udHJvbHNbJ3dwLW1lZGlhc2VsZWN0J109R3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1lZGl0b3Itd2lkZ2V0IGdyaWQtZWRpdG9yLXdpZGdldC13cC1tZWRpYXNlbGVjdFwiLFxuICAgIGV2ZW50czp7XG4gICAgICAgIFwiY2xpY2sgLnVwbG9hZF9pbWFnZV9idXR0b25cIjogXCJvcGVuX3dwX21lZGlhXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcbiAgICB9LFxuICAgIHJlbmRlcjpmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5tb2RlbC5zdHJ1Y3R1cmU7XG4gICAgICAgIHZhciBjX3ZhbCA9IHRoaXMubW9kZWwuY29udGFpbmVyW2VsZW1lbnQua2V5XTtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKFwiPGxhYmVsPlwiK2VsZW1lbnQubGFiZWwrXCI8L2xhYmVsPlwiKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBtZWRpYSB0eXBlIGZpbHRlclxuXHQgICAgICovXG5cdCAgICB0aGlzLm1lZGlhX3R5cGUgPSBcIipcIjtcblx0ICAgIGlmKHR5cGVvZiBlbGVtZW50Lm1lZGlhX3R5cGUgIT0gdHlwZW9mIHVuZGVmaW5lZCl7XG5cdFx0ICAgIHRoaXMubWVkaWFfdHlwZSA9IGVsZW1lbnQubWVkaWFfdHlwZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBzaG93IHByZXZpZXcgb2YgaW1hZ2Vcblx0ICAgICAqL1xuXHQgICAgdGhpcy4kaW1nX3dyYXBwZXIgPSBqUXVlcnkoXCI8ZGl2PjwvZGl2PlwiKTtcblx0ICAgIHRoaXMuJGltZ193cmFwcGVyLmFkZENsYXNzKFwid3AtbWVkaWFzZWxlY3QtaW1hZ2Utd3JhcHBlclwiKTtcblx0ICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLiRpbWdfd3JhcHBlcik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogdXBsb2FkIGJ1dHRvblxuXHQgICAgICovXG4gICAgICAgIHRoaXMuJHVwbG9hZF9idG4gPSBqUXVlcnkoXCI8YnV0dG9uIGNsYXNzPSdidXR0b24gdXBsb2FkX2ltYWdlX2J1dHRvbic+TWVkaWE8L2J1dHRvbj5cIik7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLiR1cGxvYWRfYnRuKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBoaWRkZW4gaW5wdXQgd2l0aCBzYXZlZCB2YWx1ZXNcblx0ICAgICAqL1xuICAgICAgICB0aGlzLiRpbnB1dCA9IGpRdWVyeShcIjxpbnB1dCAvPlwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndmFsdWUnLCBKU09OLnN0cmluZ2lmeShjX3ZhbCkgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdoaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2R5bmFtaWMtdmFsdWUgZm9ybS1qc29uJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLXBhdGhcIix0aGlzLm1vZGVsLnBhcmVudHBhdGgrZWxlbWVudC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkYXRhLWtleScsIGVsZW1lbnQua2V5KTtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuJGlucHV0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBhdmFpbGFibGUgc2l6ZXMgc2VsZWN0XG5cdCAgICAgKi9cbiAgICAgICAgdGhpcy4kc2VsZWN0X2ltYWdlX3NpemUgPSBqUXVlcnkoXCI8c2VsZWN0IGNsYXNzPSdpbWFnZS1zaXplcyc+PC9zZWxlY3Q+XCIpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kc2VsZWN0X2ltYWdlX3NpemUpO1xuXG4gICAgICAgIHRoaXMuJHNlbGVjdF9pbWFnZV9zaXplLm9uKFwiY2hhbmdlXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSgkdGhpcy5zaWJsaW5ncygnLmR5bmFtaWMtdmFsdWUnKS52YWwoKSk7XG4gICAgICAgICAgICBqc29uLnNpemUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICR0aGlzLnNpYmxpbmdzKCcuZHluYW1pYy12YWx1ZScpLnZhbChKU09OLnN0cmluZ2lmeShqc29uKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYnVpbGRJbWFnZVNpemVTZWxlY3QoKTtcblxuXHQgICAgdGhpcy5idWlsZEltYWdlUHJldmlldygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb3Blbl93cF9tZWRpYTogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZnJhbWUgPSB3cC5tZWRpYSh7XG4gICAgICAgICAgICAvL3RpdGxlIDogbGFuZ192YWx1ZXNbJ3RpdGxlLXdwLW1lZGlhJ10sXG4gICAgICAgICAgICBtdWx0aXBsZSA6IGZhbHNlLFxuICAgICAgICAgICAgbGlicmFyeSA6IHsgdHlwZSA6IHRoaXMubWVkaWFfdHlwZX0sXG4gICAgICAgICAgICBidXR0b24gOiB7IHRleHQgOiBcIkluc2VydFwiIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZyYW1lLm9uKCdvcGVuJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBmcmFtZS5zdGF0ZSgpLmdldCgnc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICB2YXIgdmFsID0gSlNPTi5wYXJzZShzZWxmLiRpbnB1dC52YWwoKSk7XG4gICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHdwLm1lZGlhLmF0dGFjaG1lbnQodmFsLmlkKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGQoIGF0dGFjaG1lbnQgPyBbIGF0dGFjaG1lbnQgXSA6IFtdICk7XG4gICAgICAgIH0pO1xuICAgICAgICBmcmFtZS5vbignY2xvc2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGZyYW1lLnN0YXRlKCkuZ2V0KCdzZWxlY3Rpb24nKTtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKGZyYW1lLnN0YXRlKCkuZ2V0KCdzZWxlY3Rpb24nKS5fYnlJZCwgZnVuY3Rpb24oaWQsIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplcyA9IHZhbC5nZXQoXCJzaXplc1wiKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2Ygc2l6ZXMgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgICAgICAgICBzaXplcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB2YWwuZ2V0KFwidXJsXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByX2pzb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFwiZnVsbFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplczogc2l6ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuJGlucHV0LnZhbChKU09OLnN0cmluZ2lmeShyX2pzb24pKTtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkSW1hZ2VTaXplU2VsZWN0KCk7XG5cdCAgICAgICAgICAgIHNlbGYuYnVpbGRJbWFnZVByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZyYW1lLm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cdGdldF9qc29uX2Zyb21faW5wdXQ6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGpzb24gPSBudWxsO1xuXHRcdGlmKHRoaXMuJGlucHV0LnZhbCgpICE9IFwib2JqZWN0XCIpe1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHRoaXMuJGlucHV0LnZhbCgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAganNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpzb24gPXRoaXMuJGlucHV0LnZhbCgpO1xuXHRcdH1cblx0XHRyZXR1cm4ganNvbjtcblx0fSxcblx0YnVpbGRJbWFnZVByZXZpZXc6IGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuZ2V0X2pzb25fZnJvbV9pbnB1dCgpO1xuXG4gICAgICAgIGlmKCBqc29uID09IG51bGxcblx0ICAgICAgICB8fCBqc29uID09ICcnXG5cdFx0XHR8fCB0eXBlb2YganNvbiAhPSB0eXBlb2Yge31cblx0XHRcdHx8IHR5cGVvZiBqc29uLnNpemVzICE9IHR5cGVvZiB7fVxuXHRcdFx0fHwgdHlwZW9mIGpzb24uc2l6ZXMudGh1bWJuYWlsICE9IHR5cGVvZiB7fVxuXHRcdFx0fHwgdHlwZW9mIGpzb24uc2l6ZXMudGh1bWJuYWlsLnVybCAhPSB0eXBlb2YgXCJcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkaW1nID0galF1ZXJ5KFwiPGltZy8+XCIpO1xuICAgICAgICAkaW1nXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJ3cC1tZWRpYXNlbGVjdC1pbWFnZS1wcmV2aWV3XCIpXG4gICAgICAgICAgICAuYXR0cihcInNyY1wiLCBqc29uLnNpemVzLnRodW1ibmFpbC51cmwpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGpzb24uc2l6ZXMudGh1bWJuYWlsLndpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIixqc29uLnNpemVzLnRodW1ibmFpbC5oZWlnaHQpO1xuICAgICAgICB0aGlzLiRpbWdfd3JhcHBlci5lbXB0eSgpO1xuICAgICAgICB0aGlzLiRpbWdfd3JhcHBlci5hcHBlbmQoJGltZyk7XG5cblxuXHR9LFxuICAgIGJ1aWxkSW1hZ2VTaXplU2VsZWN0OiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYodGhpcy4kaW5wdXQudmFsKCkgPT0gXCJcIil7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGpzb24gPSB0aGlzLmdldF9qc29uX2Zyb21faW5wdXQoKTtcblxuICAgICAgICBpZigganNvbiA9PSBudWxsXG5cdFx0XHR8fCBqc29uID09ICcnXG5cdFx0XHR8fCB0eXBlb2YganNvbiAhPSB0eXBlb2Yge31cblx0XHRcdHx8IHR5cGVvZiBqc29uLnNpemVzICE9IHR5cGVvZiB7fSApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuJHNlbGVjdF9pbWFnZV9zaXplLmhpZGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHNlbGVjdF9pbWFnZV9zaXplLmVtcHR5KCk7XG4gICAgICAgIGpRdWVyeS5lYWNoKGpzb24uc2l6ZXMsIGZ1bmN0aW9uKGluZGV4LCBzaXplKSB7XG4gICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gXCJcIjtcbiAgICAgICAgICAgICBpZihqc29uLnNpemUgPT0gaW5kZXgpe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gXCJzZWxlY3RlZD0nc2VsZWN0ZWQnXCI7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGpRdWVyeShcIjxvcHRpb24gXCIrc2VsZWN0ZWQrXCIgPlwiK2luZGV4K1wiPC9vcHRpb24+XCIpLlxuICAgICAgICAgICAgIGF0dHIoJ3ZhbHVlJywgaW5kZXgpLmFwcGVuZFRvKHNlbGYuJHNlbGVjdF9pbWFnZV9zaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKHRoaXMuJHNlbGVjdF9pbWFnZV9zaXplLmNoaWxkcmVuKCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RfaW1hZ2Vfc2l6ZS5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRzZWxlY3RfaW1hZ2Vfc2l6ZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZldGNoVmFsdWU6ZnVuY3Rpb24oKXtcblx0ICAgIHZhciB2YWx1ZSA9IFwiXCI7XG5cdCAgICB0cnl7XG5cdFx0ICAgIHZhbHVlID0gSlNPTi5wYXJzZSh0aGlzLiRpbnB1dC52YWwoKSk7XG5cdCAgICB9IGNhdGNoKGUpe1xuXHRcdCAgICBHUklELmxvZyhcImVtcHR5IGltYWdlIGJveFwiKTtcblx0ICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuIiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgaWNoIGZyb20gJ2ljYW5oYXonXG5cbndpbmRvdy5BdXRob3IgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6IFwibGlcIixcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1hdXRob3JcIixcbiAgICBldmVudHM6IHtcbiAgICAgICAgXCJjbGljayAuYXV0aG9yLWxvY2stc2VuZGVyXCI6IFwib25DbGlja1NlbmRMb2NrXCIsXG4gICAgICAgIFwiY2xpY2sgLmF1dGhvci1sb2NrLXJlcXVlc3RlclwiOiBcIm9uQ2xpY2tSZXF1ZXN0TG9ja1wiXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwiY2hhbmdlOnJlcXVlc3RfbG9ja1wiLCB0aGlzLm9uUmVxdWVzdExvY2spO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIganNvbiA9IHRoaXMubW9kZWwudG9KU09OKCk7XG4gICAgICAgIGpzb24uaGF2ZV9sb2NrID0gR1JJRC5hdXRob3JzLmhhdmVMb2NrKCk7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChpY2gudHBsX2F1dGhvcihqc29uKSk7XG5cdCAgICB0aGlzLm9uUmVxdWVzdExvY2soKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbkNsaWNrU2VuZExvY2s6IGZ1bmN0aW9uKCl7XG4gICAgICAgIEdSSUQuYXN5bmMubG9ja2luZ19oYW5kb3Zlcih0aGlzLm1vZGVsLmdldChcImlkXCIpKTtcbiAgICB9LFxuICAgIG9uQ2xpY2tSZXF1ZXN0TG9jazogZnVuY3Rpb24oKXtcbiAgICAgICAgR1JJRC5hc3luYy5sb2NraW5nX3JlcXVlc3RfbG9jaygpO1xuICAgIH0sXG5cdG9uUmVxdWVzdExvY2s6IGZ1bmN0aW9uKCl7XG5cdFx0aWYodGhpcy5tb2RlbC5nZXQoXCJyZXF1ZXN0X2xvY2tcIikpe1xuXHRcdFx0dGhpcy4kZWwuYWRkQ2xhc3MoJ2FzeW5jLXJlcXVlc3QtbG9jaycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRlbC5yZW1vdmVDbGFzcygnYXN5bmMtcmVxdWVzdC1sb2NrJyk7XG5cdFx0fVxuICAgIH1cblxufSk7XG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgaWNoIGZyb20gJ2ljYW5oYXonXG5cbndpbmRvdy5BdXRob3JzID0gR3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1hdXRob3JzXCIsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhHUklELmF1dGhvcnMsIFwiYWRkXCIsIHRoaXMub25BZGRBdXRob3IpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKEdSSUQuYXV0aG9ycywgXCJyZW1vdmVcIiwgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKEdSSUQuYXV0aG9ycywgXCJyZXNldFwiLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oR1JJRC5hdXRob3JzLCBcImNoYW5nZVwiLCB0aGlzLnJlbmRlcik7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChpY2gudHBsX2F1dGhvcnMoKSk7XG4gICAgICAgIHRoaXMuJGxpc3QgPSB0aGlzLiRlbC5maW5kKFwiLmF1dGhvcnMtbGlzdFwiKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBHUklELmF1dGhvcnMuZWFjaChmdW5jdGlvbihhdXRob3Ipe1xuICAgICAgICAgICAgc2VsZi5vbkFkZEF1dGhvcihhdXRob3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvblJlc2l6ZTogZnVuY3Rpb24oaGVpZ2h0KXtcbiAgICAgICAgdGhpcy4kbGlzdC5jc3MoXCJoZWlnaHRcIiwgaGVpZ2h0K1wicHhcIik7XG5cbiAgICB9LFxuICAgIG9uQWRkQXV0aG9yOiBmdW5jdGlvbihhdXRob3Ipe1xuICAgICAgICB2YXIgYXV0aG9yID0gbmV3IEF1dGhvcih7bW9kZWw6IGF1dGhvcn0pO1xuICAgICAgICB0aGlzLiRsaXN0LmFwcGVuZChhdXRob3IucmVuZGVyKCkuJGVsKTtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSdcbmltcG9ydCBpY2ggZnJvbSAnaWNhbmhheidcbmltcG9ydCB7aW5pdEhUTUxFZGl0b3J9IGZyb20gXCIuLi91dGlsc1wiO1xuXG53aW5kb3cuQm94RWRpdG9yID0gR3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZ3JpZC1ib3gtZWRpdG9yXCIsXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdjbGljayAuZ3JpZC1lZGl0b3ItY29udHJvbHMgW3JvbGU9Y2FuY2VsXScgOiAnb25DYW5jZWwnLFxuICAgICAgICAnY2xpY2sgLmdyaWQtZWRpdG9yLWxlZ2VuZCcgOiAnb25Ub2dnbGUnLFxuICAgICAgICAnY2xpY2sgLmdyaWQtZWRpdG9yLWNvbnRyb2xzIFtyb2xlPXNhdmVdJyA6ICdvblNhdmUnLFxuICAgICAgICAnY2xpY2sgLmdyaWQtZWRpdG9yLWNvbnRyb2xzIFtyb2xlPXJldXNlXScgOiAnb25NYWtlUmV1c2FibGUnLFxuICAgICAgICAnY2xpY2sgLmdyaWQtZWRpdG9yLXVybC1idXR0b24nOiAnb25VcmxUb2dnbGUnXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc3R5bGVzPUdSSUQuZ2V0Qm94U3R5bGVzKCkudG9KU09OKCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIF8uZWFjaChzdHlsZXMsZnVuY3Rpb24oZWxlbSl7XG4gICAgICAgICAgICBpZihlbGVtLnNsdWc9PT1zZWxmLm1vZGVsLmdldChcInN0eWxlXCIpKVxuICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWQ9XCJcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kZWwuaHRtbChpY2gudHBsX2JveGVkaXRvcih7XG4gICAgICAgICAgICAnbGFuZ192YWx1ZXMnOmRvY3VtZW50LmxhbmdfdmFsdWVzLFxuICAgICAgICAgICAgJ2JveCc6dGhpcy5tb2RlbC50b0pTT04oKSxcbiAgICAgICAgICAgICdiX2luZGV4Jzp0aGlzLm1vZGVsLmdldEluZGV4KCksXG4gICAgICAgICAgICAnY19pZCc6dGhpcy5tb2RlbC5nZXRDb250YWluZXIoKS5nZXQoXCJpZFwiKSxcbiAgICAgICAgICAgICdzX2lkJzp0aGlzLm1vZGVsLmdldFNsb3QoKS5nZXQoXCJpZFwiKSxcbiAgICAgICAgICAgICdzdHlsZXMnOnN0eWxlcyxcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgY29udGVudHN0cnVjdHVyZT10aGlzLm1vZGVsLmdldChcImNvbnRlbnRzdHJ1Y3R1cmVcIik7XG4gICAgICAgIHZhciBmaWVsZGNvbnRhaW5lcj10aGlzLiRlbC5maW5kKFwiLmdyaWQtZHluYW1pYy1maWVsZHMgLmdyaWQtZWRpdG9yLWZpZWxkLXdyYXBwZXJcIik7XG4gICAgICAgIHZhciB2aWV3cz1bXTtcbiAgICAgICAgXy5lYWNoKGNvbnRlbnRzdHJ1Y3R1cmUsZnVuY3Rpb24oZWxlbSl7XG4gICAgICAgICAgICB2YXIgdHlwZT1lbGVtLnR5cGU7XG4gICAgICAgICAgICB2YXIgdmlldz1uZXcgYm94RWRpdG9yQ29udHJvbHNbdHlwZV0oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbW9kZWw6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3R1cmU6ZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOnNlbGYubW9kZWwuZ2V0KFwiY29udGVudFwiKSxcbiAgICAgICAgICAgICAgICAgICAgYm94OnNlbGYubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHBhdGg6XCJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIGZpZWxkY29udGFpbmVyLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlld3M9dmlld3M7XG5cbiAgICAgICAgaW5pdEhUTUxFZGl0b3IodGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmdyaWQtZWRpdG9yLXByb2xvZ1wiKSkudGhlbihlZGl0b3I9PnRoaXMucHJvbG9nRWRpdG9yID0gZWRpdG9yKTtcbiAgICAgICAgaW5pdEhUTUxFZGl0b3IodGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmdyaWQtZWRpdG9yLWVwaWxvZ1wiKSkudGhlbihlZGl0b3I9PnRoaXMuZXBpbG9nRWRpdG9yID0gZWRpdG9yKTtcblxuICAgICAgICBpZihHUklELmdldEJveFN0eWxlcygpLmxlbmd0aDwxKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmdyaWQtZWRpdG9yLWJveC1zdHlsZXMtd3JhcHBlclwiKS5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmdyaWQtY29sbGFwc2FibGUtc2hvd25cIikuYWRkQ2xhc3MoJ2dyaWQtYWN0aXZlJyk7XG5cblxuXG4gICAgICAgIGpRdWVyeS5lYWNoKHRoaXMuJGVsLmZpbmQoXCIuZ3JpZC1lZGl0b3ItdXJsLWlucHV0XCIpLCBmdW5jdGlvbihpbmRleCwgdmFsKSB7XG4gICAgICAgICAgICAgdmFyICR1cmwgPSBqUXVlcnkodmFsKTtcbiAgICAgICAgICAgICBpZigkdXJsLnZhbCgpID09IFwiXCIpe1xuICAgICAgICAgICAgICAgICR1cmwuc2libGluZ3MoJ2J1dHRvbicpLnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uKCl7XG4gICAgICAgIEdSSUQuaGlkZUVkaXRvcihmdW5jdGlvbigpe1xuICAgICAgICAgICAgR1JJRC4kcm9vdF9lZGl0b3IuaHRtbChcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uVG9nZ2xlOmZ1bmN0aW9uKGUpXG4gICAge1xuICAgICAgICBqUXVlcnkoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoKS50b2dnbGVDbGFzcygnZ3JpZC1hY3RpdmUnKTtcbiAgICB9LFxuXG4gICAgb25VcmxUb2dnbGU6IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgJHBhcmVudCA9IGpRdWVyeShlLnRhcmdldCkucGFyZW50KCk7XG4gICAgICAgIGlmKCRwYXJlbnQuaGFzQ2xhc3MoJ2dyaWQtZWRpdG9yLXVybC1zaG93Jykpe1xuICAgICAgICAgICAgJHBhcmVudC5maW5kKCdpbnB1dCcpLmF0dHIoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIikudmFsKFwiXCIpO1xuICAgICAgICAgICAgJHBhcmVudC5maW5kKCdidXR0b24nKS5odG1sKFwiQWRkIGxpbmtcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcGFyZW50LmZpbmQoJ2J1dHRvbicpLmh0bWwoXCJEZWxldGUgTGlua1wiKTtcbiAgICAgICAgICAgICRwYXJlbnQuZmluZCgnaW5wdXQnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGpRdWVyeShlLnRhcmdldCkucGFyZW50KCkudG9nZ2xlQ2xhc3MoJ2dyaWQtZWRpdG9yLXVybC1zaG93Jyk7XG4gICAgfSxcblxuICAgIG9uTWFrZVJldXNhYmxlOmZ1bmN0aW9uKGUpXG4gICAge1xuICAgICAgICBpZighY29uZmlybShkb2N1bWVudC5sYW5nX3ZhbHVlc1tcImNvbmZpcm0tYm94LXJldXNlXCJdKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLm1vZGVsLnNhdmUobnVsbCx7YWN0aW9uOlwicmV1c2VcIn0pO1xuICAgICAgICBHUklELmhpZGVFZGl0b3IoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIEdSSUQuJHJvb3RfZWRpdG9yLmh0bWwoXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvblNhdmU6ZnVuY3Rpb24oZSlcbiAgICB7XG4gICAgICAgIHZhciBvYmo9e307XG4gICAgICAgIF8uZWFjaCh0aGlzLnZpZXdzLGZ1bmN0aW9uKHZpZXcpe1xuICAgICAgICAgICAgb2JqW3ZpZXcubW9kZWwuc3RydWN0dXJlLmtleV09dmlldy5mZXRjaFZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgnY29udGVudCcsb2JqKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3RpdGxlJyx0aGlzLiRlbC5maW5kKFwiLmdyaWQtZWRpdG9yLXRpdGxlXCIpLnZhbCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3RpdGxldXJsJyx0aGlzLiRlbC5maW5kKFwiLmdyaWQtZWRpdG9yLXRpdGxldXJsXCIpLnZhbCgpKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnNldCgncHJvbG9nJyx0aGlzLnByb2xvZ0VkaXRvci5nZXREYXRhKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgnZXBpbG9nJyx0aGlzLmVwaWxvZ0VkaXRvci5nZXREYXRhKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNldCgncmVhZG1vcmUnLHRoaXMuJGVsLmZpbmQoJy5ncmlkLWVkaXRvci1yZWFkbW9yZScpLnZhbCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3JlYWRtb3JldXJsJyx0aGlzLiRlbC5maW5kKCcuZ3JpZC1lZGl0b3ItcmVhZG1vcmV1cmwnKS52YWwoKSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0KCdzdHlsZScsdGhpcy4kZWwuZmluZChcIi5ncmlkLWVkaXRvci1zdHlsZXMtd3JhcHBlciBzZWxlY3RcIikudmFsKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNhdmUoKTtcbiAgICAgICAgR1JJRC5oaWRlRWRpdG9yKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBHUklELiRyb290X2VkaXRvci5odG1sKFwiXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuYm94RWRpdG9yQ29udHJvbHM9e307XG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnXG5pbXBvcnQgaWNoIGZyb20gJ2ljYW5oYXonXG5pbXBvcnQge2luaXRIVE1MRWRpdG9yfSBmcm9tIFwiLi4vdXRpbHNcIjtcblxud2luZG93LkdyaWRDb250YWluZXJFZGl0b3IgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLWNvbnRhaW5lci1lZGl0b3JcIixcbiAgICBldmVudHM6IHtcbiAgICAgICAgJ2NsaWNrIC5ncmlkLWVkaXRvci1jb250cm9scyBbcm9sZT1jYW5jZWxdJyA6ICdvbkNhbmNlbCcsXG4gICAgICAgICdjbGljayAuZ3JpZC1lZGl0b3ItY29udHJvbHMgW3JvbGU9c2F2ZV0nIDogJ29uU2F2ZScsXG4gICAgICAgICdjbGljayAuZ3JpZC1lZGl0b3ItbGVnZW5kJyA6ICdvblRvZ2dsZScsXG4gICAgICAgICdjbGljayAuZ3JpZC1lZGl0b3ItdXJsLWJ1dHRvbic6ICdvblVybFRvZ2dsZSdcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIEdSSUQubG9nKHRoaXMubW9kZWwudG9KU09OKCkpO1xuICAgICAgICB2YXIgc3R5bGVzPUdSSUQuZ2V0Q29udGFpbmVyU3R5bGVzKCkudG9KU09OKCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIF8uZWFjaChzdHlsZXMsZnVuY3Rpb24oZWxlbSl7XG4gICAgICAgICAgICBpZihlbGVtLnNsdWc9PXNlbGYubW9kZWwuZ2V0KFwic3R5bGVcIikpXG4gICAgICAgICAgICAgICAgZWxlbS5zZWxlY3RlZD1cInNlbGVjdGVkXCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWxlbS5zZWxlY3RlZD1cIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbChpY2gudHBsX2NvbnRhaW5lcmVkaXRvcih7XG4gICAgICAgICAgICAnbGFuZ192YWx1ZXMnOmRvY3VtZW50LmxhbmdfdmFsdWVzLFxuICAgICAgICAgICAgJ21vZGVsJzp0aGlzLm1vZGVsLnRvSlNPTigpLFxuICAgICAgICAgICAgJ3N0eWxlcyc6c3R5bGVzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpbml0SFRNTEVkaXRvcih0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuZ3JpZC1lZGl0b3ItcHJvbG9nXCIpKS50aGVuKGVkaXRvcj0+dGhpcy5wcm9sb2dFZGl0b3IgPSBlZGl0b3IpO1xuICAgICAgICBpbml0SFRNTEVkaXRvcih0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuZ3JpZC1lZGl0b3ItZXBpbG9nXCIpKS50aGVuKGVkaXRvcj0+dGhpcy5lcGlsb2dFZGl0b3IgPSBlZGl0b3IpO1xuXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuZ3JpZC1jb2xsYXBzYWJsZS1zaG93blwiKS5hZGRDbGFzcyhcImdyaWQtYWN0aXZlXCIpO1xuXG4gICAgICAgIGpRdWVyeS5lYWNoKHRoaXMuJGVsLmZpbmQoXCIuZ3JpZC1lZGl0b3ItdXJsLWlucHV0XCIpLCBmdW5jdGlvbihpbmRleCwgdmFsKSB7XG4gICAgICAgICAgICAgdmFyICR1cmwgPSBqUXVlcnkodmFsKTtcbiAgICAgICAgICAgICBpZigkdXJsLnZhbCgpID09IFwiXCIpe1xuICAgICAgICAgICAgICAgICR1cmwuc2libGluZ3MoJ2J1dHRvbicpLnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblRvZ2dsZTpmdW5jdGlvbihlKVxuICAgIHtcbiAgICAgICAgalF1ZXJ5KGUuY3VycmVudFRhcmdldCkucGFyZW50KCkudG9nZ2xlQ2xhc3MoJ2dyaWQtYWN0aXZlJyk7XG4gICAgfSxcblxuICAgIG9uVXJsVG9nZ2xlOiBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyICRwYXJlbnQgPSBqUXVlcnkoZS50YXJnZXQpLnBhcmVudCgpO1xuICAgICAgICBpZigkcGFyZW50Lmhhc0NsYXNzKCdncmlkLWVkaXRvci11cmwtc2hvdycpKXtcbiAgICAgICAgICAgICRwYXJlbnQuZmluZCgnaW5wdXQnKS5hdHRyKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpLnZhbChcIlwiKTtcbiAgICAgICAgICAgICRwYXJlbnQuZmluZCgnYnV0dG9uJykuaHRtbChcIkFkZCBsaW5rXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHBhcmVudC5maW5kKCdidXR0b24nKS5odG1sKFwiRGVsZXRlIExpbmtcIik7XG4gICAgICAgICAgICAkcGFyZW50LmZpbmQoJ2lucHV0JykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBqUXVlcnkoZS50YXJnZXQpLnBhcmVudCgpLnRvZ2dsZUNsYXNzKCdncmlkLWVkaXRvci11cmwtc2hvdycpO1xuICAgIH0sXG5cbiAgICBvbkNhbmNlbDogZnVuY3Rpb24oKXtcbiAgICAgICAgR1JJRC5oaWRlRWRpdG9yKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBqUXVlcnkoR1JJRC4kcm9vdF9lZGl0b3IpLmh0bWwoXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvblNhdmU6ZnVuY3Rpb24oZSlcbiAgICB7XG4gICAgICAgIHZhciBjbGFzc19wcmVmaXggPSBcIi5ncmlkLWVkaXRvci1cIjtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3RpdGxlJyx0aGlzLiRlbC5maW5kKGNsYXNzX3ByZWZpeCtcInRpdGxlXCIpLnZhbCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3RpdGxldXJsJywgdGhpcy4kZWwuZmluZChjbGFzc19wcmVmaXgrXCJ0aXRsZXVybFwiKS52YWwoKSk7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3Byb2xvZycsdGhpcy5wcm9sb2dFZGl0b3IuZ2V0RGF0YSgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ2VwaWxvZycsdGhpcy5lcGlsb2dFZGl0b3IuZ2V0RGF0YSgpKTtcblxuICAgICAgICB0aGlzLm1vZGVsLnNldCgncmVhZG1vcmUnLCB0aGlzLiRlbC5maW5kKGNsYXNzX3ByZWZpeCtcInJlYWRtb3JlXCIpLnZhbCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3JlYWRtb3JldXJsJyx0aGlzLiRlbC5maW5kKGNsYXNzX3ByZWZpeCtcInJlYWRtb3JldXJsXCIpLnZhbCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3N0eWxlJywgdGhpcy4kZWwuZmluZChjbGFzc19wcmVmaXgrXCJzdHlsZVwiKS52YWwoKSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0KCdzdHlsZV9sYWJlbCcsIGpRdWVyeSh0aGlzLiRlbCkuZmluZChjbGFzc19wcmVmaXgrXCJzdHlsZSBvcHRpb246c2VsZWN0ZWRcIikudGV4dCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zYXZlKCk7XG4gICAgICAgIEdSSUQuaGlkZUVkaXRvcihmdW5jdGlvbigpe1xuICAgICAgICAgICAgR1JJRC4kcm9vdF9lZGl0b3IuaHRtbChcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSdcbmltcG9ydCBpY2ggZnJvbSAnaWNhbmhheidcblxud2luZG93LkdyaWRSZXZpc2lvbnNWaWV3ID0gR3JpZEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblx0dGFnTmFtZTogJ2RpdicsXG5cdGNsYXNzTmFtZTogJ2dyaWQtcmV2aXNpb25zJyxcblx0ZXZlbnRzOntcblx0XHQnY2xpY2sgW3JvbGU9cHJldmlld10nOidvblByZXZpZXcnLFxuXHRcdCdjbGljayBbcm9sZT1kZWxldGVdJzonb25EZWxldGUnLFxuXHRcdCdjbGljayBbcm9sZT1yZXZlcnRdJzonb25SZXZlcnQnXG5cdH0sXG5cdGluaXRpYWxpemU6ZnVuY3Rpb24oKXtcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2FkZCcsdGhpcy5yZW5kZXIpO1xuXHRcdHRoaXMuJGxpc3QgPSBqUXVlcnkoXCI8ZGl2IGNsYXNzPSdncmlkLXJldmlzaW9ucy1saXN0Jz48L3VsPlwiKTtcblx0XHR0aGlzLiRlbC5hcHBlbmQodGhpcy4kbGlzdCk7XG5cdFx0dGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMub25SZXZpc2lvbnNTY3JvbGwuYmluZCh0aGlzKSwxMDAwKTtcblx0fSxcblx0cmVuZGVyOmZ1bmN0aW9uKCl7XG5cdFx0dmFyIHJldmlzaW9ucz10aGlzLmNvbGxlY3Rpb24udG9KU09OKCk7XG5cdFx0Xy5lYWNoKHJldmlzaW9ucyxmdW5jdGlvbihlbGVtKXtcblx0XHRcdGVsZW0uaXNEcmFmdD1mYWxzZTtcblx0XHRcdGVsZW0uaXNQdWJsaXNoZWQ9ZmFsc2U7XG5cdFx0XHRlbGVtLmlzRGVwcmVjYXRlZD1mYWxzZTtcblx0XHRcdGlmKGVsZW0uc3RhdGU9PVwicHVibGlzaGVkXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW0uaXNQdWJsaXNoZWQ9dHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZWxlbS5zdGF0ZT09XCJkcmFmdFwiKVxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtLmlzRHJhZnQ9dHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZWxlbS5zdGF0ZT09XCJkZXByZWNhdGVkXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW0uaXNEZXByZWNhdGVkPXRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbGVtW1wicmVhZGFibGVfZGF0ZVwiXSA9IFwiLS0uLS0uLS0tLVwiO1xuXHRcdFx0aWYodHlwZW9mIGVsZW1bXCJkYXRlXCJdICE9IFwidW5kZWZpbmVkXCIgJiYgZWxlbVtcImRhdGVcIl0gIT0gXCJcIiAmJiBlbGVtW1wiZGF0ZVwiXSAhPSBudWxsKXtcblx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZShwYXJzZUludChlbGVtW1wiZGF0ZVwiXSkqMTAwMCk7XG5cdFx0XHRcdGVsZW1bXCJyZWFkYWJsZV9kYXRlXCJdID0gZGF0ZS5nZXREYXRlKCkrXCIuXCIrKGRhdGUuZ2V0TW9udGgoKSsxKStcIi5cIitkYXRlLmdldEZ1bGxZZWFyKCkrXCIgJmJ1bGw7IFwiK2RhdGUuZ2V0SG91cnMoKStcIjpcIitkYXRlLmdldE1pbnV0ZXMoKStcIjpcIitkYXRlLmdldFNlY29uZHMoKTtcblx0XHRcdH1cblx0XHRcdGlmKHR5cGVvZiBlbGVtW1wiZWRpdG9yXCJdID09PSBcInVuZGVmaW5lZFwiIHx8IGVsZW1bXCJlZGl0b3JcIl0gPT0gXCJcIiB8fCBlbGVtW1wiZWRpdG9yXCJdID09PSBudWxsKXtcblx0XHRcdFx0ZWxlbVtcImVkaXRvclwiXSA9IFwidW5rbm93blwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuJGxpc3QuaHRtbChpY2gudHBsX3JldmlzaW9ucyh7cmV2aXNpb25zOnJldmlzaW9ucyxsYW5nX3ZhbHVlczpkb2N1bWVudC5sYW5nX3ZhbHVlc30pKTtcblx0XHR2YXIgY2hpbGRfY291bnQgPSB0aGlzLiRsaXN0LmNoaWxkcmVuKCkubGVuZ3RoO1xuXHRcdHZhciBsaXN0X3dpZHRoID0gY2hpbGRfY291bnQgKiB0aGlzLiRsaXN0LmNoaWxkcmVuKCkubGFzdCgpLm91dGVyV2lkdGgodHJ1ZSk7XG5cdFx0dGhpcy4kbGlzdC5jc3MoXCJ3aWR0aFwiLCBsaXN0X3dpZHRoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRvblJldmlzaW9uc1Njcm9sbDogZnVuY3Rpb24oKXtcblx0XHRpZih0aGlzLmNvbGxlY3Rpb24ubmV4dHBhZ2UgPT0gLTEpIHJldHVybjtcblx0XHRpZighdGhpcy4kZWwuaXMoXCI6dmlzaWJsZVwiKSkgcmV0dXJuO1xuXHRcdHZhciBkaWZmID0gdGhpcy4kbGlzdC5vdXRlcldpZHRoKHRydWUpLU1hdGguYWJzKHRoaXMuJGxpc3QucG9zaXRpb24oKS5sZWZ0KTtcblx0XHRkaWZmID0gZGlmZiAtIHRoaXMuJGVsLm91dGVyV2lkdGgodHJ1ZSk7XG5cdFx0aWYoZGlmZiA8IDMwMCApe1xuXHRcdFx0dGhpcy5jb2xsZWN0aW9uLmZldGNoKHtwYWdlOnRoaXMuY29sbGVjdGlvbi5uZXh0cGFnZX0pO1xuXHRcdH1cblx0fSxcblx0b25QcmV2aWV3OmZ1bmN0aW9uKGUpe1xuXHRcdHZhciAkcmV2aXNpb24gPSBqUXVlcnkoZS50YXJnZXQpLnBhcmVudHMoXCIuZ3JpZC1yZXZpc2lvblwiKTtcblx0XHR2YXIgbG9jYXRpb24gPSAgR1JJRC5QUkVWSUVXX1BBVFRFUk4ucmVwbGFjZShcIntSRVZ9XCIsICRyZXZpc2lvbi5kYXRhKFwicmV2aXNpb25cIikpO1xuXHRcdHdpbmRvdy5vcGVuKGxvY2F0aW9uLFwiX2JsYW5rXCIpO1xuXHRcdHRoaXMuJGVsLnBhcmVudHMoXCIucmV2LXdyYXBwZXJcIikudG9nZ2xlKCk7XG5cdH0sXG5cdG9uRGVsZXRlOmZ1bmN0aW9uKGUpe1xuXHRcdGlmKCFHUklELmdldFJpZ2h0cygpLmdldChcInJldmVydFwiKSB8fCBHUklELmxvY2tlZCgpKXtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91IGhhdmUgbm8gcmlnaHRzIGZvciB0aGF0Li4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cdFx0R1JJRC5yZXZlcnQoKTtcblx0fSxcblx0b25SZXZlcnQ6ZnVuY3Rpb24oZSl7XG5cdFx0aWYoIUdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwicmV2ZXJ0XCIpIHx8IEdSSUQubG9ja2VkKCkpe1xuICAgICAgICAgICAgYWxlcnQoXCJZb3UgaGF2ZSBubyByaWdodHMgZm9yIHRoYXQuLi5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblx0XHR2YXIgcmV2aXNpb249alF1ZXJ5KGUudGFyZ2V0KS5wYXJlbnRzKFwiLmdyaWQtcmV2aXNpb25cIikuZGF0YShcInJldmlzaW9uXCIpO1xuXHRcdEdSSUQuc2V0VG9SZXZpc2lvbihyZXZpc2lvbik7XG5cdH1cbn0pO1xuIiwiLyoqXG4qIEBhdXRob3IgUGFsYXN0aG90ZWwgPHJlemVwdGlvbkBwYWxhc3Rob3RlbC5kZT5cbiogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQsIFBhbGFzdGhvdGVsXG4qIEBsaWNlbnNlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMi4wLmh0bWwgR1BMdjJcbiogQHBhY2thZ2UgUGFsYXN0aG90ZWxcXEdyaWRcbiovXG5cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgaWNoIGZyb20gJ2ljYW5oYXonXG5cbndpbmRvdy5HcmlkU2xvdFN0eWxlQ2hhbmdlclZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTpcImdyaWQtc2xvdC1zdHlsZS1jaGFuZ2VyIHN0eWxlLWNoYW5nZXJcIixcbiAgICB0YWdOYW1lOiBcImRpdlwiLFxuICAgIGV2ZW50czp7XG4gICAgICAgIFwiY2xpY2sgbGlcIjogXCJjaGFuZ2VTdHlsZVwiXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhHUklELmdldFNsb3RTdHlsZXMoKSxcImFkZFwiLHRoaXMucmVuZGVyKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgICAgdmFyIGFjdGl2ZXN0eWxlID0gXCJEZWZhdWx0IFN0eWxlXCI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgR1JJRC5nZXRTbG90U3R5bGVzKCkuZWFjaCggZnVuY3Rpb24oc3R5bGUpe1xuICAgICAgICAgICAgaWYoc3R5bGUuZ2V0KFwic2x1Z1wiKSA9PSBzZWxmLm1vZGVsLmdldChcInN0eWxlXCIpKSBhY3RpdmVzdHlsZSA9IHN0eWxlLmdldChcInRpdGxlXCIpO1xuICAgICAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUudG9KU09OKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbnRhaW5lcj10aGlzLm1vZGVsLmdldENvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLiRlbC5odG1sKGljaC50cGxfc2xvdHN0eWxlY2hhbmdlcih7c3R5bGVzOiBzdHlsZXMsIGFjdGl2ZXN0eWxlOiBhY3RpdmVzdHlsZSxyZXVzZWQ6Y29udGFpbmVyLmdldChcInJldXNlZFwiKX0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjaGFuZ2VTdHlsZTogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlXCIsalF1ZXJ5KGV2ZW50LnRhcmdldCkuYXR0cihcImRhdGEtc3R5bGVcIikpO1xuICAgICAgICB0aGlzLm1vZGVsLnNhdmUoKTtcbiAgICB9XG59KTtcbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuaW1wb3J0IGljaCBmcm9tICdpY2FuaGF6J1xuXG53aW5kb3cuR3JpZFRvb2xCb3hCbHVlcHJpbnRzVmlldyA9IEdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiBcImdyaWQtYm94LWJsdWVwcmludHNcIixcbiAgICB0aW1lcjpudWxsLFxuICAgIGJsdWVwcmludHM6IG51bGwsXG4gICAgZXZlbnRzOntcbiAgICAgICAgXCJrZXl1cCAuZ3JpZC1ib3gtYmx1ZXByaW50cy1zZWFyY2ggaW5wdXRcIjogXCJzZWFyY2hTdHJpbmdcIlxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmJsdWVwcmludHMgPSB0aGlzLm1vZGVsLmdldEJsdWVwcmludHMoKTtcbiAgICAgICAgdGhpcy5ib3hfdHlwZSA9IHRoaXMubW9kZWwuZ2V0KFwidHlwZVwiKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmJsdWVwcmludHMsXCJhZGRcIiwgdGhpcy5hZGRCbHVlcHJpbnRCb3gpO1xuICAgICAgICB0aGlzLm1vZGVsLnNlYXJjaEJveGVzKCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgaWYodGhpcy5tb2RlbC5nZXQoXCJjcml0ZXJpYVwiKS5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHZhciAkX3NlYXJjaCA9IGpRdWVyeSgnPGRpdiBjbGFzcz1cImdyaWQtYm94LWJsdWVwcmludHMtc2VhcmNoXCI+PGlucHV0IHBsYWNlaG9sZGVyPVwiV2hpY2ggZG8geW91IG5lZWQ/XCIgdHlwZT1cInRleHRcIiB2YWx1ZT1cIlwiIC8+PC9kaXY+Jyk7XG4gICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQoJF9zZWFyY2gpO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hTdHJpbmcoe3RhcmdldDokX3NlYXJjaC5maW5kKFwiaW5wdXRcIil9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRibHVlcHJpbnRzbGlzdCA9IGpRdWVyeShcIjxkaXYgY2xhc3M9J2dyaWQtYm94LWJsdWVwcmludHMtbGlzdCc+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kYmx1ZXByaW50c2xpc3QpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEJsdWVwcmludEJveDogZnVuY3Rpb24oYmx1ZXByaW50LGNvbGxlY3Rpb24sZXZlbnQpe1xuICAgICAgICB2YXIganNvbiA9IGJsdWVwcmludC50b0pTT04oKTtcbiAgICAgICAganNvbi5jaWQgPSBibHVlcHJpbnQuY2lkO1xuICAgICAgICBqc29uLnJldXNhYmxlID0gdGhpcy5ib3hfdHlwZSA9PSBcInJlZmVyZW5jZVwiO1xuICAgICAgICB0aGlzLiRibHVlcHJpbnRzbGlzdC5hcHBlbmQoaWNoLnRwbF90b29sQm94ZXNCbHVlcHJpbnQoanNvbikpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVzRHJhZ2dhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2VhcmNoU3RyaW5nOmZ1bmN0aW9uKGV2ZW50KXtcblxuICAgICAgICB2YXIgaW5wdXQ9alF1ZXJ5KGV2ZW50LnRhcmdldCkudmFsKCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIGlmKHRoaXMudGltZXIpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5zdG9wTGlzdGVuaW5nKHNlbGYuYmx1ZXByaW50cyk7XG4gICAgICAgICAgICBzZWxmLmJsdWVwcmludHM9c2VsZi5tb2RlbC5zZWFyY2goaW5wdXQsc2VsZi5tb2RlbC5jcml0ZXJpYSk7XG4gICAgICAgICAgICBzZWxmLiRibHVlcHJpbnRzbGlzdC5lbXB0eSgpO1xuICAgICAgICAgICAgc2VsZi5saXN0ZW5UbyhzZWxmLmJsdWVwcmludHMsIFwiYWRkXCIsIHNlbGYuYWRkQmx1ZXByaW50Qm94KTtcbiAgICAgICAgfSwzMDApO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZXNEcmFnZ2FibGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgalF1ZXJ5KHRoaXMuZWwpLmZpbmQoXCIuZ3JpZC1ib3gtZHJhZ2dlclwiKS5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgaGVscGVyOiBmdW5jdGlvbihldmVudCwgZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeShcIjxkaXYgY2xhc3M9J2RyYWdnZXItaGVscGVyJz48L2Rpdj5cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Vyc29yQXQ6IHsgbGVmdDogMzAsIHRvcDozMCB9LFxuICAgICAgICAgICAgekluZGV4OiAxOTksXG4gICAgICAgICAgICBhcHBlbmRUbzogR1JJRC5nZXRWaWV3KCkuJGVsLFxuICAgICAgICAgICAgYWRkQ2xhc3M6IHRydWUsXG4gICAgICAgICAgICAvL2Nvbm5lY3RUb1NvcnRhYmxlOiBHUklEX1NPUlRBQkxFLFxuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSl7XG5cbiAgICAgICAgICAgICAgICB2YXIgJCA9IGpRdWVyeTtcbiAgICAgICAgICAgICAgICB2YXIgJHNsb3RzID0galF1ZXJ5KEdSSUQuZ2V0VmlldygpLmVsKS5maW5kKFwiLmdyaWQtY29udGFpbmVyLXR5cGUtY1tkYXRhLXJldXNlZD1mYWxzZV0gLmdyaWQtc2xvdCAuZ3JpZC1ib3hlcy13cmFwcGVyXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCAuZ3JpZC1jb250YWluZXItdHlwZS1zYyAuZ3JpZC1zbG90IC5ncmlkLWJveGVzLXdyYXBwZXJcIik7XG4gICAgICAgICAgICAgICAgR1JJRC5sb2coJHNsb3RzKTtcbiAgICAgICAgICAgICAgICAvLyBkcm9wIHBsYWNlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgYm94ZXMgdG9nZ2xlZCBoaWRkZW5cbiAgICAgICAgICAgICAgICAvLyB2YXIgJHRvZ2dsZV9idG4gPSAkdG9vbGJhci5maW5kKFwiW3JvbGU9aGlkZV9ib3hlc11cIik7XG5cbiAgICAgICAgICAgICAgICAkc2xvdHMuY2hpbGRyZW4oXCIuZ3JpZC1ib3hcIikuYmVmb3JlKGpRdWVyeSggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImdyaWQtYm94LWRyb3AtYXJlYS13cmFwcGVyXCIpKTtcbiAgICAgICAgICAgICAgICAkc2xvdHMuYXBwZW5kKGpRdWVyeSggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImdyaWQtYm94LWRyb3AtYXJlYS13cmFwcGVyXCIpKTtcbiAgICAgICAgICAgICAgICAkc2xvdHMuZmluZChcIi5ncmlkLWJveC1kcm9wLWFyZWEtd3JhcHBlclwiKS5hcHBlbmQoalF1ZXJ5KCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZ3JpZC1ib3gtZHJvcC1hcmVhXCIpKTtcblxuICAgICAgICAgICAgICAgICRzbG90cy5maW5kKFwiLmdyaWQtYm94LWRyb3AtYXJlYVwiKS5kcm9wcGFibGUoe1xuICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6IFwiLmdyaWQtYm94LWRyYWdnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJDbGFzczogXCJob3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBkcm9wOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzX2JveCA9IGpRdWVyeSh1aS5kcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzX2Ryb3AgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXNfc2xvdCA9ICR0aGlzX2Ryb3AucGFyZW50cyhcIi5ncmlkLXNsb3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXNfY29udGFpbmVyID0gJHRoaXNfc2xvdC5wYXJlbnRzKFwiLmdyaWQtY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBHUklELmdldE1vZGVsKCkuZ2V0Q29udGFpbmVycygpLmdldCgkdGhpc19jb250YWluZXIuZGF0YShcImlkXCIpKS5nZXRTbG90cygpLmdldCgkdGhpc19zbG90LmRhdGEoXCJpZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmx1ZXByaW50ID0gc2VsZi5ibHVlcHJpbnRzLmdldCgkdGhpc19ib3guZGF0YShcImNpZFwiKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkbmV3X2JveCA9ICR0aGlzX2Ryb3AucGFyZW50KCkuYWRkQ2xhc3MoJ2dyaWQtbmV3LWJveC1wbGFjZScpLnJlbW92ZUNsYXNzKCdncmlkLWJveC1kcm9wLWFyZWEtd3JhcHBlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgR1JJRC5nZXRWaWV3KCkuJGVsLmZpbmQoXCIuZ3JpZC1ib3gtZHJvcC1hcmVhLXdyYXBwZXJcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSBzbG90LmNyZWF0ZUJveChibHVlcHJpbnQsICRuZXdfYm94LmluZGV4KCkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSApe1xuICAgICAgICAgICAgICAgIEdSSUQuZ2V0VmlldygpLiRlbC5maW5kKFwiLmdyaWQtYm94LWRyb3AtYXJlYS13cmFwcGVyXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbiIsIi8qKlxuKiBAYXV0aG9yIFBhbGFzdGhvdGVsIDxyZXplcHRpb25AcGFsYXN0aG90ZWwuZGU+XG4qIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0LCBQYWxhc3Rob3RlbFxuKiBAbGljZW5zZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTIuMC5odG1sIEdQTHYyXG4qIEBwYWNrYWdlIFBhbGFzdGhvdGVsXFxHcmlkXG4qL1xuXG5pbXBvcnQgR3JpZEJhY2tib25lIGZyb20gJ2JhY2tib25lJ1xuaW1wb3J0IGljaCBmcm9tICdpY2FuaGF6J1xuXG53aW5kb3cuR3JpZFRvb2xCb3hUeXBlc1ZpZXcgPSBHcmlkQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJncmlkLXRvb2wgZ3JpZC1lbGVtZW50LWJveFwiLFxuICAgIGV2ZW50czp7XG4gICAgXHRcImNsaWNrIC5ncmlkLWJveC10eXBlXCI6IFwidG9nZ2xlQm94VHlwZVwiXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgXHR2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHZhciBqc29uID0ge2JveHR5cGVzOltdfTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24oYm94dHlwZSwgaW5kZXgpe1xuICAgICAgICAgICAgdmFyIGJveHR5cGVfanNvbiA9IGJveHR5cGUudG9KU09OKCk7XG4gICAgICAgICAgICBib3h0eXBlX2pzb24uaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGpzb24uYm94dHlwZXMucHVzaChib3h0eXBlX2pzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGljaC50cGxfdG9vbEJveGVzKGpzb24pKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvZ2dsZUJveFR5cGU6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdmFyICR0aGlzID0galF1ZXJ5KGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAkdGhpcy50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIGlmKCR0aGlzLmhhc0NsYXNzKCdhY3RpdmUnKSl7XG4gICAgICAgICAgICB2YXIgYmx1ZXByaW50c192aWV3ID0gbmV3IEdyaWRUb29sQm94Qmx1ZXByaW50c1ZpZXcoe21vZGVsOnRoaXMuY29sbGVjdGlvbi5hdCgkdGhpcy5kYXRhKFwiaW5kZXhcIikpfSk7XG4gICAgICAgICAgICAkdGhpcy5uZXh0KFwiZGRcIikuYXBwZW5kKGJsdWVwcmludHNfdmlldy5yZW5kZXIoKS5lbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdGhpcy5uZXh0KFwiZGRcIikuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cbmltcG9ydCBHcmlkQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnXG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJ1xuaW1wb3J0IGljaCBmcm9tICdpY2FuaGF6J1xuXG53aW5kb3cuR3JpZFRvb2xDb250YWluZXJzVmlldyA9IEdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiBcImdyaWQtdG9vbCBncmlkLWVsZW1lbnQtY29udGFpbmVyXCIsXG4gICAgZXZlbnRzOntcbiAgICAgICAgXCJjbGljayAuZ3JpZC1jb250YWluZXItdHlwZVwiOiBcInJlbmRlckNvbnRhaW5lclR5cGVcIlxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoaWNoLnRwbF90b29sQ29udGFpbmVycyh7fSkpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIC8vIGlmIHlvdSB3YW50IHRvIHNob3cgY29udGFpbmVycyBvbiBkZWZhdWx0IHVuY29tbWVudCBuZXh0IGxpbmVcbiAgICAgICAgLy90aGlzLiRlbC5maW5kKFwiLmdyaWQtY29udGFpbmVyLXR5cGVcIikuZmlyc3QoKS50cmlnZ2VyKFwiY2xpY2tcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyQ29udGFpbmVyVHlwZTogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICB2YXIgJHR5cGUgPSBqUXVlcnkoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgICR0eXBlLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgdmFyIHJvbGUgPSAkdHlwZS5hdHRyKFwicm9sZVwiKTtcbiAgICAgICAgdmFyIGxpc3QgPSBcIlwiO1xuICAgICAgICBpZihyb2xlID09PSBcInJldXNhYmxlXCIpe1xuICAgICAgICAgICAgLy8gcmV1c2FibGVzXG4gICAgICAgICAgICB2YXIgcmV1c2FibGVzID0gdGhpcy5nZXRSZXVzYWJsZSgpO1xuICAgICAgICAgICAgbGlzdCA9IHRoaXMuZ2V0UmVuZGVyZWRDb250YWluZXJMaXN0KHJldXNhYmxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb250YWluZXJzXG4gICAgICAgICAgICB2YXIgY29udGFpbmVycyA9IHRoaXMuZ2V0Q29udGFpbmVycyhyb2xlKTtcbiAgICAgICAgICAgIGxpc3QgPSB0aGlzLmdldFJlbmRlcmVkQ29udGFpbmVyTGlzdChjb250YWluZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBET00gbWFuaXB1bGF0aW9uXG4gICAgICAgIGlmKCR0eXBlLmhhc0NsYXNzKCdhY3RpdmUnKSl7XG4gICAgICAgICAgICAvLyBhZGQgZWxlbWVudHNcbiAgICAgICAgICAgICR0eXBlLm5leHQoXCJkZFwiKS5hcHBlbmQobGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZWxlbWVudHNcbiAgICAgICAgICAgICR0eXBlLm5leHQoXCJkZFwiKS5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZXNEcmFnZ2FibGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRSZW5kZXJlZENvbnRhaW5lckxpc3Q6IGZ1bmN0aW9uKGpzb24pe1xuICAgICAgICByZXR1cm4gaWNoLnRwbF90b29sQ29udGFpbmVyc0NvbnRhaW5lcihqc29uKTtcbiAgICB9LFxuICAgIGdldENvbnRhaW5lcnM6IGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgICB2YXIgc2NvcGVfdHlwZSA9IFwiYy1cIjtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XG4gICAgICAgIHZhciBjb250YWluZXJzID0geyBjb250YWluZXJzOiB0aGlzLmNvbGxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgXy5lYWNoKGNvbnRhaW5lcnMuY29udGFpbmVycywgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCl7XG5cbiAgICAgICAgICAgIGlmKCB2YWx1ZS50eXBlLmluZGV4T2Yoc2NvcGVfdHlwZSkgIT09IDAgKXtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29udGFpbmVycy5jb250YWluZXJzW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlLnNsb3RzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzX2RpbWVuc2lvbiA9IGNvbGxlY3Rpb24uYXQoa2V5KS5nZXREaW1lbnNpb24oKS5zcGxpdChcIi1cIik7XG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAgO2kgPCB2YWx1ZS5udW1zbG90czsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xvdHMucHVzaCh7ZGltZW5zaW9uOiBzbG90c19kaW1lbnNpb25baV19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGFpbmVycztcbiAgICB9LFxuICAgIGdldFJldXNhYmxlOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4geyBjb250YWluZXJzOiBHUklELmdldFJldXNhYmxlQ29udGFpbmVycygpLnRvSlNPTigpIH07XG4gICAgfSxcbiAgICBpbml0aWFsaXplc0RyYWdnYWJsZTogZnVuY3Rpb24oKXtcbiAgICAgICAgalF1ZXJ5KHRoaXMuZWwpLmZpbmQoXCIuZ3JpZC1uZXctZWxlbWVudFwiKS5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgaGVscGVyOiBmdW5jdGlvbihldmVudCwgZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeShcIjxkaXYgY2xhc3M9J2RyYWdnZXItaGVscGVyJz48L2Rpdj5cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Vyc29yQXQ6IHsgbGVmdDogMzAsIHRvcDozMCB9LFxuICAgICAgICAgICAgekluZGV4OiA5OSxcbiAgICAgICAgICAgIGFwcGVuZFRvOiBHUklELmdldFZpZXcoKS4kZWwsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKXtcbiAgICAgICAgICAgICAgICBHUklELmxvZyhcIlN0YXJ0IGRyYWdnaW5nXCIpO1xuICAgICAgICAgICAgICAgIHZhciAkID0galF1ZXJ5O1xuICAgICAgICAgICAgICAgIHZhciAkZ3JpZCA9IEdSSUQuZ2V0VmlldygpLiRlbDtcblxuICAgICAgICAgICAgICAgIHZhciAkY29udGFpbmVycyA9ICRncmlkLmZpbmQoJy5ncmlkLWNvbnRhaW5lcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyICRkcm9wQXJlYSA9IGpRdWVyeShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJjb250YWluZXItZHJvcC1hcmVhLXdyYXBwZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLXR5cGVcIixcImNvbnRhaW5lci1kcm9wLWFyZWEtd3JhcHBlclwiKTtcbiAgICAgICAgICAgICAgICAkZ3JpZC5maW5kKFwiLmNvbnRhaW5lcnMtd3JhcHBlclwiKS5wcmVwZW5kKCRkcm9wQXJlYS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAkY29udGFpbmVycy5hZnRlciggJGRyb3BBcmVhLmNsb25lKCkgKTtcbiAgICAgICAgICAgICAgICAkZ3JpZC5maW5kKFwiLmNvbnRhaW5lci1kcm9wLWFyZWEtd3JhcHBlclwiKS5hcHBlbmQoalF1ZXJ5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKFwiY29udGFpbmVyLWRyb3AtYXJlYVwiKSk7XG4gICAgICAgICAgICAgICAgJGdyaWQuZmluZChcIi5jb250YWluZXItZHJvcC1hcmVhXCIpLmRyb3BwYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdDogXCIuZ3JpZC1uZXctZWxlbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICBob3ZlckNsYXNzOiBcImhvdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGRyb3A6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkZHJhZ2dhYmxlID0galF1ZXJ5KHVpLmRyYWdnYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyUmV1c2FibGUgPSAkZHJhZ2dhYmxlLmRhdGEoXCJyZXVzYWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJUeXBlID0gICRkcmFnZ2FibGUuZGF0YShcInR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGRyb3B3cmFwcGVyID0galF1ZXJ5KHRoaXMpLnBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkZHJvcHdyYXBwZXIucmVtb3ZlQ2xhc3MoJ2NvbnRhaW5lci1kcm9wLWFyZWEtd3JhcHBlcicpLmFkZENsYXNzKCduZXctY29udGFpbmVyLXRhcmdldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgR1JJRC5nZXRWaWV3KCkuJGVsLmZpbmQoJy5jb250YWluZXItZHJvcC1hcmVhLXdyYXBwZXInKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdfaW5kZXggPSAkZHJvcHdyYXBwZXIuaW5kZXgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29udGFpbmVyUmV1c2FibGUgPT0gdHJ1ZSB8fCBjb250YWluZXJSZXVzYWJsZSA9PSBcInRydWVcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IEdSSUQuZ2V0UmV1c2FibGVDb250YWluZXJzKCkuYXQoJGRyYWdnYWJsZS5pbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHUklELmdldE1vZGVsKCkuYWRkUmV1c2VDb250YWluZXIoY29udGFpbmVyLCBuZXdfaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdSSUQubG9nKFtcIlJFVVNFRFwiLCBjb250YWluZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEdSSUQuZ2V0TW9kZWwoKS5jcmVhdGVDb250YWluZXIoY29udGFpbmVyVHlwZSwgbmV3X2luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWkgKXtcbiAgICAgICAgICAgICAgICBHUklELmdldFZpZXcoKS4kZWwuZmluZCgnLmNvbnRhaW5lci1kcm9wLWFyZWEtd3JhcHBlcicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG4iLCIvKipcbiogQGF1dGhvciBQYWxhc3Rob3RlbCA8cmV6ZXB0aW9uQHBhbGFzdGhvdGVsLmRlPlxuKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCwgUGFsYXN0aG90ZWxcbiogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC0yLjAuaHRtbCBHUEx2MlxuKiBAcGFja2FnZSBQYWxhc3Rob3RlbFxcR3JpZFxuKi9cblxuaW1wb3J0IEdyaWRCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSdcbmltcG9ydCBpY2ggZnJvbSAnaWNhbmhheidcblxud2luZG93LkdyaWRUb29sYmFyVmlldyA9IEdyaWRCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaWQ6XCJncmlkLXRvb2xiYXJcIixcbiAgICBfdG9vbENvbnRhaW5lcnNWaWV3OiBudWxsLFxuICAgIF90b29sQm94ZXNWaWV3OiBudWxsLFxuICAgIF9yZXZpc2lvbnNWaWV3OiBudWxsLFxuICAgIGV2ZW50czp7XG4gICAgICAgIFwiY2xpY2sgLmdyaWQtdG9vbGJhciBbcm9sZT1wdWJsaXNoXVwiOiBcInB1Ymxpc2hcIixcbiAgICAgICAgXCJjbGljayAuZ3JpZC10b29sYmFyIFtyb2xlPXByZXZpZXddXCI6IFwicHJldmlld1wiLFxuICAgICAgICBcImNsaWNrIC5ncmlkLXRvb2xiYXIgW3JvbGU9cmV2ZXJ0XVwiOiBcInJldmVydFwiLFxuICAgICAgICBcImNsaWNrIC5ncmlkLXRvb2xiYXIgW3JvbGU9cmV2aXNpb25zXVwiOiBcInJldmlzaW9uc1wiLFxuICAgICAgICBcImNsaWNrIC5ncmlkLXRvb2xiYXIgW3JvbGU9YXV0aG9yc11cIjogXCJvbkNsaWNrQXV0aG9yc1wiLFxuICAgICAgICBcImNsaWNrIC5ncmlkLWVsZW1lbnQtdHlwZVtkYXRhLXR5cGU9Ym94XTpub3QoLmFjdGl2ZSlcIjogXCJzaG93Qm94VG9vbHNcIixcbiAgICAgICAgXCJjbGljayAuZ3JpZC1lbGVtZW50LXR5cGVbZGF0YS10eXBlPWNvbnRhaW5lcl06bm90KC5hY3RpdmUpXCI6IFwic2hvd0NvbnRhaW5lclRvb2xzXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwiY2hhbmdlOmlzRHJhZnRcIiwgdGhpcy5zZXRTdGF0ZSk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oR1JJRC5hdXRob3JzLCBcImFkZFwiLCB0aGlzLm9uVXBkYXRlQXV0aG9ycyk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oR1JJRC5hdXRob3JzLCBcInJlbW92ZVwiLCB0aGlzLm9uVXBkYXRlQXV0aG9ycyk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oR1JJRC5hdXRob3JzLCBcInJlc2V0XCIsIHRoaXMub25VcGRhdGVBdXRob3JzKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLiRlbC5odG1sKGljaC50cGxfdG9vbGJhcih0aGlzLm1vZGVsLnRvSlNPTigpKSk7XG5cbiAgICAgICAgdGhpcy4kdG9vbGJhciA9IHRoaXMuJGVsLmZpbmQoXCIuZ3JpZC10b29sYmFyXCIpO1xuXG4gICAgICAgIHRoaXMuJHRvb2xfZWxlbWVudHMgPSB0aGlzLiRlbC5maW5kKFwiLmdyaWQtdG9vbC1lbGVtZW50c1wiKTtcbiAgICAgICAgdGhpcy4kdG9vbF9lbGVtZW50X2NvbnRlbnQgPSB0aGlzLiRlbC5maW5kKFwiLmdyaWQtZWxlbWVudC10eXBlLWNvbnRlbnRcIik7XG4gICAgICAgIHRoaXMuJHRhYl9jb250YWluZXIgPSB0aGlzLiRlbC5maW5kKFwiLmdyaWQtZWxlbWVudC10eXBlW2RhdGEtdHlwZT1jb250YWluZXJdXCIpO1xuICAgICAgICB0aGlzLiR0YWJfYm94ID0gdGhpcy4kZWwuZmluZChcIi5ncmlkLWVsZW1lbnQtdHlwZVtkYXRhLXR5cGU9Ym94XVwiKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudF90cmFzaCA9IHRoaXMuJGVsLmZpbmQoXCIuZ3JpZC1lbGVtZW50LXRyYXNoXCIpO1xuICAgICAgICB0aGlzLiRhdXRob3JzX2NvdW50ID0gdGhpcy4kZWwuZmluZChcIi5pbmRpY2F0b3ItYXV0aG9ycy1jb3VudFwiKTtcblxuICAgICAgICBpZihHUklELm1vZGUgPT0gXCJncmlkXCIpe1xuICAgICAgICAgICB0aGlzLl9yZXZpc2lvbnNWaWV3ID0gbmV3IEdyaWRSZXZpc2lvbnNWaWV3KHtjb2xsZWN0aW9uOkdSSUQucmV2aXNpb25zfSk7XG4gICAgICAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9yZXZpc2lvbnNWaWV3LiRlbC5oaWRlKCkpO1xuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSBcImNvbnRhaW5lclwiO1xuICAgICAgICBpZihHUklELm1vZGUgPT0gXCJjb250YWluZXJcIiB8fCAhR1JJRC5nZXRSaWdodHMoKS5nZXQoXCJjcmVhdGUtY29udGFpbmVyXCIpKXtcbiAgICAgICAgICAgIHRoaXMuJHRhYl9jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0eXBlID0gXCJib3hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZighR1JJRC5nZXRSaWdodHMoKS5nZXQoXCJjcmVhdGUtYm94XCIpKXtcbiAgICAgICAgICAgIHRoaXMuJHRhYl9ib3gucmVtb3ZlKCk7XG4gICAgICAgICAgICB0eXBlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlID09IFwiY29udGFpbmVyXCIgKXtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRhaW5lclRvb2xzKCk7XG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09IFwiYm94XCIpe1xuICAgICAgICAgICAgdGhpcy5zaG93Qm94VG9vbHMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVXBkYXRlQXV0aG9ycygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHVibGlzaDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIUdSSUQuZ2V0UmlnaHRzKCkuZ2V0KFwicHVibGlzaFwiKSB8fCBHUklELmxvY2tlZCgpKXtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91IGhhdmUgbm8gcmlnaHRzIGZvciB0aGF0Li4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuc2F2ZSgpO1xuICAgIH0sXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBpc0RyYWZ0ID0gdGhpcy5tb2RlbC5nZXQoXCJpc0RyYWZ0XCIpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiLmdyaWQtdG9vbGJhclwiKS5hdHRyKFwiZGF0YS1kcmFmdFwiLCBpc0RyYWZ0KTtcbiAgICAgICAgdmFyICRidXR0b24gPSB0aGlzLiRlbC5maW5kKFwiLmdyaWQtdG9vbC1zdGF0ZSBzcGFuXCIpO1xuICAgICAgICBpZihpc0RyYWZ0KXtcbiAgICAgICAgICAgICRidXR0b24uaHRtbChcIkRyYWZ0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGJ1dHRvbi5odG1sKFwiUHVibGlzaGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmV2aWV3OiBmdW5jdGlvbigpe1xuICAgICAgICB3aW5kb3cub3Blbih0aGlzLm1vZGVsLmdldChcIlBSRVZJRVdfVVJMXCIpLFwiZ3JpZF9wcmV2aWV3XCIpO1xuICAgIH0sXG4gICAgcmV2ZXJ0OiBmdW5jdGlvbigpe1xuICAgICAgICBpZighR1JJRC5nZXRSaWdodHMoKS5nZXQoXCJyZXZlcnRcIikgfHwgR1JJRC5sb2NrZWQoKSApe1xuICAgICAgICAgICAgYWxlcnQoXCJZb3UgaGF2ZSBubyByaWdodHMgZm9yIHRoYXQuLi5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgR1JJRC5yZXZlcnQoKTtcbiAgICB9LFxuICAgIHJldmlzaW9uczogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fcmV2aXNpb25zVmlldy4kZWwuc2xpZGVUb2dnbGUoKTtcbiAgICAgICAgalF1ZXJ5KFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHtzY3JvbGxUb3A6IDB9LDMwMCk7XG4gICAgfSxcbiAgICB0b2dnbGVCb3hlczogZnVuY3Rpb24oKXtcbiAgICAgICAgR1JJRC5sb2coXCJCVE4gdG9nZ2xlQm94ZXNcIik7XG4gICAgfSxcbiAgICAvLyBjb250YWluZXIgdG9vbHNcbiAgICBnZXRUb29sQ29udGFpbmVyc1ZpZXc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCEodGhpcy5fdG9vbENvbnRhaW5lcnNWaWV3IGluc3RhbmNlb2YgR3JpZFRvb2xDb250YWluZXJzVmlldykgKXtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2xDb250YWluZXJzVmlldyA9IG5ldyBHcmlkVG9vbENvbnRhaW5lcnNWaWV3KHtjb2xsZWN0aW9uOkdSSUQuZ2V0Q29udGFpbmVyVHlwZXMoKX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b29sQ29udGFpbmVyc1ZpZXc7XG4gICAgfSxcbiAgICBjb250YWluZXJUb29sc1Zpc2libGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiAodGhpcy4kZWwuZmluZCh0aGlzLmdldFRvb2xDb250YWluZXJzVmlldygpLmVsKS5sZW5ndGggPT0gMSk7XG4gICAgfSxcbiAgICB0b2dnbGVDb250YWluZXJUb29sczogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5oaWRlQm94VG9vbHMoKTtcbiAgICAgICAgaWYoIXRoaXMuY29udGFpbmVyVG9vbHNWaXNpYmxlKCkpe1xuICAgICAgICAgICAgdGhpcy5zaG93Q29udGFpbmVyVG9vbHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbnRhaW5lclRvb2xzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNob3dDb250YWluZXJUb29sczogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5oaWRlQm94VG9vbHMoKTtcbiAgICAgICAgaWYoIXRoaXMuY29udGFpbmVyVG9vbHNWaXNpYmxlKCkpe1xuICAgICAgICAgICAgdGhpcy4kZWwuZmluZCh0aGlzLmdldFRvb2xDb250YWluZXJzVmlldygpLmVsKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoJy5ncmlkLWVsZW1lbnQtdHlwZS1jb250ZW50JykuYXBwZW5kKHRoaXMuZ2V0VG9vbENvbnRhaW5lcnNWaWV3KCkucmVuZGVyKCkuZWwpO1xuICAgICAgICAgICAgdGhpcy4kdGFiX2NvbnRhaW5lci5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhpZGVDb250YWluZXJUb29sczogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMuY29udGFpbmVyVG9vbHNWaXNpYmxlKCkgKXtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQodGhpcy5nZXRUb29sQ29udGFpbmVyc1ZpZXcoKS5lbCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLiR0YWJfY29udGFpbmVyLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gYm94ZXMgdG9vbHNcbiAgICBnZXRUb29sQm94ZXNWaWV3OiBmdW5jdGlvbigpe1xuICAgICAgICBpZighKHRoaXMuX3Rvb2xCb3hlc1ZpZXcgaW5zdGFuY2VvZiBHcmlkVG9vbEJveFR5cGVzVmlldykgKXtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2xCb3hlc1ZpZXcgPSBuZXcgR3JpZFRvb2xCb3hUeXBlc1ZpZXcoe2NvbGxlY3Rpb246R1JJRC5nZXRCb3hUeXBlcygpfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rvb2xCb3hlc1ZpZXc7XG4gICAgfSxcbiAgICBib3hUb29sc1Zpc2libGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiAodGhpcy4kZWwuZmluZCh0aGlzLmdldFRvb2xCb3hlc1ZpZXcoKS5lbCkubGVuZ3RoID09IDEpO1xuICAgIH0sXG4gICAgdG9nZ2xlQm94VG9vbHM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuaGlkZUNvbnRhaW5lclRvb2xzKCk7XG4gICAgICAgIGlmKCF0aGlzLmJveFRvb2xzVmlzaWJsZSgpKXtcbiAgICAgICAgICAgIHRoaXMuc2hvd0JveFRvb2xzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVCb3hUb29scygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaG93Qm94VG9vbHM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuaGlkZUNvbnRhaW5lclRvb2xzKCk7XG4gICAgICAgIGlmKCF0aGlzLmJveFRvb2xzVmlzaWJsZSgpKXtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoJy5ncmlkLWVsZW1lbnQtdHlwZS1jb250ZW50JykuYXBwZW5kKHRoaXMuZ2V0VG9vbEJveGVzVmlldygpLnJlbmRlcigpLmVsKTtcbiAgICAgICAgICAgIHRoaXMuJHRhYl9ib3guYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoaWRlQm94VG9vbHM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuYm94VG9vbHNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuJHRhYl9ib3gucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy4kZWwuZmluZCh0aGlzLmdldFRvb2xCb3hlc1ZpZXcoKS5lbCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIHJlc2l6ZSBDb250YWluZXIgYW5kIEJveCB0b29sYmFyXG4gICAgb25SZXNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3aW5kb3dfaGVpZ2h0ID0galF1ZXJ5KHdpbmRvdykuaGVpZ2h0KCk7XG4gICAgICAgIHZhciBlbGVtZW50c190b3Bfb2Zmc2V0ID0gdGhpcy4kZWwub2Zmc2V0KCkudG9wO1xuICAgICAgICB2YXIgdGFiX2hlaWdodCA9IHRoaXMuJHRhYl9jb250YWluZXIub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHdpbmRvd19oZWlnaHQtZWxlbWVudHNfdG9wX29mZnNldC10YWJfaGVpZ2h0O1xuICAgICAgICB0aGlzLiR0b29sX2VsZW1lbnRfY29udGVudC5jc3MoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0b29sYmFyX3Jlc2l6ZScsaGVpZ2h0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGF1dGhvcnMgYnV0dG9uXG4gICAgICovXG4gICAgb25VcGRhdGVBdXRob3JzOiBmdW5jdGlvbigpe1xuICAgICAgICBpZihHUklELmF1dGhvcnMuZ2V0Q291bnQoKSA8IDIpe1xuICAgICAgICAgICAgdGhpcy4kYXV0aG9yc19jb3VudC5wYXJlbnRzKFwibGlcIikuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kYXV0aG9yc19jb3VudC5wYXJlbnRzKFwibGlcIikuc2hvdygpO1xuICAgICAgICAgICAgdGhpcy4kYXV0aG9yc19jb3VudC50ZXh0KEdSSUQuYXV0aG9ycy5nZXRDb3VudCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0b29sYmFyLnJlbW92ZUNsYXNzKFwiYXN5bmMtcmVxdWVzdC1sb2NrXCIpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIEdSSUQuYXV0aG9ycy5lYWNoKGZ1bmN0aW9uKGF1dGhvcil7XG4gICAgICAgICAgICBpZihhdXRob3IuZ2V0KFwicmVxdWVzdF9sb2NrXCIpKXtcbiAgICAgICAgICAgICAgICBzZWxmLiR0b29sYmFyLmFkZENsYXNzKFwiYXN5bmMtcmVxdWVzdC1sb2NrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xpY2tBdXRob3JzOiBmdW5jdGlvbihlKXtcbiAgICAgICAgR1JJRC50b2dnbGVBdXRob3JzKCk7XG4gICAgICAgIHRoaXMuJHRvb2xiYXIucmVtb3ZlQ2xhc3MoXCJhc3luYy1yZXF1ZXN0LWxvY2tcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiB3aGVuIHVzZXIgcmVxdWVzdHMgbG9jayBldmVudFxuICAgICAqL1xuICAgIGFzeW5jX3JlcXVlc3RfbG9jazogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy4kdG9vbGJhci5hZGRDbGFzcyhcImFzeW5jLXJlcXVlc3QtbG9ja1wiKTtcbiAgICB9XG59KTtcblxuIiwiLyogKGlnbm9yZWQpICovIiwibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7Il0sInNvdXJjZVJvb3QiOiIifQ==